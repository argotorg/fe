use super::intrinsic

pub trait AsBytes {
    const N: usize
    const fn as_bytes(self) -> [u8; Self::N]
}

impl<const LEN: usize> AsBytes for [u8; LEN] {
    const N: usize = LEN
    const fn as_bytes(self) -> [u8; Self::N] { self }
}

impl<const LEN: usize> AsBytes for String<LEN> {
    const N: usize = LEN
    const fn as_bytes(self) -> [u8; Self::N] { intrinsic::__as_bytes(self) }
}

impl AsBytes for u256 {
    const N: usize = 32
    const fn as_bytes(self) -> [u8; Self::N] { intrinsic::__as_bytes(self) }
}

impl<T0, T1> AsBytes for (T0, T1)
    where T0: AsBytes,
          T1: AsBytes
{
    const N: usize = T0::N + T1::N
    const fn as_bytes(self) -> [u8; Self::N] {
        intrinsic::__as_bytes((self.0.as_bytes(), self.1.as_bytes()))
    }
}

impl<T0, T1, T2> AsBytes for (T0, T1, T2)
    where T0: AsBytes,
          T1: AsBytes,
          T2: AsBytes
{
    const N: usize = T0::N + T1::N + T2::N
    const fn as_bytes(self) -> [u8; Self::N] {
        intrinsic::__as_bytes((self.0.as_bytes(), self.1.as_bytes(), self.2.as_bytes()))
    }
}

impl<T0, T1, T2, T3> AsBytes for (T0, T1, T2, T3)
    where T0: AsBytes,
          T1: AsBytes,
          T2: AsBytes,
          T3: AsBytes
{
    const N: usize = T0::N + T1::N + T2::N + T3::N
    const fn as_bytes(self) -> [u8; Self::N] {
        intrinsic::__as_bytes((
            self.0.as_bytes(),
            self.1.as_bytes(),
            self.2.as_bytes(),
            self.3.as_bytes(),
        ))
    }
}

pub const fn keccak<T: AsBytes>(x: T) -> u256 {
    let bytes: [u8; T::N] = x.as_bytes()
    intrinsic::__keccak256(bytes)
}
