{"text":"Sean, if I'm understanding, even though what you shared was kind of brief, I think it's helpful, like the idea to just keep dissolving the lower function calls. Well, make sure that there's no reliance on that constructor, or on any of those constructors, really. And then, yeah. What do you mean constructors? When I say constructors, I'm talking about like these salsa queries, the functions that create the wrappers. Yeah, that's like a good indicator that the refactor is not finished. Yeah, it's like the, I mean, one, you know, one thing to look for, I guess, is like, whether the raw, like the HIR things are still being used, you know, where we've got this, like, not the best way to look at it. Well, I think that, I think that was more the approach that I was instructing Claude to use, was to look at the, the usage of the wrappers and get rid of the wrappers themselves. But then, it seems like that didn't happen thoroughly. Yeah, it's like the, I guess, yeah, I guess just looking, looking for those functions. It's really, it's really the functions that take, like, I don't know, I guess it's just all the, it's all the lower, lower HIR ty, lower trait, lower, all the stuff that's in there. And, I guess, one thing that I was hoping to get your feedback on was even just at a glance, if the, the API changes on the HIR items themselves seem reasonable, like, in terms of, like, the methods and the fields and stuff. I think so, like, more or less reasonable, because there's definitely plenty of cases where there are still, there's still intermediate structures. I don't think, so what I came, what I, what I came to understand is that maybe these intermediate structures are not entirely undesirable. It's more so that we don't want to rely on them in the public API. So, it's like, if, if there's a case where it's useful to, like, differentiate, um, in a more granular way, like, the, the item, like, uh, internally in order to actually run some, some analysis stuff. And maybe, um, that's okay for now, but, like, um, just to keep that kind of stuff in the private API, and then the public API is not going to rely on that. So, yeah, I mean, I, yeah, I think that's fine. I think, um, I guess my intuition is that even those, like, my intuition is basically that, that could be an intermediate step. Like, I, I think a lot of those wrappers could ultimately be dissolved. I'm not positive. I think there's, like, uh, I guess, like, one, one example. Let's hop in Zed. Um, do you want to share yours? Have you changed anything since? No. Uh, did I? I don't think so. Let me see here. I'm going to open it up. Oh, here it is. I will also share a little bit about my methodology, because I think it's interesting. Um, where are we at? Share. Share yourself automatically, as I, as I've been mentioning for the past six months. Well, sometimes I, sometimes I open it up with Micah and other problems, and I'm thankful that it works right off the bat. Were you listening to my laptop, uh, fans? Yeah, I mean, it's fine. It's only a problem when, like, both, um, ImplTrait. Yeah, like, this, this, like, TraitImplData thing, that feels to me, like, kind of an internal-only wrapper. Uh-huh. Could just be, I think, unless I'm missing something, like, broken apart. Like, there's, there's no real reason to bundle it together into this one struct. Struct. Yeah. Right? Yeah. A method to get the params. A method to get the trait against. That's basically it. Yeah. Right? Yeah. Self-ty. Yeah. Yeah, this was, this is basically, I believe this is the implementer thing, just renamed, kind of. And I kind of went back and forth with Claude, and it was saying, I'd have to read the, the conversation again. Wait, hold on a second. This? Like, I'm just, you know, this stuff can, it could just be cut out, you know, like, in all these places where, you call, like, self.trait_impl.data.self_ty, you know, for. Oh, right. To get the self_ty. Every place where there's a comment that says, don't need to cache the query. Yeah, yeah, yeah, yeah. You just, you just cut out that block of code. Yeah. Right. That makes sense to me. You know, paste it in there. Yeah, yeah, yeah. Yeah. Like, intuitively, that makes sense to me. Maybe, maybe I just need to ditch Claude sometimes and just do it myself, because it's like, it gets in these cognitive dissonances of, like, wait, we need this. Don't destroy it. Um, but, let me see if there's a record here. Okay. All right, so here's, if you follow me, this document is, like, the, this is what I used as, like, to track the process and to keep things, um, persistent across the compactions. Um, but, yeah, this was its rationale. I don't know. This might just be, it's probably just bullshit. But, I don't know what this means. Atomic instantiation. Fancy. Um, but there was some point where there was, like, a, it said there was a trade-off between, um, adding lots of extra stuff to the, uh, what table? Some kind of a table versus keeping this. Um, and, I don't know. I don't know. Uh. Yeah. At that point, I was just kind of like, this is getting, I, I felt that I was getting out of, I was getting away from the, from the, uh, incremental refactor. So, I was like, okay. Yeah, I mean, that's, like, it, it might be right, but I think the, um, instantiate, it's actually doing that instantiate. Identity, which does nothing. Yeah. In, in, in this case. Um, instantiate identity just, like, unwraps the binder thing. So, it's not, like, if you, if you gave it a, um, a list of tys and actually called dot instantiate, that's, like, applying. Like, parameters and stuff. So, you give it a, all types, uh, tys, ty IDs, and then, um, yeah, it's like, it's like when you've got, uh, yeah, like a generic, a generic thing. Um, like, you get a concrete instance of that, you instantiate it and give it some tys. But, like, in, in this case, the collect constraints thing, I mean, maybe, maybe it's talking about something else. But, um, like, this instantiate identity thing is just, like, an unwrap, like a unbind or something. Yeah. Um, and so, I think this is all just fine to split it up. Um, you know, like, it might make sense to just collect constraints itself is also, is already tracked. So, I think it's perfectly fine to just do this. Uh, I'm just, like, just pasting, like, this assumptions thing. Just, just basically, like, cut out, cut out these strengths of code, um, paste them into methods. Oh, yeah, I see. And then make it all work. And then you can just shitcan this whole trademple data thing. And the type. Cool. That sounds great. Other, other, other cases might be more complicated. Maybe. You know, like, the HIR param precursor stuff or whatever. Oh, yeah, yeah, yeah. Yeah. That's, like, I mean, it might still all be unwindable, but it's kind of two layers, you know? Yeah. Well, it might be one of those things that's more risky to try and unwind using Claude. And I can totally, like, this doesn't, you know, we don't have to change it all at once. It's mostly, like, you can get to the point where we're, like, unwrapped kind of one layer of wrapping, or one level of wrapping, uh, for most things, you know? Yeah. But we don't have, I guess, like, ImplTrait and implementer. Right. Right, right, right. Just, just... Et cetera. I mean, it's just flattening out all the extra stuff from HIR analysis. Yeah, at least, like, one, like, one iterative step in that direction, you know? Yep. Yep. Like, one level of wrappers, kind of. Which I think, my sense is that this is more or less moving in that direction. Um, I mean, the fact that, that the lines of code, the changes are fairly close. There's, like, plus 300 lines, but, which is kind of weird, but I think, I don't think it's anything... Well, I, I think that, I think the reason that there's added lines of code is that... You just haven't deleted it? There's new methods. Like, there's new methods added to the, uh, to these structs. Yeah. But they're not being used. Really. Right. Um, you know, like this, like, ImplTrait raw ty, you know, this is still pub crate. Yeah. Um, and so, if we get rid of that, and then you can see that it's, like, it's used all over the place, um, and used because it's passed into some, you know, passed into lower hir ty. Yeah. Which is still being used. Yeah. So, like, basically, if you, um, like, in this, you know, in this item.rs, like, you know, for the most part, we shouldn't be exposing type ID, um, we should just have a method that's, like, dot ty, or self ty, or something. Mm-hmm. That's for the ty ID, not for type ID, so. Yeah, yeah. Yeah, yeah, yeah. Yeah, I mean, type ID is the, like... The raw? ...reference to a... Well, it's, it's, it's basically, like, a path, like, it's a name, it's a type name, right? Type name. That's what that means to be resolved. Mm-hmm. That's a thing that we were calling, like, type ref before, you know, where it's, like, it's either named foo, or it's, like, a tuple, A, B, C, um, you know, et cetera. Yeah, it's, like, some as-yet-unresolved type. Mm-hmm. And that's, that is, would that be considered, that's not HIR yet, or is it HIR, like... This is, it's like the, it's the HIR, it's just like, it's like ident. Yeah, yeah, yeah. Ident is some identifier, you know, to be determined what it actually means. I see, I see. And so, like, the thing where, just before, that it's probably a fool's errand to try to make a node-like wrapper around this thing. Right. Because then you have things like that, that type_id between two references at the salsa level, like, to make these things actually unique. You need to have some differentiator, and a differentiator has to be something like this const or enum, that tells you where the thing is. Right. Okay, this is the use of a type name in a struct field, and here's the struct, and here's the field index. This is a type name used in a function parameter. Right, right, right, right. And here's the, here's the function, and here's the parameter number. Which is just, which is just, which is just, it's just like spreading the same information redundantly that's already elsewhere into a whole nother layer of boilerplate that needs to get... It's like, I guess the way I view it is like, I of something, the type of something, for most of our uses, is basically an attribute. Right. It's not really its own thing. You know, so when I'm, like, I'm looking at a function, I'm looking at its parameters, for each parameter, I want to know the type of that parameter. And then, the case where traversing from a type, or, you know, resolved or otherwise, it's, like, definition, or parent, or something, is useful, that's, like, that's an LSP use case. You know, like, if you want to find all references of a struct called Foo, you need to, like, build up some index or something. Or, I guess, how Rust Analyzer does it, according to what Yoshi said in some meeting ages ago, is that it actually does a text search, basically, for all uses of the word foo, and then it resolves all of those cases and sees, you know, checks whether they point at the struct foo that you're, that you're concerned with. Yeah. Nice and simple. Things, like, type ID, name to type ID. Well, that's a case where, like, we should just keep using this, this HIR thing that isn't going to be a node-like thing at all. But, for the most part, for the most part, its uses should disappear from most of the code base. It should just be used inside the methods. Yeah. And then, like, because most of, mostly what you want is not the name of the type. Right, right, right. It's the actual resolved ty. Right. Tie ID. Right. And you can still get the name anyway. So, it's like, right? Yeah, yeah. There's no, but as far as, like, the naming stuff goes, I think that is an area where I still flounder a bit. Like, type ID, I changed the name to raw ty, but that's probably not the best name either of the field. Like... Yeah, what is this? Is it the self ty? Or, like, oh, it's... That was, that one was supposed to be, that one's supposed to be private. Like, I just haven't gone through and, like, checked all the work. But, like, in the, in the briefing document that I made, like, or in the conversations that I had with AI Claude, like, that was, like, okay, let's call the internal one, you know, let's call type ID raw ty or something. But I don't, I don't think that's necessarily the right name. Um, yeah, similar to what you were saying about, like, the, the lower naming of the, of the, um, of those various different, like, salsa queries that aren't actually lowering. Um, yeah, I think the type ID versus ty ID distinction is confusing for Claude, and it's, it's becoming less and less confusing for me. Um, but, yeah. I mean, is, what, would it be reasonable to name, to rename type ID to type ident? Or is that crazy? Is that confusing? Um, what about type key? Type key? Something. Something different. I don't know. I think, I think type ref. Type ref was reasonable? I mean, it, like, it would be fine. Um, I mean, I don't know, I don't really care what the name is, but, but the point is really that it, it shouldn't be used all over the place anyway. Um, I mean, it, it is poorly named, so yeah, go ahead and rename it. Um. I think it's just, it's a matter of, like, um, it's just really easy to get it conflated with, with type ID, um, so it's, yeah, it'd be nice to have it be a little bit more distinguishable on a superficial level. But, yeah. Okay. Type ref something. Um, sweet. Well, yeah, this is helpful. Yeah, I would, I'd recommend, like, one, one approach would be to, like, identify some of this kind of stuff, and then, and then just break it. Yeah. You know, like I did. And then ask the agent to fix it, basically. Yeah. Yeah. Sounds great. I am seeing a lot of lower this, lower that. I like, I mean, just, just making that raw ty private, you know, just immediately points to several uses where it's doing the stuff externally that we should be doing internally inside methods, you know? Yeah. So all of, follow me, this, like, analyze, ImplTrait specific error, you know, this, this stuff should just, this stuff should just go away. Like, these lines of code, wait, basically. This is all, this is all redundant. Mm-hmm. And I suspect that there's a lot of cases like that. Mm-hmm. Yeah, there probably are. And the way to really put the, put the fire to it is to ensure that they, that the, um, the information is exposed or withheld explicitly in the, in the, um, the struck definitions themselves. That's like a surefire way. Yeah, there's just, yeah, and just like, you know, I mean, I, I guess it's that, because that, that just immediately breaks things. Um, but just to find other cases where you could hide stuff and make things private, um, just to just like check for uses of lower HIR ty, for example, like here's one that I maybe wouldn't have anticipated. Um, like this is getting the default type of an associated type. Mm-hmm. You know, so this like associated type, associated ty deckle, this is the, this is one of those things that is hard to wrap, or hard to make note. Hard to, I'm not sure. Well, maybe, like, I really do think that, uh, it was just, I think these, this LLMs, these LLMs are conservative, they're very conservative, so, um, and they, they don't really actually know what's going on, so, so it's like, yeah, you gotta get real specific, or do it yourself. But, um, what is the, let's see, are there, besides, um, type ID, I guess, well, because we have, we have these like attribute-like things that, um, I know you were discussing that we don't necessarily want to go all the way granular with, uh, the traversal API. Um, I'm just wondering if there are any other, like, red flags in terms of stuff that's public, that shouldn't be public. Um, maybe that's too broad of a question to ask, but. Yeah, I think, like, you know, so here, here's one example, like, super traits. So these are trait refs, you know, so trait ref is just, like, the name of a trait. Yeah. Um, so these are the super traits. Which is very attribute-like. Yeah, it is, but then it's like, this is used, presumably, in the collective constraints thing, or extend all bounds, or something. Super traits. But this, see, but, okay, so, this, maybe, maybe it wouldn't hurt to just be somewhat, like, err on the side of keeping as much stuff as possible internal, and then, like, this collects super traits query. Well, yeah, the tricky part about this case is that the super traits could be a cycle. I see. Um, and so, like, so we've got this external function that, um, I mean, I guess, like, it, collect super traits could just be called internally instead of externally, basically, would be fine. Um, like, you know, right now. Well, it's public crate already, so. Crate basically doesn't mean anything, because it's, this is the mega crate. Right, right, right. So, it's just gotta be private. Right, right, right. But, I mean, I'm even just talking in terms of, like, um, oh, I see what you mean. Yeah, there's two, there's several levels of, of internal, of the meaning of internal. Like, there's the distinction between the, sort of, HIR def and the analysis modules, right? And wanting to keep some things. Maybe just totally, um, like, maybe some of these things we wanna keep, if we have to keep them at all, we should keep them inside of the analysis module. But then there's other things where pub crate is the appropriate, um. Well, pub, I mean, the, the thing about pub crate is that there, there's, like, I guess the only consumer of the, uh, of this crate is LSP. Right. Um. So, you know, it is useful to consider what LSP should be using from here versus not using. Um, but I think, like, with this exercise, the primary concern is, like, um, for this exercise, uh, pub crate is useless because this is the only crate, basically. Like, this is the only crate of the compiler. Yeah, yeah, yeah. And so pub crate doesn't do anything. It's not gonna, it's not going to, um, expose, uh, the, the boundary of, of this new API that we're trying to build. So I think the, um, you know, just flip from pub to not pub at all. And then at some point, like, at, at some point we'll want to move some of the things that stay pub, um, to pub crate, you know, to say, like, okay, LSP shouldn't be accessing this. Um, yeah. And the, the, I guess the driver shouldn't be accessing this, um, you know, whatever. But that's kind of a separate, you know, API definition thing. Like, I guess the, with this exercise, to me at least, it feels like it's an exercise in, in the, kind of, the internal API, um, within this own, within this single crate. So it's, like, module level visibility sensor. Yeah. Okay, cool. And in the case of this, uh, what were we looking at just now? Like, this super traits thing. Super traits. The only reason this needs to be pub right now is that the collect super traits, uh, function is defined outside of here. Yeah. It's like. Ah, right. You know, super trait instts calls collect super traits. Oh, like, maybe an alternative would be RS. We don't have to, we don't have to have every single item in one, in one file. This collects super traits. Code alongside this trait definition. Um, you know, like if you split apart the item.rs file into multiple files and put it in an item module. Items module. Item module. I mean, this, this particular case isn't a very interesting code organization question. Yeah. We just collect super traits as long as being. Yeah. Okay. Um, I think. Yeah, I mean, I guess, like, I would, I would say just, you know, go through the def analysis file and see where, where hir ty, et cetera, functions are being used in there and see how many lines of code you can delete there by just calling, calling these new methods, basically, or moving stuff into methods. Yeah. Uh, you said the def analyzer? Def analysis.rs. There it is. Yeah, yeah, yeah, yeah, yeah. Because one of the goals is to, to break down these. Yeah, we have these, I'm just, I have to keep reminding myself, we are taking these, these big, um, salsa queries that are defined separately from the various structs and we're, we're factoring out stuff that can be attached to, that would be usefully attached to the, the, the, the struct impl blocks so that they are kind of bound to the context, um, that's needed to execute those little chunks of these queries and then the result is going to be that these different, like, high level usages of those, those, those large, um, decontextualized queries are going to get, are going to be able to be, um, refactored to use, directly use the smaller, um, um, uh, contextualized queries attached to the structs and so the, yeah, the end result being that we shouldn't see those lower hir ty, you know, sprinkled here and there or you're manually passing in assumptions, right? Like, like, that's, that's, that's like a sign that things are working as intended with this new API. Yeah, cause these, like, of these, the, what's the ty of the, or what, what, what trait is this trait input talking about? Attributes? Yup. They should just be methods that provide information. Yup. Um. Um. And the, the calculation of those attributes is several lines of code and so it's, and then it's, it's work that needs to be duplicated in LSP analysis and, uh, uh, path resolution and... Right. ...duplicated all over the place. Right. Um. We don't want to have that be, like, kind of, haphazardly, like, duplicated all around and then every time you want to change the logic, you have to go around to each place and re, rework it, um, manually. It should just be consolidated. Um. I think. Yeah. Um. I've been, still, the, the stuff about the scope ID, um, still eludes me a little bit, like, a lot actually. Um. But, let's see, so scope ID is, let's see, what is this scope ID thing? It's kind of what you were describing before in a way of, um, it, um, contextualizes the, the items, basically, into their function. The scope ID is basically a node in the scope graph. And the scope graph is like the naming context. Okay. So it's like... That's the, that's, the paths are, paths are, like, paths in the scope graph. So, if you have a path, it's going to be a string of scope names. Is that right? Or scope IDs, even. Or scope IDs, even. Yeah. Or it's going to be idents that corresponds to... That's almost, almost entirely right. Uh, I think, like, at the, at the tail end, they're not necessarily, yeah. Like, the scope graph is used for name resolution. Yeah. Yeah. So the, the, the paths are going to be comprised of little segments that correspond to scope IDs. More or less. Like, at, at the, at the tail end, we don't necessarily use the scope graph. Gotcha. It becomes, like, maybe more granular. It's like explicit research. Methodic resolution. Oh, sure. That's inside, that's, like, inside of a scope. And it's, like, it's, it's kind of a weird situation. Where, like, you know, clone isn't really defined inside the full scope. Yeah. Search all traits and all trait impulse. Right, right, right. It's, it's... Across the entire project. That's where the other abstractions, um, come into play that don't fit into a neat little hierarchical arrangement. If that makes sense. Okay, but, for the purposes of this refactor, um, scope ID, um, I see. So, yeah. So, yeah. So, different variants of scope ID will need to get treated differently with respect to the kinds of methods that are defined on scope ID? Is that sorta? I don't, I don't, I don't think anything about scope ID really needs to change. Okay. Um, I mean, maybe, if some of the scope ID variants are using things that we're aiming to eliminate. Well, I guess it, this all seems fine. Okay. Yeah. I guess, like, some of, like, these are, some of these are a little bit weird, but they're, they're fine for now. Like, this, the field scope makes sense to, it has, you get like, field def list ID. Oh yeah, we've talked about that one before. Yeah. It has this ty fields. What I'm trying to suggest is that we add something like a field def. It has methods on it. You know, like this, any time is used. We need to get the index in. Yeah. Yeah, I was wondering if that was different from what you were imagining. I guess this, this seems pretty, what I'm suggesting is that if anything, we're doing a lot of work. Uh huh. That seems like a, an opportunity for a method. Somewhere. Yeah. On something. Yeah. Yeah. So this kind of pattern and index into that parent. Like if you actually got this, then you'd be manually indexing into the parent object. Right, right, right, right. Um. It's like, it's like leaky. It's kind of hard to explicitly define, you know, where, sometimes the leakiness is like, unfortunately necessary, either in the, like in the meantime, for now, or maybe even for some weird complex reason. But I guess the, the idea is to try and really consolidate as much as possible that kind of leakiness, like you're saying, like, we don't want to have, have to duplicate the logic all over the place. If, if we can help it. I guess the reason this isn't used much is because you can't actually resolve, um, called foo and it has a field called x. If you want to x, that's not allowed. I see. That's not allowed. I see. So whatever, this case is, this case is harmless. I see. Cause you have to do foo dot x anytime you want to. Yeah, like if you, like there's no case in Rust, for example, where foo colon colon x is allowed. Unless x is a method. Yeah. Yeah. But if x has a field name, then it's, then that's just meaningless. And, so yeah, so field names are strictly different from methods in the scope graph? I mean, methods aren't really in the scope graph because that's like a resolution problem because of traits. Oh, right, right, right. Cause, uh, uh, the. I guess func, func param is a better. Funk param. I mean, this, this, I said before, like I don't, nothing about scope ID needs to change right now, I think. But some of these, you know, like generic param. Are these all carrying index, indexes, indices? Yeah. All cases where, at some point in the future, we might want to change these to be. Yeah. Cause this is just, this is basically just a node like, you know, where it's like a, it has a pointer to the parent. It has an index to differentiate itself from all the other ones. Yeah. Yeah. That's doesn't, you know, it doesn't matter. Like scope. I mean, that could be a nice to have. The scope graph is really only for path resolution. Uh huh. So it doesn't really matter. Well, I just remembered that you had mentioned scope ID last time and I don't remember why. So that's why I wanted to bring it up. Um, I think I mentioned it in the context of like, these are things that aren't items that are also worth thinking about. Oh, like the stuff we're talking about right now. Like generic param. Yeah. So it's not, not to suggest that scope ID itself needs to change. Gotcha. Like generic params. That's a, that's a thing that isn't in item.rs. Yeah. That we should maybe rework. Um. I see. I mean, this is the, this is the complicated case. Uh huh. Okay. So it's not, it's not. It's not. This is like, you don't have to change anything about scope ID. Right. But scope ID is, scope ID is a pointer to like other things that might be nice for this traversal abstraction to traverse to and from. So maybe, maybe would you say it's correct to think of it as like, that the, the items are like the most chunky thing to, to start with in this, building this API. And then the, the scope ID variants, the, the, the, the structs that the scope ID variants wrap are the next sort of level of granularity. It's a little more fine. Yeah, probably. And it's basically just the, the items are the root. If you go one level deeper, um, it's the things, the things that an item has as kind of direct children. Oh yeah. Yeah, yeah, yeah. Like a, like a function has parameters. Right. Okay. It's direct children that aren't just a single, the return type of function. Right. It's kind of just an, it's just a, it's a piece of information about the function. Right. But a parameter has its own information. Okay. It has a name. It has a label. It has a type. And these are, these are things that are, they are pathable. They're like things that are, well there, it seems like there are other things that are able to be tied to a path that are not even in the scope graph. But, the items are like the big chunks of the scope graph, but then the items themselves have some, some children in the scope graph, in the scope ID. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. And so it's just like, it's just the children of items. The children of items. Regardless of, just forget about the scope graph, forget about paths. Um, it's children of items that have their own attributes. Okay. And those things are still useful to traverse, even if they don't have a clean mapping to the scope graph or the path. We still want to be able to traverse them because, um, we want to be able to, to use the information that we have to, um, to collect, uh, the, the resolutions of various compiler logic. Yeah. I mean, I, I also wouldn't, like, necessarily worry about the traversal. It's like, um, that was kind of the, sort of the driving motivation. But, uh, but like, it's these, these children, like a parameter of a function. Yeah. Um, like right now, um, the attributes of these things externally, you know, so it's just like a code cleanliness problem, like a code encapsulation problem. Yeah. Yeah. Yeah. You know, we've, we've got these things like a function parameter and to figure out what the type of the function parameter is. Well, you need to first call collect func def constraints. And then you have to like index into the parameter list. There's just a lot of. Call lower hir ty. Right. Right. All that shit. You shouldn't need to know how to do that. It should just be like, you know, hey function, what's your parameter zero and what's its resolved ty. Right, right, right. Yeah. I see what you're saying. Regardless of the, the concept of the traversal, whatever. Yeah. What is or isn't a node in this traversal. It's like, we want to encapsulate information, uh, so that it makes it easier to use the code. Okay. Okay. Thank you. That sort of demystified it for me. Okay. So I'll try to get the item level stuff tightened up and validated in terms of there should be less code and there should be no calls to all these lower, lower this, lower that functions sprinkled around. Yeah. And then I think it seems like the next level is to kind of just apply the same, um, idea to these non-item things. Yeah. Yeah. Carefully. Yeah. And I think it'd be useful to like, after you, after you do the item level, just, I guess, focus on the item level and presentable. And ideally that'll be a, a nice diff where we're deleting some lines of code. Yeah. Maybe it won't be a ton, but for manual ask cleanup. Right. Um, like the agents, they like to fully specify all paths for all includes and they include everything in every function body and they, you know, all that kind of shit. That's, that's just ugly. Like. Yeah, they do. Um, you know. They do like to do that, which kind of, it's noisy. Um, yeah. So, of course, cleaning up the, the LLM generated style code. Um. Yeah. So it's just like, you know, get, get the first level into a presentable state. Um, and then ideally that seems compelling. And then. Yeah. And then proceed on. That sounds good. Okay, cool. I'll, I'll, I'll take that as a, as like a, a mid, a midpoint then to, to get to before I start on the, on the scope ID variants or the, the, the item children. Yeah. Well, thank you. Thanks again, Sean. No problem. This is a crash course. This is definitely a crash course. Yeah. I mean, I like, I guess part of the value of maybe doing some of it manually is that start to understand how the shit works, you know? Yeah, totally. Cause it's not, I mean, I guess part of my hope with this refactor is that it, um, putting all this stuff in methods, like be more clear how to do stuff. Yeah. Yeah. How do I get the, the type of a, of a thing? Yeah. Oh, I just call this function. Um. Yeah. Or I just call this method. Like, okay, first you have to, you know, collect the constraints and then you gotta, you know, and you have to call this path resolution function and you have to know like the current scope and you gotta. And you have to ignore the naming of this, this, and this. Yeah. Don't get caught up on it. Yeah. I mean what you think it means. Yeah. Right. So, someone like me. Yeah. Someone like, uh, like you. Someone like Grant. We can. Yep. We can actually make features more easily. Make changes. Yep. Totally. It's not just for the, for the AI. It's for the people. You know, that's inspiring. Um. Okay. I, I think I have enough to, to keep it moving. Um. Can we talk about, uh, trait syntax for a bit? Absolutely. And sort of just get a go ahead on implementing this. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah. Yeah."}