---
source: crates/analyzer/tests/analysis.rs
expression: "build_snapshot(&db, module)"

---
note: 
  ┌─ uniswap.fe:2:5
  │  
2 │ ╭     pub fn balanceOf(self, _ account: address) -> u256 {
3 │ │         return 0
4 │ │     }
  │ ╰─────^ self: Some(Mutable), params: [{ label: Some("_"), name: account, typ: address }] -> u256

note: 
  ┌─ uniswap.fe:3:16
  │
3 │         return 0
  │                ^ u256

note: 
  ┌─ uniswap.fe:6:5
  │  
6 │ ╭     pub fn transfer(self, to: address, _ amount: u256) -> bool {
7 │ │         return false
8 │ │     }
  │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: to, typ: address }, { label: Some("_"), name: amount, typ: u256 }] -> bool

note: 
  ┌─ uniswap.fe:7:16
  │
7 │         return false
  │                ^^^^^ bool

note: 
   ┌─ uniswap.fe:15:5
   │
15 │     balances: Map<address, u256>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, u256>
16 │     allowances: Map<address, Map<address, u256>>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, Map<address, u256>>
17 │     total_supply: u256
   │     ^^^^^^^^^^^^^^^^^^ u256
18 │ 
19 │     nonces: Map<address, u256>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, u256>
20 │ 
21 │     factory: address
   │     ^^^^^^^^^^^^^^^^ address
22 │     token0: ERC20
   │     ^^^^^^^^^^^^^ ERC20
23 │     token1: ERC20
   │     ^^^^^^^^^^^^^ ERC20
24 │ 
25 │     reserve0: u256
   │     ^^^^^^^^^^^^^^ u256
26 │     reserve1: u256
   │     ^^^^^^^^^^^^^^ u256
27 │     block_timestamp_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
28 │ 
29 │     price0_cumulative_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
30 │     price1_cumulative_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
31 │     k_last: u256
   │     ^^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:34:9
   │
34 │         idx owner: address
   │         ^^^^^^^^^^^^^^^^^^ address
35 │         idx spender: address
   │         ^^^^^^^^^^^^^^^^^^^^ address
36 │         value: u256
   │         ^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:40:9
   │
40 │         idx from: address
   │         ^^^^^^^^^^^^^^^^^ address
41 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address
42 │         value: u256
   │         ^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:46:9
   │
46 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
47 │         amount0: u256
   │         ^^^^^^^^^^^^^ u256
48 │         amount1: u256
   │         ^^^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:52:9
   │
52 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
53 │         amount0: u256
   │         ^^^^^^^^^^^^^ u256
54 │         amount1: u256
   │         ^^^^^^^^^^^^^ u256
55 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address

note: 
   ┌─ uniswap.fe:59:9
   │
59 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
60 │         amount0_in: u256
   │         ^^^^^^^^^^^^^^^^ u256
61 │         amount1_in: u256
   │         ^^^^^^^^^^^^^^^^ u256
62 │         amount0_out: u256
   │         ^^^^^^^^^^^^^^^^^ u256
63 │         amount1_out: u256
   │         ^^^^^^^^^^^^^^^^^ u256
64 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address

note: 
   ┌─ uniswap.fe:68:9
   │
68 │         reserve0: u256
   │         ^^^^^^^^^^^^^^ u256
69 │         reserve1: u256
   │         ^^^^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:76:5
   │  
76 │ ╭     pub fn factory(self) -> address {
77 │ │         return self.factory
78 │ │     }
   │ ╰─────^ self: Some(Mutable), params: [] -> address

note: 
   ┌─ uniswap.fe:77:16
   │
77 │         return self.factory
   │                ^^^^ UniswapV2Pair

note: 
   ┌─ uniswap.fe:77:16
   │
77 │         return self.factory
   │                ^^^^^^^^^^^^ SPtr<address> -> address

note: 
   ┌─ uniswap.fe:80:5
   │  
80 │ ╭     pub fn token0(self) -> address {
81 │ │         return address(self.token0)
82 │ │     }
   │ ╰─────^ self: Some(Mutable), params: [] -> address

note: 
   ┌─ uniswap.fe:81:24
   │
81 │         return address(self.token0)
   │                        ^^^^ UniswapV2Pair

note: 
   ┌─ uniswap.fe:81:24
   │
81 │         return address(self.token0)
   │                        ^^^^^^^^^^^ SPtr<ERC20> -> ERC20

note: 
   ┌─ uniswap.fe:81:16
   │
81 │         return address(self.token0)
   │                ^^^^^^^^^^^^^^^^^^^^ address

note: 
   ┌─ uniswap.fe:84:5
   │  
84 │ ╭     pub fn token1(self) -> address {
85 │ │         return address(self.token1)
86 │ │     }
   │ ╰─────^ self: Some(Mutable), params: [] -> address

note: 
   ┌─ uniswap.fe:85:24
   │
85 │         return address(self.token1)
   │                        ^^^^ UniswapV2Pair

note: 
   ┌─ uniswap.fe:85:24
   │
85 │         return address(self.token1)
   │                        ^^^^^^^^^^^ SPtr<ERC20> -> ERC20

note: 
   ┌─ uniswap.fe:85:16
   │
85 │         return address(self.token1)
   │                ^^^^^^^^^^^^^^^^^^^^ address

note: 
   ┌─ uniswap.fe:88:5
   │  
88 │ ╭     fn _mint(self, ctx: Context, to: address, value: u256) {
89 │ │         self.total_supply = self.total_supply + value
90 │ │         self.balances[to] = self.balances[to] + value
91 │ │         emit Transfer(ctx, from: address(0), to, value)
92 │ │     }
   │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: to, typ: address }, { label: None, name: value, typ: u256 }] -> ()

note: 
   ┌─ uniswap.fe:89:9
   │
89 │         self.total_supply = self.total_supply + value
   │         ^^^^ UniswapV2Pair

note: 
   ┌─ uniswap.fe:89:9
   │
89 │         self.total_supply = self.total_supply + value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
   │         │                    
   │         SPtr<u256>

note: 
   ┌─ uniswap.fe:89:29
   │
89 │         self.total_supply = self.total_supply + value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256
   │                             │                    
   │                             SPtr<u256> -> u256

note: 
   ┌─ uniswap.fe:89:29
   │
89 │         self.total_supply = self.total_supply + value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256
90 │         self.balances[to] = self.balances[to] + value
   │         ^^^^ UniswapV2Pair

note: 
   ┌─ uniswap.fe:90:9
   │
90 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^ ^^ address
   │         │              
   │         SPtr<Map<address, u256>>

note: 
   ┌─ uniswap.fe:90:9
   │
90 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
   │         │                    
   │         SPtr<u256>

note: 
   ┌─ uniswap.fe:90:29
   │
90 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^ ^^ address
   │                             │              
   │                             SPtr<Map<address, u256>>

note: 
   ┌─ uniswap.fe:90:29
   │
90 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256
   │                             │                    
   │                             SPtr<u256> -> u256

note: 
   ┌─ uniswap.fe:90:29
   │
90 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256
91 │         emit Transfer(ctx, from: address(0), to, value)
   │                       ^^^                ^ u256
   │                       │                   
   │                       Context

note: 
   ┌─ uniswap.fe:91:34
   │
91 │         emit Transfer(ctx, from: address(0), to, value)
   │                                  ^^^^^^^^^^  ^^  ^^^^^ u256
   │                                  │           │    
   │                                  │           address
   │                                  address

note: 
   ┌─ uniswap.fe:94:5
   │  
94 │ ╭     fn _burn(self, ctx: Context, from: address, value: u256) {
95 │ │         self.balances[from] = self.balances[from] - value
96 │ │         self.total_supply = self.total_supply - value
97 │ │         emit Transfer(ctx, from, to: address(0), value)
98 │ │     }
   │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: from, typ: address }, { label: None, name: value, typ: u256 }] -> ()

note: 
   ┌─ uniswap.fe:95:9
   │
95 │         self.balances[from] = self.balances[from] - value
   │         ^^^^ UniswapV2Pair

note: 
   ┌─ uniswap.fe:95:9
   │
95 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^ ^^^^ address
   │         │              
   │         SPtr<Map<address, u256>>

note: 
   ┌─ uniswap.fe:95:9
   │
95 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
   │         │                      
   │         SPtr<u256>

note: 
   ┌─ uniswap.fe:95:31
   │
95 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^ ^^^^ address
   │                               │              
   │                               SPtr<Map<address, u256>>

note: 
   ┌─ uniswap.fe:95:31
   │
95 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^   ^^^^^ u256
   │                               │                      
   │                               SPtr<u256> -> u256

note: 
   ┌─ uniswap.fe:95:31
   │
95 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
96 │         self.total_supply = self.total_supply - value
   │         ^^^^ UniswapV2Pair

note: 
   ┌─ uniswap.fe:96:9
   │
96 │         self.total_supply = self.total_supply - value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
   │         │                    
   │         SPtr<u256>

note: 
   ┌─ uniswap.fe:96:29
   │
96 │         self.total_supply = self.total_supply - value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256
   │                             │                    
   │                             SPtr<u256> -> u256

note: 
   ┌─ uniswap.fe:96:29
   │
96 │         self.total_supply = self.total_supply - value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256
97 │         emit Transfer(ctx, from, to: address(0), value)
   │                       ^^^  ^^^^              ^ u256
   │                       │    │                  
   │                       │    address
   │                       Context

note: 
   ┌─ uniswap.fe:97:38
   │
97 │         emit Transfer(ctx, from, to: address(0), value)
   │                                      ^^^^^^^^^^  ^^^^^ u256
   │                                      │            
   │                                      address

note: 
    ┌─ uniswap.fe:100:5
    │  
100 │ ╭     fn _approve(self, ctx: Context, owner: address, spender: address, value: u256) {
101 │ │         self.allowances[owner][spender] = value
102 │ │         emit Approval(ctx, owner, spender, value)
103 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: owner, typ: address }, { label: None, name: spender, typ: address }, { label: None, name: value, typ: u256 }] -> ()

note: 
    ┌─ uniswap.fe:101:9
    │
101 │         self.allowances[owner][spender] = value
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:101:9
    │
101 │         self.allowances[owner][spender] = value
    │         ^^^^^^^^^^^^^^^ ^^^^^ address
    │         │                
    │         SPtr<Map<address, Map<address, u256>>>

note: 
    ┌─ uniswap.fe:101:9
    │
101 │         self.allowances[owner][spender] = value
    │         ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^ address
    │         │                       
    │         SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:101:9
    │
101 │         self.allowances[owner][spender] = value
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^ u256
    │         │                                  
    │         SPtr<u256>
102 │         emit Approval(ctx, owner, spender, value)
    │                       ^^^  ^^^^^  ^^^^^^^  ^^^^^ u256
    │                       │    │      │         
    │                       │    │      address
    │                       │    address
    │                       Context

note: 
    ┌─ uniswap.fe:105:5
    │  
105 │ ╭     fn _transfer(self, ctx: Context, from: address, to: address, value: u256) {
106 │ │         self.balances[from] = self.balances[from] - value
107 │ │         self.balances[to] = self.balances[to] + value
108 │ │         emit Transfer(ctx, from, to, value)
109 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: from, typ: address }, { label: None, name: to, typ: address }, { label: None, name: value, typ: u256 }] -> ()

note: 
    ┌─ uniswap.fe:106:9
    │
106 │         self.balances[from] = self.balances[from] - value
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:106:9
    │
106 │         self.balances[from] = self.balances[from] - value
    │         ^^^^^^^^^^^^^ ^^^^ address
    │         │              
    │         SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:106:9
    │
106 │         self.balances[from] = self.balances[from] - value
    │         ^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
    │         │                      
    │         SPtr<u256>

note: 
    ┌─ uniswap.fe:106:31
    │
106 │         self.balances[from] = self.balances[from] - value
    │                               ^^^^^^^^^^^^^ ^^^^ address
    │                               │              
    │                               SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:106:31
    │
106 │         self.balances[from] = self.balances[from] - value
    │                               ^^^^^^^^^^^^^^^^^^^   ^^^^^ u256
    │                               │                      
    │                               SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:106:31
    │
106 │         self.balances[from] = self.balances[from] - value
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
107 │         self.balances[to] = self.balances[to] + value
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:107:9
    │
107 │         self.balances[to] = self.balances[to] + value
    │         ^^^^^^^^^^^^^ ^^ address
    │         │              
    │         SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:107:9
    │
107 │         self.balances[to] = self.balances[to] + value
    │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
    │         │                    
    │         SPtr<u256>

note: 
    ┌─ uniswap.fe:107:29
    │
107 │         self.balances[to] = self.balances[to] + value
    │                             ^^^^^^^^^^^^^ ^^ address
    │                             │              
    │                             SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:107:29
    │
107 │         self.balances[to] = self.balances[to] + value
    │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256
    │                             │                    
    │                             SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:107:29
    │
107 │         self.balances[to] = self.balances[to] + value
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256
108 │         emit Transfer(ctx, from, to, value)
    │                       ^^^  ^^^^  ^^  ^^^^^ u256
    │                       │    │     │    
    │                       │    │     address
    │                       │    address
    │                       Context

note: 
    ┌─ uniswap.fe:111:5
    │  
111 │ ╭     pub fn approve(self, ctx: Context, spender: address, value: u256) -> bool {
112 │ │         self._approve(ctx, owner: ctx.msg_sender(), spender, value)
113 │ │         return true
114 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: spender, typ: address }, { label: None, name: value, typ: u256 }] -> bool

note: 
    ┌─ uniswap.fe:112:9
    │
112 │         self._approve(ctx, owner: ctx.msg_sender(), spender, value)
    │         ^^^^          ^^^         ^^^ Context
    │         │             │            
    │         │             Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:112:35
    │
112 │         self._approve(ctx, owner: ctx.msg_sender(), spender, value)
    │                                   ^^^^^^^^^^^^^^^^  ^^^^^^^  ^^^^^ u256
    │                                   │                 │         
    │                                   │                 address
    │                                   address

note: 
    ┌─ uniswap.fe:112:9
    │
112 │         self._approve(ctx, owner: ctx.msg_sender(), spender, value)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
113 │         return true
    │                ^^^^ bool

note: 
    ┌─ uniswap.fe:116:5
    │  
116 │ ╭     pub fn transfer(self, ctx: Context, to: address, value: u256) -> bool {
117 │ │         self._transfer(ctx, from: ctx.msg_sender(), to, value)
118 │ │         return true
119 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: to, typ: address }, { label: None, name: value, typ: u256 }] -> bool

note: 
    ┌─ uniswap.fe:117:9
    │
117 │         self._transfer(ctx, from: ctx.msg_sender(), to, value)
    │         ^^^^           ^^^        ^^^ Context
    │         │              │           
    │         │              Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:117:35
    │
117 │         self._transfer(ctx, from: ctx.msg_sender(), to, value)
    │                                   ^^^^^^^^^^^^^^^^  ^^  ^^^^^ u256
    │                                   │                 │    
    │                                   │                 address
    │                                   address

note: 
    ┌─ uniswap.fe:117:9
    │
117 │         self._transfer(ctx, from: ctx.msg_sender(), to, value)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
118 │         return true
    │                ^^^^ bool

note: 
    ┌─ uniswap.fe:121:5
    │  
121 │ ╭     pub fn transferFrom(self, ctx: Context, from: address, to: address, value: u256) -> bool {
122 │ │         assert self.allowances[from][ctx.msg_sender()] >= value
123 │ │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
124 │ │         self._transfer(ctx, from, to, value)
125 │ │         return true
126 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: from, typ: address }, { label: None, name: to, typ: address }, { label: None, name: value, typ: u256 }] -> bool

note: 
    ┌─ uniswap.fe:122:16
    │
122 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:122:16
    │
122 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^^^^^^^^^^^^ ^^^^ address
    │                │                
    │                SPtr<Map<address, Map<address, u256>>>

note: 
    ┌─ uniswap.fe:122:16
    │
122 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^ ^^^ Context
    │                │                      
    │                SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:122:38
    │
122 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                                      ^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:122:16
    │
122 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^ u256
    │                │                                           
    │                SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:122:16
    │
122 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:123:9
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │         ^^^^^^^^^^^^^^^ ^^^^ address
    │         │                
    │         SPtr<Map<address, Map<address, u256>>>

note: 
    ┌─ uniswap.fe:123:9
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │         ^^^^^^^^^^^^^^^^^^^^^ ^^^ Context
    │         │                      
    │         SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:123:31
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                               ^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:123:9
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
    │         │                                          
    │         SPtr<u256>

note: 
    ┌─ uniswap.fe:123:51
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                   ^^^^^^^^^^^^^^^ ^^^^ address
    │                                                   │                
    │                                                   SPtr<Map<address, Map<address, u256>>>

note: 
    ┌─ uniswap.fe:123:51
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                   ^^^^^^^^^^^^^^^^^^^^^ ^^^ Context
    │                                                   │                      
    │                                                   SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:123:73
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                                         ^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:123:51
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^ u256
    │                                                   │                                          
    │                                                   SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:123:51
    │
123 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
124 │         self._transfer(ctx, from, to, value)
    │         ^^^^           ^^^  ^^^^  ^^  ^^^^^ u256
    │         │              │    │     │    
    │         │              │    │     address
    │         │              │    address
    │         │              Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:124:9
    │
124 │         self._transfer(ctx, from, to, value)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
125 │         return true
    │                ^^^^ bool

note: 
    ┌─ uniswap.fe:128:5
    │  
128 │ ╭     pub fn balanceOf(self, _ account: address) -> u256 {
129 │ │         return self.balances[account]
130 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: Some("_"), name: account, typ: address }] -> u256

note: 
    ┌─ uniswap.fe:129:16
    │
129 │         return self.balances[account]
    │                ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:129:16
    │
129 │         return self.balances[account]
    │                ^^^^^^^^^^^^^ ^^^^^^^ address
    │                │              
    │                SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:129:16
    │
129 │         return self.balances[account]
    │                ^^^^^^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:132:5
    │  
132 │ ╭     pub fn get_reserves(self) -> (u256, u256, u256) {
133 │ │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
134 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [] -> (u256, u256, u256)

note: 
    ┌─ uniswap.fe:133:17
    │
133 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                 ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:133:17
    │
133 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                 ^^^^^^^^^^^^^  ^^^^ UniswapV2Pair
    │                 │               
    │                 SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:133:32
    │
133 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                                ^^^^^^^^^^^^^  ^^^^ UniswapV2Pair
    │                                │               
    │                                SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:133:47
    │
133 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                                               ^^^^^^^^^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:133:16
    │
133 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (u256, u256, u256)

note: 
    ┌─ uniswap.fe:137:5
    │  
137 │ ╭     pub fn initialize(self, ctx: Context, token0: ERC20, token1: ERC20) {
138 │ │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
139 │ │         self.token0 = token0
140 │ │         self.token1 = token1
141 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: token0, typ: ERC20 }, { label: None, name: token1, typ: ERC20 }] -> ()

note: 
    ┌─ uniswap.fe:138:16
    │
138 │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
    │                ^^^ Context

note: 
    ┌─ uniswap.fe:138:16
    │
138 │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^    ^^^^ UniswapV2Pair
    │                │                    
    │                address

note: 
    ┌─ uniswap.fe:138:36
    │
138 │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
    │                                    ^^^^^^^^^^^^ SPtr<address> -> address

note: 
    ┌─ uniswap.fe:138:16
    │
138 │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>
    │                │                                  
    │                bool
139 │         self.token0 = token0
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:139:9
    │
139 │         self.token0 = token0
    │         ^^^^^^^^^^^   ^^^^^^ ERC20
    │         │              
    │         SPtr<ERC20>
140 │         self.token1 = token1
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:140:9
    │
140 │         self.token1 = token1
    │         ^^^^^^^^^^^   ^^^^^^ ERC20
    │         │              
    │         SPtr<ERC20>

note: 
    ┌─ uniswap.fe:144:5
    │  
144 │ ╭     fn _update(self, ctx: Context, balance0: u256, balance1: u256, reserve0: u256, reserve1: u256) {
145 │ │         // changed from u32s
146 │ │         // TODO: reproduce desired overflow (https://github.com/ethereum/fe/issues/286)
147 │ │         let block_timestamp: u256 = ctx.block_timestamp() % 2 ** 32
    · │
156 │ │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
157 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: balance0, typ: u256 }, { label: None, name: balance1, typ: u256 }, { label: None, name: reserve0, typ: u256 }, { label: None, name: reserve1, typ: u256 }] -> ()

note: 
    ┌─ uniswap.fe:147:13
    │
147 │         let block_timestamp: u256 = ctx.block_timestamp() % 2 ** 32
    │             ^^^^^^^^^^^^^^^ u256
148 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last
    │             ^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:147:37
    │
147 │         let block_timestamp: u256 = ctx.block_timestamp() % 2 ** 32
    │                                     ^^^ Context

note: 
    ┌─ uniswap.fe:147:37
    │
147 │         let block_timestamp: u256 = ctx.block_timestamp() % 2 ** 32
    │                                     ^^^^^^^^^^^^^^^^^^^^^   ^    ^^ u256
    │                                     │                       │     
    │                                     │                       u256
    │                                     u256

note: 
    ┌─ uniswap.fe:147:61
    │
147 │         let block_timestamp: u256 = ctx.block_timestamp() % 2 ** 32
    │                                                             ^^^^^^^ u256

note: 
    ┌─ uniswap.fe:147:37
    │
147 │         let block_timestamp: u256 = ctx.block_timestamp() % 2 ** 32
    │                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
148 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last
    │                                  ^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
    │                                  │                  
    │                                  u256

note: 
    ┌─ uniswap.fe:148:52
    │
148 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last
    │                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:148:34
    │
148 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last
    │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
149 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0 {
    │            ^^^^^^^^^^^^   ^ u256
    │            │               
    │            u256

note: 
    ┌─ uniswap.fe:149:12
    │
149 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0 {
    │            ^^^^^^^^^^^^^^^^     ^^^^^^^^    ^ u256
    │            │                    │            
    │            │                    u256
    │            bool

note: 
    ┌─ uniswap.fe:149:33
    │
149 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0 {
    │                                 ^^^^^^^^^^^^^ bool

note: 
    ┌─ uniswap.fe:149:12
    │
149 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0 {
    │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^    ^ u256
    │            │                                      │            
    │            │                                      u256
    │            bool

note: 
    ┌─ uniswap.fe:149:51
    │
149 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0 {
    │                                                   ^^^^^^^^^^^^^ bool

note: 
    ┌─ uniswap.fe:149:12
    │
149 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0 {
    │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
150 │             self.price0_cumulative_last = self.price0_cumulative_last + reserve1 / reserve0 * time_elapsed
    │             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:150:13
    │
150 │             self.price0_cumulative_last = self.price0_cumulative_last + reserve1 / reserve0 * time_elapsed
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
    │             │                              
    │             SPtr<u256>

note: 
    ┌─ uniswap.fe:150:43
    │
150 │             self.price0_cumulative_last = self.price0_cumulative_last + reserve1 / reserve0 * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^^ u256
    │                                           │                             │           
    │                                           │                             u256
    │                                           SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:150:73
    │
150 │             self.price0_cumulative_last = self.price0_cumulative_last + reserve1 / reserve0 * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256
    │                                                                         │                      
    │                                                                         u256

note: 
    ┌─ uniswap.fe:150:73
    │
150 │             self.price0_cumulative_last = self.price0_cumulative_last + reserve1 / reserve0 * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:150:43
    │
150 │             self.price0_cumulative_last = self.price0_cumulative_last + reserve1 / reserve0 * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
151 │             self.price1_cumulative_last = self.price1_cumulative_last + reserve0 / reserve1 * time_elapsed
    │             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:151:13
    │
151 │             self.price1_cumulative_last = self.price1_cumulative_last + reserve0 / reserve1 * time_elapsed
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
    │             │                              
    │             SPtr<u256>

note: 
    ┌─ uniswap.fe:151:43
    │
151 │             self.price1_cumulative_last = self.price1_cumulative_last + reserve0 / reserve1 * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^^ u256
    │                                           │                             │           
    │                                           │                             u256
    │                                           SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:151:73
    │
151 │             self.price1_cumulative_last = self.price1_cumulative_last + reserve0 / reserve1 * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256
    │                                                                         │                      
    │                                                                         u256

note: 
    ┌─ uniswap.fe:151:73
    │
151 │             self.price1_cumulative_last = self.price1_cumulative_last + reserve0 / reserve1 * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:151:43
    │
151 │             self.price1_cumulative_last = self.price1_cumulative_last + reserve0 / reserve1 * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
152 │         }
153 │         self.reserve0 = balance0
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:153:9
    │
153 │         self.reserve0 = balance0
    │         ^^^^^^^^^^^^^   ^^^^^^^^ u256
    │         │                
    │         SPtr<u256>
154 │         self.reserve1 = balance1
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:154:9
    │
154 │         self.reserve1 = balance1
    │         ^^^^^^^^^^^^^   ^^^^^^^^ u256
    │         │                
    │         SPtr<u256>
155 │         self.block_timestamp_last = block_timestamp
    │         ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:155:9
    │
155 │         self.block_timestamp_last = block_timestamp
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^ u256
    │         │                            
    │         SPtr<u256>
156 │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
    │                   ^^^            ^^^^ UniswapV2Pair
    │                   │               
    │                   Context

note: 
    ┌─ uniswap.fe:156:34
    │
156 │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
    │                                  ^^^^^^^^^^^^^            ^^^^ UniswapV2Pair
    │                                  │                         
    │                                  SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:156:59
    │
156 │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
    │                                                           ^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:159:5
    │  
159 │ ╭     fn _mint_fee(self, ctx: Context, reserve0: u256, reserve1: u256) -> bool {
160 │ │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
161 │ │         let fee_on: bool = fee_to != address(0)
162 │ │         let k_last: u256 = self.k_last
    · │
179 │ │         return fee_on
180 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: reserve0, typ: u256 }, { label: None, name: reserve1, typ: u256 }] -> bool

note: 
    ┌─ uniswap.fe:160:13
    │
160 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │             ^^^^^^ address
161 │         let fee_on: bool = fee_to != address(0)
    │             ^^^^^^ bool
162 │         let k_last: u256 = self.k_last
    │             ^^^^^^ u256
    ·
165 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                     ^^^^^^ u256
166 │                 let root_k_last: u256 = sqrt(k_last)
    │                     ^^^^^^^^^^^ u256
167 │                 if root_k > root_k_last {
168 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                         ^^^^^^^^^ u256
169 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                         ^^^^^^^^^^^ u256
170 │                     let liquidity: u256 = numerator / denominator
    │                         ^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:160:48
    │
160 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                                                ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:160:48
    │
160 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                                                ^^^^^^^^^^^^ SPtr<address> -> address

note: 
    ┌─ uniswap.fe:160:31
    │
160 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:160:31
    │
160 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ address
161 │         let fee_on: bool = fee_to != address(0)
    │                            ^^^^^^            ^ u256
    │                            │                  
    │                            address

note: 
    ┌─ uniswap.fe:161:38
    │
161 │         let fee_on: bool = fee_to != address(0)
    │                                      ^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:161:28
    │
161 │         let fee_on: bool = fee_to != address(0)
    │                            ^^^^^^^^^^^^^^^^^^^^ bool
162 │         let k_last: u256 = self.k_last
    │                            ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:162:28
    │
162 │         let k_last: u256 = self.k_last
    │                            ^^^^^^^^^^^ SPtr<u256> -> u256
163 │         if fee_on {
    │            ^^^^^^ bool
164 │             if k_last != 0 {
    │                ^^^^^^    ^ u256
    │                │          
    │                u256

note: 
    ┌─ uniswap.fe:164:16
    │
164 │             if k_last != 0 {
    │                ^^^^^^^^^^^ bool
165 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                         ^^^^^^^^   ^^^^^^^^ u256
    │                                         │           
    │                                         u256

note: 
    ┌─ uniswap.fe:165:41
    │
165 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                         ^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:165:36
    │
165 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ u256
166 │                 let root_k_last: u256 = sqrt(k_last)
    │                                              ^^^^^^ u256

note: 
    ┌─ uniswap.fe:166:41
    │
166 │                 let root_k_last: u256 = sqrt(k_last)
    │                                         ^^^^^^^^^^^^ u256
167 │                 if root_k > root_k_last {
    │                    ^^^^^^   ^^^^^^^^^^^ u256
    │                    │         
    │                    u256

note: 
    ┌─ uniswap.fe:167:20
    │
167 │                 if root_k > root_k_last {
    │                    ^^^^^^^^^^^^^^^^^^^^ bool
168 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:168:43
    │
168 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^   ^^^^^^ u256
    │                                           │                    
    │                                           SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:168:43
    │
168 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^ u256
    │                                           │                             
    │                                           u256

note: 
    ┌─ uniswap.fe:168:43
    │
168 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
169 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^   ^ u256
    │                                             │         
    │                                             u256

note: 
    ┌─ uniswap.fe:169:45
    │
169 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^^^^^   ^^^^^^^^^^^ u256
    │                                             │             
    │                                             u256

note: 
    ┌─ uniswap.fe:169:45
    │
169 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256
170 │                     let liquidity: u256 = numerator / denominator
    │                                           ^^^^^^^^^   ^^^^^^^^^^^ u256
    │                                           │            
    │                                           u256

note: 
    ┌─ uniswap.fe:170:43
    │
170 │                     let liquidity: u256 = numerator / denominator
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^ u256
171 │                     if liquidity > 0 {
    │                        ^^^^^^^^^   ^ u256
    │                        │            
    │                        u256

note: 
    ┌─ uniswap.fe:171:24
    │
171 │                     if liquidity > 0 {
    │                        ^^^^^^^^^^^^^ bool
172 │                         self._mint(ctx, to: fee_to, value: liquidity)
    │                         ^^^^       ^^^      ^^^^^^         ^^^^^^^^^ u256
    │                         │          │        │               
    │                         │          │        address
    │                         │          Context
    │                         UniswapV2Pair

note: 
    ┌─ uniswap.fe:172:25
    │
172 │                         self._mint(ctx, to: fee_to, value: liquidity)
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
    ·
176 │         } else if k_last != 0 {
    │                   ^^^^^^    ^ u256
    │                   │          
    │                   u256

note: 
    ┌─ uniswap.fe:176:19
    │
176 │         } else if k_last != 0 {
    │                   ^^^^^^^^^^^ bool
177 │             self.k_last = 0
    │             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:177:13
    │
177 │             self.k_last = 0
    │             ^^^^^^^^^^^   ^ u256
    │             │              
    │             SPtr<u256>
178 │         }
179 │         return fee_on
    │                ^^^^^^ bool

note: 
    ┌─ uniswap.fe:183:5
    │  
183 │ ╭     pub fn mint(self, ctx: Context, to: address) -> u256 {
184 │ │         let MINIMUM_LIQUIDITY: u256 = 1000
185 │ │         let reserve0: u256 = self.reserve0
186 │ │         let reserve1: u256 = self.reserve1
    · │
207 │ │         return liquidity
208 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: to, typ: address }] -> u256

note: 
    ┌─ uniswap.fe:184:13
    │
184 │         let MINIMUM_LIQUIDITY: u256 = 1000
    │             ^^^^^^^^^^^^^^^^^ u256
185 │         let reserve0: u256 = self.reserve0
    │             ^^^^^^^^ u256
186 │         let reserve1: u256 = self.reserve1
    │             ^^^^^^^^ u256
187 │         let balance0: u256 = self.token0.balanceOf(ctx.self_address())
    │             ^^^^^^^^ u256
188 │         let balance1: u256 = self.token1.balanceOf(ctx.self_address())
    │             ^^^^^^^^ u256
189 │         let amount0: u256 = balance0 - self.reserve0
    │             ^^^^^^^ u256
190 │         let amount1: u256 = balance1 - self.reserve1
    │             ^^^^^^^ u256
191 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │             ^^^^^^ bool
192 │         let total_supply: u256 = self.total_supply // gas savings, must be defined here since totalSupply can update in _mintFee
    │             ^^^^^^^^^^^^ u256
193 │         let liquidity: u256 = 0
    │             ^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:184:39
    │
184 │         let MINIMUM_LIQUIDITY: u256 = 1000
    │                                       ^^^^ u256
185 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:185:30
    │
185 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ SPtr<u256> -> u256
186 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:186:30
    │
186 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ SPtr<u256> -> u256
187 │         let balance0: u256 = self.token0.balanceOf(ctx.self_address())
    │                              ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:187:30
    │
187 │         let balance0: u256 = self.token0.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^           ^^^ Context
    │                              │                      
    │                              SPtr<ERC20> -> ERC20

note: 
    ┌─ uniswap.fe:187:52
    │
187 │         let balance0: u256 = self.token0.balanceOf(ctx.self_address())
    │                                                    ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:187:30
    │
187 │         let balance0: u256 = self.token0.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
188 │         let balance1: u256 = self.token1.balanceOf(ctx.self_address())
    │                              ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:188:30
    │
188 │         let balance1: u256 = self.token1.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^           ^^^ Context
    │                              │                      
    │                              SPtr<ERC20> -> ERC20

note: 
    ┌─ uniswap.fe:188:52
    │
188 │         let balance1: u256 = self.token1.balanceOf(ctx.self_address())
    │                                                    ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:188:30
    │
188 │         let balance1: u256 = self.token1.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
189 │         let amount0: u256 = balance0 - self.reserve0
    │                             ^^^^^^^^   ^^^^ UniswapV2Pair
    │                             │           
    │                             u256

note: 
    ┌─ uniswap.fe:189:40
    │
189 │         let amount0: u256 = balance0 - self.reserve0
    │                                        ^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:189:29
    │
189 │         let amount0: u256 = balance0 - self.reserve0
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256
190 │         let amount1: u256 = balance1 - self.reserve1
    │                             ^^^^^^^^   ^^^^ UniswapV2Pair
    │                             │           
    │                             u256

note: 
    ┌─ uniswap.fe:190:40
    │
190 │         let amount1: u256 = balance1 - self.reserve1
    │                                        ^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:190:29
    │
190 │         let amount1: u256 = balance1 - self.reserve1
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256
191 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                            ^^^^           ^^^  ^^^^^^^^  ^^^^^^^^ u256
    │                            │              │    │          
    │                            │              │    u256
    │                            │              Context
    │                            UniswapV2Pair

note: 
    ┌─ uniswap.fe:191:28
    │
191 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
192 │         let total_supply: u256 = self.total_supply // gas savings, must be defined here since totalSupply can update in _mintFee
    │                                  ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:192:34
    │
192 │         let total_supply: u256 = self.total_supply // gas savings, must be defined here since totalSupply can update in _mintFee
    │                                  ^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256
193 │         let liquidity: u256 = 0
    │                               ^ u256
194 │         if total_supply == 0 {
    │            ^^^^^^^^^^^^    ^ u256
    │            │                
    │            u256

note: 
    ┌─ uniswap.fe:194:12
    │
194 │         if total_supply == 0 {
    │            ^^^^^^^^^^^^^^^^^ bool
195 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │             ^^^^^^^^^        ^^^^^^^   ^^^^^^^ u256
    │             │                │          
    │             │                u256
    │             u256

note: 
    ┌─ uniswap.fe:195:30
    │
195 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                              ^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:195:25
    │
195 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                         ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^ u256
    │                         │                          
    │                         u256

note: 
    ┌─ uniswap.fe:195:25
    │
195 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
196 │             self._mint(ctx, to: address(0), value: MINIMUM_LIQUIDITY) // permanently lock the first MINIMUM_LIQUIDITY tokens
    │             ^^^^       ^^^              ^ u256
    │             │          │                 
    │             │          Context
    │             UniswapV2Pair

note: 
    ┌─ uniswap.fe:196:33
    │
196 │             self._mint(ctx, to: address(0), value: MINIMUM_LIQUIDITY) // permanently lock the first MINIMUM_LIQUIDITY tokens
    │                                 ^^^^^^^^^^         ^^^^^^^^^^^^^^^^^ u256
    │                                 │                   
    │                                 address

note: 
    ┌─ uniswap.fe:196:13
    │
196 │             self._mint(ctx, to: address(0), value: MINIMUM_LIQUIDITY) // permanently lock the first MINIMUM_LIQUIDITY tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
197 │         } else {
198 │             liquidity = min(amount0 * total_supply / reserve0, amount1 * total_supply / reserve1)
    │             ^^^^^^^^^       ^^^^^^^   ^^^^^^^^^^^^ u256
    │             │               │          
    │             │               u256
    │             u256

note: 
    ┌─ uniswap.fe:198:29
    │
198 │             liquidity = min(amount0 * total_supply / reserve0, amount1 * total_supply / reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^ u256
    │                             │                         
    │                             u256

note: 
    ┌─ uniswap.fe:198:29
    │
198 │             liquidity = min(amount0 * total_supply / reserve0, amount1 * total_supply / reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^   ^^^^^^^^^^^^ u256
    │                             │                                  │          
    │                             │                                  u256
    │                             u256

note: 
    ┌─ uniswap.fe:198:64
    │
198 │             liquidity = min(amount0 * total_supply / reserve0, amount1 * total_supply / reserve1)
    │                                                                ^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^ u256
    │                                                                │                         
    │                                                                u256

note: 
    ┌─ uniswap.fe:198:64
    │
198 │             liquidity = min(amount0 * total_supply / reserve0, amount1 * total_supply / reserve1)
    │                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:198:25
    │
198 │             liquidity = min(amount0 * total_supply / reserve0, amount1 * total_supply / reserve1)
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
199 │         }
200 │         assert liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED"
    │                ^^^^^^^^^   ^ u256
    │                │            
    │                u256

note: 
    ┌─ uniswap.fe:200:16
    │
200 │         assert liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED"
    │                ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<40>
    │                │               
    │                bool
201 │         self._mint(ctx, to, value: liquidity)
    │         ^^^^       ^^^  ^^         ^^^^^^^^^ u256
    │         │          │    │           
    │         │          │    address
    │         │          Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:201:9
    │
201 │         self._mint(ctx, to, value: liquidity)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
202 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256
    │         │            │    │         │         │          
    │         │            │    │         │         u256
    │         │            │    │         u256
    │         │            │    u256
    │         │            Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:202:9
    │
202 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
203 │         if fee_on {
    │            ^^^^^^ bool
204 │             self.k_last = reserve0 * reserve1 // reserve0 and reserve1 are up-to-date
    │             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:204:13
    │
204 │             self.k_last = reserve0 * reserve1 // reserve0 and reserve1 are up-to-date
    │             ^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^^ u256
    │             │             │           
    │             │             u256
    │             SPtr<u256>

note: 
    ┌─ uniswap.fe:204:27
    │
204 │             self.k_last = reserve0 * reserve1 // reserve0 and reserve1 are up-to-date
    │                           ^^^^^^^^^^^^^^^^^^^ u256
205 │         }
206 │         emit Mint(ctx, sender: ctx.msg_sender(), amount0, amount1)
    │                   ^^^          ^^^ Context
    │                   │             
    │                   Context

note: 
    ┌─ uniswap.fe:206:32
    │
206 │         emit Mint(ctx, sender: ctx.msg_sender(), amount0, amount1)
    │                                ^^^^^^^^^^^^^^^^  ^^^^^^^  ^^^^^^^ u256
    │                                │                 │         
    │                                │                 u256
    │                                address
207 │         return liquidity
    │                ^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:211:5
    │  
211 │ ╭     pub fn burn(self, ctx: Context, to: address) -> (u256, u256) {
212 │ │         let reserve0: u256 = self.reserve0
213 │ │         let reserve1: u256 = self.reserve1
214 │ │         let token0: ERC20 = self.token0
    · │
235 │ │         return (amount0, amount1)
236 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: to, typ: address }] -> (u256, u256)

note: 
    ┌─ uniswap.fe:212:13
    │
212 │         let reserve0: u256 = self.reserve0
    │             ^^^^^^^^ u256
213 │         let reserve1: u256 = self.reserve1
    │             ^^^^^^^^ u256
214 │         let token0: ERC20 = self.token0
    │             ^^^^^^ ERC20
215 │         let token1: ERC20 = self.token1
    │             ^^^^^^ ERC20
216 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │             ^^^^^^^^ u256
217 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │             ^^^^^^^^ u256
218 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │             ^^^^^^^^^ u256
219 │ 
220 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │             ^^^^^^ bool
221 │         let total_supply: u256 = self.total_supply // gas savings, must be defined here since total_supply can update in _mintFee
    │             ^^^^^^^^^^^^ u256
222 │         let amount0: u256 = (liquidity * balance0) / total_supply // using balances ensures pro-rata distribution
    │             ^^^^^^^ u256
223 │         let amount1: u256 = (liquidity * balance1) / total_supply // using balances ensures pro-rata distribution
    │             ^^^^^^^ u256

note: 
    ┌─ uniswap.fe:212:30
    │
212 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:212:30
    │
212 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ SPtr<u256> -> u256
213 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:213:30
    │
213 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ SPtr<u256> -> u256
214 │         let token0: ERC20 = self.token0
    │                             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:214:29
    │
214 │         let token0: ERC20 = self.token0
    │                             ^^^^^^^^^^^ SPtr<ERC20> -> ERC20
215 │         let token1: ERC20 = self.token1
    │                             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:215:29
    │
215 │         let token1: ERC20 = self.token1
    │                             ^^^^^^^^^^^ SPtr<ERC20> -> ERC20
216 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                              ^^^^^^           ^^^ Context
    │                              │                 
    │                              ERC20

note: 
    ┌─ uniswap.fe:216:47
    │
216 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                                               ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:216:30
    │
216 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
217 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                              ^^^^^^           ^^^ Context
    │                              │                 
    │                              ERC20

note: 
    ┌─ uniswap.fe:217:47
    │
217 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                                               ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:217:30
    │
217 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
218 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                               ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:218:31
    │
218 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                               ^^^^^^^^^^^^^ ^^^ Context
    │                               │              
    │                               SPtr<Map<address, u256>>

note: 
    ┌─ uniswap.fe:218:45
    │
218 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                                             ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:218:31
    │
218 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256
219 │ 
220 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                            ^^^^           ^^^  ^^^^^^^^  ^^^^^^^^ u256
    │                            │              │    │          
    │                            │              │    u256
    │                            │              Context
    │                            UniswapV2Pair

note: 
    ┌─ uniswap.fe:220:28
    │
220 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
221 │         let total_supply: u256 = self.total_supply // gas savings, must be defined here since total_supply can update in _mintFee
    │                                  ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:221:34
    │
221 │         let total_supply: u256 = self.total_supply // gas savings, must be defined here since total_supply can update in _mintFee
    │                                  ^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256
222 │         let amount0: u256 = (liquidity * balance0) / total_supply // using balances ensures pro-rata distribution
    │                              ^^^^^^^^^   ^^^^^^^^ u256
    │                              │            
    │                              u256

note: 
    ┌─ uniswap.fe:222:29
    │
222 │         let amount0: u256 = (liquidity * balance0) / total_supply // using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256
    │                             │                         
    │                             u256

note: 
    ┌─ uniswap.fe:222:29
    │
222 │         let amount0: u256 = (liquidity * balance0) / total_supply // using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
223 │         let amount1: u256 = (liquidity * balance1) / total_supply // using balances ensures pro-rata distribution
    │                              ^^^^^^^^^   ^^^^^^^^ u256
    │                              │            
    │                              u256

note: 
    ┌─ uniswap.fe:223:29
    │
223 │         let amount1: u256 = (liquidity * balance1) / total_supply // using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256
    │                             │                         
    │                             u256

note: 
    ┌─ uniswap.fe:223:29
    │
223 │         let amount1: u256 = (liquidity * balance1) / total_supply // using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
224 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^   ^ u256
    │                │          
    │                u256

note: 
    ┌─ uniswap.fe:224:16
    │
224 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^^^^^     ^^^^^^^   ^ u256
    │                │               │          
    │                │               u256
    │                bool

note: 
    ┌─ uniswap.fe:224:32
    │
224 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                                ^^^^^^^^^^^ bool

note: 
    ┌─ uniswap.fe:224:16
    │
224 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<40>
    │                │                             
    │                bool
225 │         self._burn(ctx, from: ctx.self_address(), value: liquidity)
    │         ^^^^       ^^^        ^^^ Context
    │         │          │           
    │         │          Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:225:31
    │
225 │         self._burn(ctx, from: ctx.self_address(), value: liquidity)
    │                               ^^^^^^^^^^^^^^^^^^         ^^^^^^^^^ u256
    │                               │                           
    │                               address

note: 
    ┌─ uniswap.fe:225:9
    │
225 │         self._burn(ctx, from: ctx.self_address(), value: liquidity)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
226 │         token0.transfer(to, amount0)
    │         ^^^^^^          ^^  ^^^^^^^ u256
    │         │               │    
    │         │               address
    │         ERC20

note: 
    ┌─ uniswap.fe:226:9
    │
226 │         token0.transfer(to, amount0)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
227 │         token1.transfer(to, amount1)
    │         ^^^^^^          ^^  ^^^^^^^ u256
    │         │               │    
    │         │               address
    │         ERC20

note: 
    ┌─ uniswap.fe:227:9
    │
227 │         token1.transfer(to, amount1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
228 │         balance0 = token0.balanceOf(ctx.self_address())
    │         ^^^^^^^^   ^^^^^^           ^^^ Context
    │         │          │                 
    │         │          ERC20
    │         u256

note: 
    ┌─ uniswap.fe:228:37
    │
228 │         balance0 = token0.balanceOf(ctx.self_address())
    │                                     ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:228:20
    │
228 │         balance0 = token0.balanceOf(ctx.self_address())
    │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
229 │         balance1 = token1.balanceOf(ctx.self_address())
    │         ^^^^^^^^   ^^^^^^           ^^^ Context
    │         │          │                 
    │         │          ERC20
    │         u256

note: 
    ┌─ uniswap.fe:229:37
    │
229 │         balance1 = token1.balanceOf(ctx.self_address())
    │                                     ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:229:20
    │
229 │         balance1 = token1.balanceOf(ctx.self_address())
    │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
230 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256
    │         │            │    │         │         │          
    │         │            │    │         │         u256
    │         │            │    │         u256
    │         │            │    u256
    │         │            Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:230:9
    │
230 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
231 │         if fee_on {
    │            ^^^^^^ bool
232 │             self.k_last = reserve0 * reserve1
    │             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:232:13
    │
232 │             self.k_last = reserve0 * reserve1
    │             ^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^^ u256
    │             │             │           
    │             │             u256
    │             SPtr<u256>

note: 
    ┌─ uniswap.fe:232:27
    │
232 │             self.k_last = reserve0 * reserve1
    │                           ^^^^^^^^^^^^^^^^^^^ u256
233 │         }
234 │         emit Burn(ctx, sender: ctx.msg_sender(), amount0, amount1, to)
    │                   ^^^          ^^^ Context
    │                   │             
    │                   Context

note: 
    ┌─ uniswap.fe:234:32
    │
234 │         emit Burn(ctx, sender: ctx.msg_sender(), amount0, amount1, to)
    │                                ^^^^^^^^^^^^^^^^  ^^^^^^^  ^^^^^^^  ^^ address
    │                                │                 │        │         
    │                                │                 │        u256
    │                                │                 u256
    │                                address
235 │         return (amount0, amount1)
    │                 ^^^^^^^  ^^^^^^^ u256
    │                 │         
    │                 u256

note: 
    ┌─ uniswap.fe:235:16
    │
235 │         return (amount0, amount1)
    │                ^^^^^^^^^^^^^^^^^^ (u256, u256)

note: 
    ┌─ uniswap.fe:241:5
    │  
241 │ ╭     pub fn swap(self, ctx: Context, amount0_out: u256, amount1_out: u256, to: address) {
242 │ │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
243 │ │         let reserve0: u256 = self.reserve0
244 │ │         let reserve1: u256 = self.reserve1
    · │
277 │ │         emit Swap(ctx, sender: ctx.msg_sender(), amount0_in, amount1_in, amount0_out, amount1_out, to)
278 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: amount0_out, typ: u256 }, { label: None, name: amount1_out, typ: u256 }, { label: None, name: to, typ: address }] -> ()

note: 
    ┌─ uniswap.fe:243:13
    │
243 │         let reserve0: u256 = self.reserve0
    │             ^^^^^^^^ u256
244 │         let reserve1: u256 = self.reserve1
    │             ^^^^^^^^ u256
    ·
247 │         let token0: ERC20 = self.token0
    │             ^^^^^^ ERC20
248 │         let token1: ERC20 = self.token1
    │             ^^^^^^ ERC20
    ·
263 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │             ^^^^^^^^ u256
264 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │             ^^^^^^^^ u256
265 │ 
266 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │             ^^^^^^^^^^ u256
267 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │             ^^^^^^^^^^ u256
    ·
271 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │             ^^^^^^^^^^^^^^^^^ u256
272 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │             ^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:242:16
    │
242 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^   ^ u256
    │                │              
    │                u256

note: 
    ┌─ uniswap.fe:242:16
    │
242 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^    ^^^^^^^^^^^   ^ u256
    │                │                  │              
    │                │                  u256
    │                bool

note: 
    ┌─ uniswap.fe:242:35
    │
242 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                                   ^^^^^^^^^^^^^^^ bool

note: 
    ┌─ uniswap.fe:242:16
    │
242 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<37>
    │                │                                    
    │                bool
243 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:243:30
    │
243 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ SPtr<u256> -> u256
244 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:244:30
    │
244 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ SPtr<u256> -> u256
245 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^   ^^^^^^^^ u256
    │                │              
    │                u256

note: 
    ┌─ uniswap.fe:245:16
    │
245 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^   ^^^^^^^^ u256
    │                │                          │              
    │                │                          u256
    │                bool

note: 
    ┌─ uniswap.fe:245:43
    │
245 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                                           ^^^^^^^^^^^^^^^^^^^^^^ bool

note: 
    ┌─ uniswap.fe:245:16
    │
245 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<33>
    │                │                                                   
    │                bool
246 │ 
247 │         let token0: ERC20 = self.token0
    │                             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:247:29
    │
247 │         let token0: ERC20 = self.token0
    │                             ^^^^^^^^^^^ SPtr<ERC20> -> ERC20
248 │         let token1: ERC20 = self.token1
    │                             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:248:29
    │
248 │         let token1: ERC20 = self.token1
    │                             ^^^^^^^^^^^ SPtr<ERC20> -> ERC20
    ·
251 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^            ^^^^^^ ERC20
    │                │              
    │                address

note: 
    ┌─ uniswap.fe:251:22
    │
251 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                      ^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:251:16
    │
251 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^^^^^^^^^^^^^^^^^^^^     ^^            ^^^^^^ ERC20
    │                │                         │              
    │                │                         address
    │                bool

note: 
    ┌─ uniswap.fe:251:48
    │
251 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                                                ^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:251:42
    │
251 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                                          ^^^^^^^^^^^^^^^^^^^^^ bool

note: 
    ┌─ uniswap.fe:251:16
    │
251 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^ String<21>
    │                │                                                 
    │                bool
252 │ 
253 │         if amount0_out > 0 {
    │            ^^^^^^^^^^^   ^ u256
    │            │              
    │            u256

note: 
    ┌─ uniswap.fe:253:12
    │
253 │         if amount0_out > 0 {
    │            ^^^^^^^^^^^^^^^ bool
254 │             token0.transfer(to, amount0_out) // optimistically transfer tokens
    │             ^^^^^^          ^^  ^^^^^^^^^^^ u256
    │             │               │    
    │             │               address
    │             ERC20

note: 
    ┌─ uniswap.fe:254:13
    │
254 │             token0.transfer(to, amount0_out) // optimistically transfer tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
255 │         }
256 │         if amount1_out > 0 {
    │            ^^^^^^^^^^^   ^ u256
    │            │              
    │            u256

note: 
    ┌─ uniswap.fe:256:12
    │
256 │         if amount1_out > 0 {
    │            ^^^^^^^^^^^^^^^ bool
257 │             token1.transfer(to, amount1_out) // optimistically transfer tokens
    │             ^^^^^^          ^^  ^^^^^^^^^^^ u256
    │             │               │    
    │             │               address
    │             ERC20

note: 
    ┌─ uniswap.fe:257:13
    │
257 │             token1.transfer(to, amount1_out) // optimistically transfer tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
    ·
263 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                              ^^^^^^           ^^^ Context
    │                              │                 
    │                              ERC20

note: 
    ┌─ uniswap.fe:263:47
    │
263 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                                               ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:263:30
    │
263 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
264 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                              ^^^^^^           ^^^ Context
    │                              │                 
    │                              ERC20

note: 
    ┌─ uniswap.fe:264:47
    │
264 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                                               ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:264:30
    │
264 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
265 │ 
266 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                                                       ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^^^ u256
    │                                                                       │          │           
    │                                                                       │          u256
    │                                                                       u256

note: 
    ┌─ uniswap.fe:266:82
    │
266 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                                                                  ^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:266:32
    │
266 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
    │                                │                                       
    │                                u256

note: 
    ┌─ uniswap.fe:266:44
    │
266 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                            ^^^^^^^^   ^^^^^^^^^^^ u256
    │                                            │           
    │                                            u256

note: 
    ┌─ uniswap.fe:266:43
    │
266 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:266:32
    │
266 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                           ^ u256
    │                                │                                                                              
    │                                u256

note: 
    ┌─ uniswap.fe:266:32
    │
266 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
267 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                                                       ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^^^ u256
    │                                                                       │          │           
    │                                                                       │          u256
    │                                                                       u256

note: 
    ┌─ uniswap.fe:267:82
    │
267 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                                                                  ^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:267:32
    │
267 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
    │                                │                                       
    │                                u256

note: 
    ┌─ uniswap.fe:267:44
    │
267 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                            ^^^^^^^^   ^^^^^^^^^^^ u256
    │                                            │           
    │                                            u256

note: 
    ┌─ uniswap.fe:267:43
    │
267 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:267:32
    │
267 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                           ^ u256
    │                                │                                                                              
    │                                u256

note: 
    ┌─ uniswap.fe:267:32
    │
267 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
268 │ 
269 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^   ^ u256
    │                │             
    │                u256

note: 
    ┌─ uniswap.fe:269:16
    │
269 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^    ^^^^^^^^^^   ^ u256
    │                │                 │             
    │                │                 u256
    │                bool

note: 
    ┌─ uniswap.fe:269:34
    │
269 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                                  ^^^^^^^^^^^^^^ bool

note: 
    ┌─ uniswap.fe:269:16
    │
269 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<36>
    │                │                                  
    │                bool
270 │ 
271 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^   ^^^^ u256
    │                                       │           
    │                                       u256

note: 
    ┌─ uniswap.fe:271:39
    │
271 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^^^^^^^^   ^^^^^^^^^^   ^ u256
    │                                       │                 │             
    │                                       │                 u256
    │                                       u256

note: 
    ┌─ uniswap.fe:271:57
    │
271 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                                         ^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:271:39
    │
271 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
272 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^   ^^^^ u256
    │                                       │           
    │                                       u256

note: 
    ┌─ uniswap.fe:272:39
    │
272 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^^^^^^^^   ^^^^^^^^^^   ^ u256
    │                                       │                 │             
    │                                       │                 u256
    │                                       u256

note: 
    ┌─ uniswap.fe:272:57
    │
272 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                                         ^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:272:39
    │
272 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
273 │ 
274 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^ u256
    │                │                    
    │                u256

note: 
    ┌─ uniswap.fe:274:16
    │
274 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^   ^^^^^^^^ u256
    │                │                                        │           
    │                │                                        u256
    │                u256

note: 
    ┌─ uniswap.fe:274:57
    │
274 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                                                         ^^^^^^^^^^^^^^^^^^^   ^^^^^^^ u256
    │                                                         │                      
    │                                                         u256

note: 
    ┌─ uniswap.fe:274:57
    │
274 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:274:16
    │
274 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^ String<12>
    │                │                                                                        
    │                bool
275 │ 
276 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256
    │         │            │    │         │         │          
    │         │            │    │         │         u256
    │         │            │    │         u256
    │         │            │    u256
    │         │            Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:276:9
    │
276 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
277 │         emit Swap(ctx, sender: ctx.msg_sender(), amount0_in, amount1_in, amount0_out, amount1_out, to)
    │                   ^^^          ^^^ Context
    │                   │             
    │                   Context

note: 
    ┌─ uniswap.fe:277:32
    │
277 │         emit Swap(ctx, sender: ctx.msg_sender(), amount0_in, amount1_in, amount0_out, amount1_out, to)
    │                                ^^^^^^^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^  ^^ address
    │                                │                 │           │           │            │             
    │                                │                 │           │           │            u256
    │                                │                 │           │           u256
    │                                │                 │           u256
    │                                │                 u256
    │                                address

note: 
    ┌─ uniswap.fe:281:5
    │  
281 │ ╭     pub fn skim(self, ctx: Context, to: address) {
282 │ │         let token0: ERC20 = self.token0 // gas savings
283 │ │         let token1: ERC20 = self.token1 // gas savings
284 │ │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
285 │ │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
286 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: to, typ: address }] -> ()

note: 
    ┌─ uniswap.fe:282:13
    │
282 │         let token0: ERC20 = self.token0 // gas savings
    │             ^^^^^^ ERC20
283 │         let token1: ERC20 = self.token1 // gas savings
    │             ^^^^^^ ERC20

note: 
    ┌─ uniswap.fe:282:29
    │
282 │         let token0: ERC20 = self.token0 // gas savings
    │                             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:282:29
    │
282 │         let token0: ERC20 = self.token0 // gas savings
    │                             ^^^^^^^^^^^ SPtr<ERC20> -> ERC20
283 │         let token1: ERC20 = self.token1 // gas savings
    │                             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:283:29
    │
283 │         let token1: ERC20 = self.token1 // gas savings
    │                             ^^^^^^^^^^^ SPtr<ERC20> -> ERC20
284 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │         ^^^^^^          ^^  ^^^^^^           ^^^ Context
    │         │               │   │                 
    │         │               │   ERC20
    │         │               address
    │         ERC20

note: 
    ┌─ uniswap.fe:284:46
    │
284 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │                                              ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:284:29
    │
284 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
    │                             │                                       
    │                             u256

note: 
    ┌─ uniswap.fe:284:68
    │
284 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │                                                                    ^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:284:29
    │
284 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:284:9
    │
284 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool
285 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │         ^^^^^^          ^^  ^^^^^^           ^^^ Context
    │         │               │   │                 
    │         │               │   ERC20
    │         │               address
    │         ERC20

note: 
    ┌─ uniswap.fe:285:46
    │
285 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │                                              ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:285:29
    │
285 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair
    │                             │                                       
    │                             u256

note: 
    ┌─ uniswap.fe:285:68
    │
285 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │                                                                    ^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:285:29
    │
285 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:285:9
    │
285 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool

note: 
    ┌─ uniswap.fe:289:5
    │  
289 │ ╭     pub fn sync(self, ctx: Context) {
290 │ │         let token0: ERC20 = self.token0
291 │ │         let token1: ERC20 = self.token1
292 │ │         self._update(ctx,
    · │
296 │ │                      reserve1: self.reserve1)
297 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }] -> ()

note: 
    ┌─ uniswap.fe:290:13
    │
290 │         let token0: ERC20 = self.token0
    │             ^^^^^^ ERC20
291 │         let token1: ERC20 = self.token1
    │             ^^^^^^ ERC20

note: 
    ┌─ uniswap.fe:290:29
    │
290 │         let token0: ERC20 = self.token0
    │                             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:290:29
    │
290 │         let token0: ERC20 = self.token0
    │                             ^^^^^^^^^^^ SPtr<ERC20> -> ERC20
291 │         let token1: ERC20 = self.token1
    │                             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:291:29
    │
291 │         let token1: ERC20 = self.token1
    │                             ^^^^^^^^^^^ SPtr<ERC20> -> ERC20
292 │         self._update(ctx,
    │         ^^^^         ^^^ Context
    │         │             
    │         UniswapV2Pair
293 │                      balance0: token0.balanceOf(ctx.self_address()),
    │                                ^^^^^^           ^^^ Context
    │                                │                 
    │                                ERC20

note: 
    ┌─ uniswap.fe:293:49
    │
293 │                      balance0: token0.balanceOf(ctx.self_address()),
    │                                                 ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:293:32
    │
293 │                      balance0: token0.balanceOf(ctx.self_address()),
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
294 │                      balance1: token1.balanceOf(ctx.self_address()),
    │                                ^^^^^^           ^^^ Context
    │                                │                 
    │                                ERC20

note: 
    ┌─ uniswap.fe:294:49
    │
294 │                      balance1: token1.balanceOf(ctx.self_address()),
    │                                                 ^^^^^^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:294:32
    │
294 │                      balance1: token1.balanceOf(ctx.self_address()),
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
295 │                      reserve0: self.reserve0,
    │                                ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:295:32
    │
295 │                      reserve0: self.reserve0,
    │                                ^^^^^^^^^^^^^ SPtr<u256> -> u256
296 │                      reserve1: self.reserve1)
    │                                ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:296:32
    │
296 │                      reserve1: self.reserve1)
    │                                ^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:292:9
    │  
292 │ ╭         self._update(ctx,
293 │ │                      balance0: token0.balanceOf(ctx.self_address()),
294 │ │                      balance1: token1.balanceOf(ctx.self_address()),
295 │ │                      reserve0: self.reserve0,
296 │ │                      reserve1: self.reserve1)
    │ ╰─────────────────────────────────────────────^ ()

note: 
    ┌─ uniswap.fe:301:5
    │
301 │     fee_to: address
    │     ^^^^^^^^^^^^^^^ address
302 │     fee_to_setter: address
    │     ^^^^^^^^^^^^^^^^^^^^^^ address
303 │ 
304 │     pairs: Map<address, Map<address, address>>
    │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, Map<address, address>>
305 │ 
306 │     all_pairs: Array<address, 100>
    │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Array<address, 100>
307 │     pair_counter: u256
    │     ^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:310:9
    │
310 │         idx token0: address
    │         ^^^^^^^^^^^^^^^^^^^ address
311 │         idx token1: address
    │         ^^^^^^^^^^^^^^^^^^^ address
312 │         pair: address
    │         ^^^^^^^^^^^^^ address
313 │         index: u256
    │         ^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:320:5
    │  
320 │ ╭     pub fn fee_to(self) -> address {
321 │ │         return self.fee_to
322 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [] -> address

note: 
    ┌─ uniswap.fe:321:16
    │
321 │         return self.fee_to
    │                ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:321:16
    │
321 │         return self.fee_to
    │                ^^^^^^^^^^^ SPtr<address> -> address

note: 
    ┌─ uniswap.fe:324:5
    │  
324 │ ╭     pub fn fee_to_setter(self) -> address {
325 │ │         return self.fee_to_setter
326 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [] -> address

note: 
    ┌─ uniswap.fe:325:16
    │
325 │         return self.fee_to_setter
    │                ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:325:16
    │
325 │         return self.fee_to_setter
    │                ^^^^^^^^^^^^^^^^^^ SPtr<address> -> address

note: 
    ┌─ uniswap.fe:328:5
    │  
328 │ ╭     pub fn all_pairs_length(self) -> u256 {
329 │ │         return self.pair_counter
330 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [] -> u256

note: 
    ┌─ uniswap.fe:329:16
    │
329 │         return self.pair_counter
    │                ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:329:16
    │
329 │         return self.pair_counter
    │                ^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:332:5
    │  
332 │ ╭     pub fn create_pair(self, ctx: Context, _ token_a: address, _ token_b: address) -> address {
333 │ │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
334 │ │ 
335 │ │         let token0: address = token_a if token_a < token_b else token_b
    · │
350 │ │         return address(pair)
351 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: Some("_"), name: token_a, typ: address }, { label: Some("_"), name: token_b, typ: address }] -> address

note: 
    ┌─ uniswap.fe:335:13
    │
335 │         let token0: address = token_a if token_a < token_b else token_b
    │             ^^^^^^ address
336 │         let token1: address = token_a if token_a > token_b else token_b
    │             ^^^^^^ address
    ·
340 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │             ^^^^ u256
341 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(ctx, 0, salt)
    │             ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:333:16
    │
333 │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
    │                ^^^^^^^    ^^^^^^^ address
    │                │           
    │                address

note: 
    ┌─ uniswap.fe:333:16
    │
333 │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
    │                ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<30>
    │                │                    
    │                bool
334 │ 
335 │         let token0: address = token_a if token_a < token_b else token_b
    │                                          ^^^^^^^   ^^^^^^^ address
    │                                          │          
    │                                          address

note: 
    ┌─ uniswap.fe:335:31
    │
335 │         let token0: address = token_a if token_a < token_b else token_b
    │                               ^^^^^^^    ^^^^^^^^^^^^^^^^^      ^^^^^^^ address
    │                               │          │                       
    │                               │          bool
    │                               address

note: 
    ┌─ uniswap.fe:335:31
    │
335 │         let token0: address = token_a if token_a < token_b else token_b
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ address
336 │         let token1: address = token_a if token_a > token_b else token_b
    │                                          ^^^^^^^   ^^^^^^^ address
    │                                          │          
    │                                          address

note: 
    ┌─ uniswap.fe:336:31
    │
336 │         let token1: address = token_a if token_a > token_b else token_b
    │                               ^^^^^^^    ^^^^^^^^^^^^^^^^^      ^^^^^^^ address
    │                               │          │                       
    │                               │          bool
    │                               address

note: 
    ┌─ uniswap.fe:336:31
    │
336 │         let token1: address = token_a if token_a > token_b else token_b
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ address
337 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                ^^^^^^            ^ u256
    │                │                  
    │                address

note: 
    ┌─ uniswap.fe:337:26
    │
337 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                          ^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:337:16
    │
337 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^ String<23>
    │                │                      
    │                bool
338 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:338:16
    │
338 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^ ^^^^^^ address
    │                │           
    │                SPtr<Map<address, Map<address, address>>>

note: 
    ┌─ uniswap.fe:338:16
    │
338 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^ ^^^^^^ address
    │                │                   
    │                SPtr<Map<address, address>>

note: 
    ┌─ uniswap.fe:338:16
    │
338 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^            ^ u256
    │                │                                      
    │                SPtr<address> -> address

note: 
    ┌─ uniswap.fe:338:46
    │
338 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                                              ^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:338:16
    │
338 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^ String<22>
    │                │                                          
    │                bool
339 │ 
340 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                     ^^^^^^  ^^^^^^ address
    │                                     │        
    │                                     address

note: 
    ┌─ uniswap.fe:340:36
    │
340 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                    ^^^^^^^^^^^^^^^^ (address, address)

note: 
    ┌─ uniswap.fe:340:36
    │
340 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Array<u8, 64>

note: 
    ┌─ uniswap.fe:340:26
    │
340 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
341 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(ctx, 0, salt)
    │                                                         ^^^  ^  ^^^^ u256
    │                                                         │    │   
    │                                                         │    u256
    │                                                         Context

note: 
    ┌─ uniswap.fe:341:35
    │
341 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(ctx, 0, salt)
    │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UniswapV2Pair
342 │         pair.initialize(ctx, token0: ERC20(token0), token1: ERC20(token1))
    │         ^^^^            ^^^                ^^^^^^ address
    │         │               │                   
    │         │               Context
    │         UniswapV2Pair

note: 
    ┌─ uniswap.fe:342:38
    │
342 │         pair.initialize(ctx, token0: ERC20(token0), token1: ERC20(token1))
    │                                      ^^^^^^^^^^^^^                ^^^^^^ address
    │                                      │                             
    │                                      ERC20

note: 
    ┌─ uniswap.fe:342:61
    │
342 │         pair.initialize(ctx, token0: ERC20(token0), token1: ERC20(token1))
    │                                                             ^^^^^^^^^^^^^ ERC20

note: 
    ┌─ uniswap.fe:342:9
    │
342 │         pair.initialize(ctx, token0: ERC20(token0), token1: ERC20(token1))
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ()
343 │ 
344 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:344:9
    │
344 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^ ^^^^^^ address
    │         │           
    │         SPtr<Map<address, Map<address, address>>>

note: 
    ┌─ uniswap.fe:344:9
    │
344 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^ ^^^^^^ address
    │         │                   
    │         SPtr<Map<address, address>>

note: 
    ┌─ uniswap.fe:344:9
    │
344 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair
    │         │                                     
    │         SPtr<address>

note: 
    ┌─ uniswap.fe:344:38
    │
344 │         self.pairs[token0][token1] = address(pair)
    │                                      ^^^^^^^^^^^^^ address
345 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:345:9
    │
345 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^ ^^^^^^ address
    │         │           
    │         SPtr<Map<address, Map<address, address>>>

note: 
    ┌─ uniswap.fe:345:9
    │
345 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^ ^^^^^^ address
    │         │                   
    │         SPtr<Map<address, address>>

note: 
    ┌─ uniswap.fe:345:9
    │
345 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair
    │         │                                     
    │         SPtr<address>

note: 
    ┌─ uniswap.fe:345:38
    │
345 │         self.pairs[token1][token0] = address(pair)
    │                                      ^^^^^^^^^^^^^ address
346 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:346:9
    │
346 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^^^^^^^^^^^ ^^^^ UniswapV2Factory
    │         │               
    │         SPtr<Array<address, 100>>

note: 
    ┌─ uniswap.fe:346:24
    │
346 │         self.all_pairs[self.pair_counter] = address(pair)
    │                        ^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:346:9
    │
346 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair
    │         │                                            
    │         SPtr<address>

note: 
    ┌─ uniswap.fe:346:45
    │
346 │         self.all_pairs[self.pair_counter] = address(pair)
    │                                             ^^^^^^^^^^^^^ address
347 │         self.pair_counter = self.pair_counter + 1
    │         ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:347:9
    │
347 │         self.pair_counter = self.pair_counter + 1
    │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Factory
    │         │                    
    │         SPtr<u256>

note: 
    ┌─ uniswap.fe:347:29
    │
347 │         self.pair_counter = self.pair_counter + 1
    │                             ^^^^^^^^^^^^^^^^^   ^ u256
    │                             │                    
    │                             SPtr<u256> -> u256

note: 
    ┌─ uniswap.fe:347:29
    │
347 │         self.pair_counter = self.pair_counter + 1
    │                             ^^^^^^^^^^^^^^^^^^^^^ u256
348 │ 
349 │         emit PairCreated(ctx, token0, token1, pair: address(pair), index: self.pair_counter)
    │                          ^^^  ^^^^^^  ^^^^^^                ^^^^ UniswapV2Pair
    │                          │    │       │                      
    │                          │    │       address
    │                          │    address
    │                          Context

note: 
    ┌─ uniswap.fe:349:53
    │
349 │         emit PairCreated(ctx, token0, token1, pair: address(pair), index: self.pair_counter)
    │                                                     ^^^^^^^^^^^^^         ^^^^ UniswapV2Factory
    │                                                     │                      
    │                                                     address

note: 
    ┌─ uniswap.fe:349:75
    │
349 │         emit PairCreated(ctx, token0, token1, pair: address(pair), index: self.pair_counter)
    │                                                                           ^^^^^^^^^^^^^^^^^ SPtr<u256> -> u256
350 │         return address(pair)
    │                        ^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:350:16
    │
350 │         return address(pair)
    │                ^^^^^^^^^^^^^ address

note: 
    ┌─ uniswap.fe:353:5
    │  
353 │ ╭     pub fn set_fee_to(self, ctx: Context, fee_to: address) {
354 │ │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
355 │ │         self.fee_to = fee_to
356 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: fee_to, typ: address }] -> ()

note: 
    ┌─ uniswap.fe:354:16
    │
354 │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^ Context

note: 
    ┌─ uniswap.fe:354:16
    │
354 │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^    ^^^^ UniswapV2Factory
    │                │                    
    │                address

note: 
    ┌─ uniswap.fe:354:36
    │
354 │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                                    ^^^^^^^^^^^^^^^^^^ SPtr<address> -> address

note: 
    ┌─ uniswap.fe:354:16
    │
354 │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>
    │                │                                        
    │                bool
355 │         self.fee_to = fee_to
    │         ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:355:9
    │
355 │         self.fee_to = fee_to
    │         ^^^^^^^^^^^   ^^^^^^ address
    │         │              
    │         SPtr<address>

note: 
    ┌─ uniswap.fe:358:5
    │  
358 │ ╭     pub fn set_fee_to_setter(self, ctx: Context, fee_to_setter: address) {
359 │ │         assert ctx.msg_sender() == fee_to_setter, "UniswapV2: FORBIDDEN"
360 │ │         self.fee_to_setter = fee_to_setter
361 │ │     }
    │ ╰─────^ self: Some(Mutable), params: [{ label: None, name: ctx, typ: Context }, { label: None, name: fee_to_setter, typ: address }] -> ()

note: 
    ┌─ uniswap.fe:359:16
    │
359 │         assert ctx.msg_sender() == fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^ Context

note: 
    ┌─ uniswap.fe:359:16
    │
359 │         assert ctx.msg_sender() == fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^ address
    │                │                    
    │                address

note: 
    ┌─ uniswap.fe:359:16
    │
359 │         assert ctx.msg_sender() == fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>
    │                │                                   
    │                bool
360 │         self.fee_to_setter = fee_to_setter
    │         ^^^^ UniswapV2Factory

note: 
    ┌─ uniswap.fe:360:9
    │
360 │         self.fee_to_setter = fee_to_setter
    │         ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ address
    │         │                     
    │         SPtr<address>

note: 
    ┌─ uniswap.fe:364:1
    │  
364 │ ╭ fn sqrt(_ val: u256) -> u256 {
365 │ │     let z: u256
366 │ │     if val > 3 {
367 │ │         z = val
    · │
376 │ │     return z
377 │ │ }
    │ ╰─^ self: None, params: [{ label: Some("_"), name: val, typ: u256 }] -> u256

note: 
    ┌─ uniswap.fe:365:9
    │
365 │     let z: u256
    │         ^ u256
    ·
368 │         let x: u256 = val / 2 + 1
    │             ^ u256

note: 
    ┌─ uniswap.fe:366:8
    │
366 │     if val > 3 {
    │        ^^^   ^ u256
    │        │      
    │        u256

note: 
    ┌─ uniswap.fe:366:8
    │
366 │     if val > 3 {
    │        ^^^^^^^ bool
367 │         z = val
    │         ^   ^^^ u256
    │         │    
    │         u256
368 │         let x: u256 = val / 2 + 1
    │                       ^^^   ^ u256
    │                       │      
    │                       u256

note: 
    ┌─ uniswap.fe:368:23
    │
368 │         let x: u256 = val / 2 + 1
    │                       ^^^^^^^   ^ u256
    │                       │          
    │                       u256

note: 
    ┌─ uniswap.fe:368:23
    │
368 │         let x: u256 = val / 2 + 1
    │                       ^^^^^^^^^^^ u256
369 │         while x < z {
    │               ^   ^ u256
    │               │    
    │               u256

note: 
    ┌─ uniswap.fe:369:15
    │
369 │         while x < z {
    │               ^^^^^ bool
370 │             z = x
    │             ^   ^ u256
    │             │    
    │             u256
371 │             x = (val / x + x) / 2
    │             ^    ^^^   ^ u256
    │             │    │      
    │             │    u256
    │             u256

note: 
    ┌─ uniswap.fe:371:18
    │
371 │             x = (val / x + x) / 2
    │                  ^^^^^^^   ^ u256
    │                  │          
    │                  u256

note: 
    ┌─ uniswap.fe:371:17
    │
371 │             x = (val / x + x) / 2
    │                 ^^^^^^^^^^^^^   ^ u256
    │                 │                
    │                 u256

note: 
    ┌─ uniswap.fe:371:17
    │
371 │             x = (val / x + x) / 2
    │                 ^^^^^^^^^^^^^^^^^ u256
372 │         }
373 │     } else if val != 0 {
    │               ^^^    ^ u256
    │               │       
    │               u256

note: 
    ┌─ uniswap.fe:373:15
    │
373 │     } else if val != 0 {
    │               ^^^^^^^^ bool
374 │         z = 1
    │         ^   ^ u256
    │         │    
    │         u256
375 │     }
376 │     return z
    │            ^ u256

note: 
    ┌─ uniswap.fe:379:1
    │  
379 │ ╭ fn min(_ x: u256, _ y: u256) -> u256 {
380 │ │     return x if x < y else y
381 │ │ }
    │ ╰─^ self: None, params: [{ label: Some("_"), name: x, typ: u256 }, { label: Some("_"), name: y, typ: u256 }] -> u256

note: 
    ┌─ uniswap.fe:380:17
    │
380 │     return x if x < y else y
    │                 ^   ^ u256
    │                 │    
    │                 u256

note: 
    ┌─ uniswap.fe:380:12
    │
380 │     return x if x < y else y
    │            ^    ^^^^^      ^ u256
    │            │    │           
    │            │    bool
    │            u256

note: 
    ┌─ uniswap.fe:380:12
    │
380 │     return x if x < y else y
    │            ^^^^^^^^^^^^^^^^^ u256


