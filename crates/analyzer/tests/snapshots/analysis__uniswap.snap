---
source: crates/analyzer/tests/analysis.rs
expression: "build_snapshot(&db, module)"

---
note: 
  ┌─ uniswap.fe:4:5
  │  
4 │ ╭     pub fn balanceOf(account: address) -> u256:
5 │ │         return 0
  │ ╰────────────────^ attributes hash: 2137329072726581226
  │  
  = FunctionSignature {
        self_decl: None,
        ctx_decl: None,
        params: [
            FunctionParam {
                name: "account",
                typ: Ok(
                    Base(
                        Address,
                    ),
                ),
            },
        ],
        return_type: Ok(
            Base(
                Numeric(
                    U256,
                ),
            ),
        ),
    }

note: 
  ┌─ uniswap.fe:5:16
  │
5 │         return 0
  │                ^ u256: Value

note: 
  ┌─ uniswap.fe:7:5
  │  
7 │ ╭     pub fn transfer(recipient: address, amount: u256) -> bool:
8 │ │         return false
  │ ╰────────────────────^ attributes hash: 14278358233768701433
  │  
  = FunctionSignature {
        self_decl: None,
        ctx_decl: None,
        params: [
            FunctionParam {
                name: "recipient",
                typ: Ok(
                    Base(
                        Address,
                    ),
                ),
            },
            FunctionParam {
                name: "amount",
                typ: Ok(
                    Base(
                        Numeric(
                            U256,
                        ),
                    ),
                ),
            },
        ],
        return_type: Ok(
            Base(
                Bool,
            ),
        ),
    }

note: 
  ┌─ uniswap.fe:8:16
  │
8 │         return false
  │                ^^^^^ bool: Value

note: 
   ┌─ uniswap.fe:14:5
   │
14 │     balances: Map<address, u256>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, u256>
15 │     allowances: Map<address, Map<address, u256>>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, Map<address, u256>>
16 │     total_supply: u256
   │     ^^^^^^^^^^^^^^^^^^ u256
17 │ 
18 │     nonces: Map<address, u256>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, u256>
19 │ 
20 │     factory: address
   │     ^^^^^^^^^^^^^^^^ address
21 │     token0: address
   │     ^^^^^^^^^^^^^^^ address
22 │     token1: address
   │     ^^^^^^^^^^^^^^^ address
23 │ 
24 │     reserve0: u256
   │     ^^^^^^^^^^^^^^ u256
25 │     reserve1: u256
   │     ^^^^^^^^^^^^^^ u256
26 │     block_timestamp_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
27 │ 
28 │     price0_cumulative_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
29 │     price1_cumulative_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
30 │     k_last: u256
   │     ^^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:33:9
   │
33 │         idx owner: address
   │         ^^^^^^^^^^^^^^^^^^ address
34 │         idx spender: address
   │         ^^^^^^^^^^^^^^^^^^^^ address
35 │         value: u256
   │         ^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:38:9
   │
38 │         idx from: address
   │         ^^^^^^^^^^^^^^^^^ address
39 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address
40 │         value: u256
   │         ^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:43:9
   │
43 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
44 │         amount0: u256
   │         ^^^^^^^^^^^^^ u256
45 │         amount1: u256
   │         ^^^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:48:9
   │
48 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
49 │         amount0: u256
   │         ^^^^^^^^^^^^^ u256
50 │         amount1: u256
   │         ^^^^^^^^^^^^^ u256
51 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address

note: 
   ┌─ uniswap.fe:54:9
   │
54 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
55 │         amount0_in: u256
   │         ^^^^^^^^^^^^^^^^ u256
56 │         amount1_in: u256
   │         ^^^^^^^^^^^^^^^^ u256
57 │         amount0_out: u256
   │         ^^^^^^^^^^^^^^^^^ u256
58 │         amount1_out: u256
   │         ^^^^^^^^^^^^^^^^^ u256
59 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address

note: 
   ┌─ uniswap.fe:62:9
   │
62 │         reserve0: u256
   │         ^^^^^^^^^^^^^^ u256
63 │         reserve1: u256
   │         ^^^^^^^^^^^^^^ u256

note: 
   ┌─ uniswap.fe:68:5
   │  
68 │ ╭     pub fn factory(self) -> address:
69 │ │         return self.factory
   │ ╰───────────────────────────^ attributes hash: 227275695522088782
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         ctx_decl: None,
         params: [],
         return_type: Ok(
             Base(
                 Address,
             ),
         ),
     }

note: 
   ┌─ uniswap.fe:69:16
   │
69 │         return self.factory
   │                ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:69:16
   │
69 │         return self.factory
   │                ^^^^^^^^^^^^ address: Storage { nonce: Some(4) } => Value

note: 
   ┌─ uniswap.fe:71:5
   │  
71 │ ╭     pub fn token0(self) -> address:
72 │ │         return self.token0
   │ ╰──────────────────────────^ attributes hash: 227275695522088782
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         ctx_decl: None,
         params: [],
         return_type: Ok(
             Base(
                 Address,
             ),
         ),
     }

note: 
   ┌─ uniswap.fe:72:16
   │
72 │         return self.token0
   │                ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:72:16
   │
72 │         return self.token0
   │                ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
   ┌─ uniswap.fe:74:5
   │  
74 │ ╭     pub fn token1(self) -> address:
75 │ │         return self.token1
   │ ╰──────────────────────────^ attributes hash: 227275695522088782
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         ctx_decl: None,
         params: [],
         return_type: Ok(
             Base(
                 Address,
             ),
         ),
     }

note: 
   ┌─ uniswap.fe:75:16
   │
75 │         return self.token1
   │                ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:75:16
   │
75 │         return self.token1
   │                ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
   ┌─ uniswap.fe:77:5
   │  
77 │ ╭     fn _mint(self, ctx: Context, to: address, value: u256):
78 │ │         self.total_supply = self.total_supply + value
79 │ │         self.balances[to] = self.balances[to] + value
80 │ │         emit Transfer(ctx, from: address(0), to, value)
   │ ╰───────────────────────────────────────────────────────^ attributes hash: 8083461052236716587
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         ctx_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "ctx",
                 typ: Ok(
                     Struct(
                         Struct {
                             name: "Context",
                             field_count: 0,
                         },
                     ),
                 ),
             },
             FunctionParam {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Unit,
             ),
         ),
     }

note: 
   ┌─ uniswap.fe:78:9
   │
78 │         self.total_supply = self.total_supply + value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:78:9
   │
78 │         self.total_supply = self.total_supply + value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                    
   │         u256: Storage { nonce: Some(2) }

note: 
   ┌─ uniswap.fe:78:29
   │
78 │         self.total_supply = self.total_supply + value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                             │                    
   │                             u256: Storage { nonce: Some(2) } => Value

note: 
   ┌─ uniswap.fe:78:29
   │
78 │         self.total_supply = self.total_supply + value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
79 │         self.balances[to] = self.balances[to] + value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:79:9
   │
79 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^ ^^ address: Value
   │         │              
   │         Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ uniswap.fe:79:9
   │
79 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                    
   │         u256: Storage { nonce: None }

note: 
   ┌─ uniswap.fe:79:29
   │
79 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^ ^^ address: Value
   │                             │              
   │                             Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ uniswap.fe:79:29
   │
79 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                             │                    
   │                             u256: Storage { nonce: None } => Value

note: 
   ┌─ uniswap.fe:79:29
   │
79 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
80 │         emit Transfer(ctx, from: address(0), to, value)
   │                       ^^^                ^ u256: Value
   │                       │                   
   │                       Context: Memory

note: 
   ┌─ uniswap.fe:80:34
   │
80 │         emit Transfer(ctx, from: address(0), to, value)
   │                                  ^^^^^^^^^^  ^^  ^^^^^ u256: Value
   │                                  │           │    
   │                                  │           address: Value
   │                                  address: Value

note: 
   ┌─ uniswap.fe:80:9
   │
80 │         emit Transfer(ctx, from: address(0), to, value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 5533489995250141934
   │
   = Event {
         name: "Transfer",
         fields: [
             EventField {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
                 is_indexed: false,
             },
         ],
     }

note: 
   ┌─ uniswap.fe:82:5
   │  
82 │ ╭     fn _burn(self, ctx: Context, from: address, value: u256):
83 │ │         self.balances[from] = self.balances[from] - value
84 │ │         self.total_supply = self.total_supply - value
85 │ │         emit Transfer(ctx, from, to: address(0), value)
   │ ╰───────────────────────────────────────────────────────^ attributes hash: 5051284079043548081
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         ctx_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "ctx",
                 typ: Ok(
                     Struct(
                         Struct {
                             name: "Context",
                             field_count: 0,
                         },
                     ),
                 ),
             },
             FunctionParam {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Unit,
             ),
         ),
     }

note: 
   ┌─ uniswap.fe:83:9
   │
83 │         self.balances[from] = self.balances[from] - value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:83:9
   │
83 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^ ^^^^ address: Value
   │         │              
   │         Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ uniswap.fe:83:9
   │
83 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                      
   │         u256: Storage { nonce: None }

note: 
   ┌─ uniswap.fe:83:31
   │
83 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^ ^^^^ address: Value
   │                               │              
   │                               Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ uniswap.fe:83:31
   │
83 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                               │                      
   │                               u256: Storage { nonce: None } => Value

note: 
   ┌─ uniswap.fe:83:31
   │
83 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
84 │         self.total_supply = self.total_supply - value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:84:9
   │
84 │         self.total_supply = self.total_supply - value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                    
   │         u256: Storage { nonce: Some(2) }

note: 
   ┌─ uniswap.fe:84:29
   │
84 │         self.total_supply = self.total_supply - value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                             │                    
   │                             u256: Storage { nonce: Some(2) } => Value

note: 
   ┌─ uniswap.fe:84:29
   │
84 │         self.total_supply = self.total_supply - value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
85 │         emit Transfer(ctx, from, to: address(0), value)
   │                       ^^^  ^^^^              ^ u256: Value
   │                       │    │                  
   │                       │    address: Value
   │                       Context: Memory

note: 
   ┌─ uniswap.fe:85:38
   │
85 │         emit Transfer(ctx, from, to: address(0), value)
   │                                      ^^^^^^^^^^  ^^^^^ u256: Value
   │                                      │            
   │                                      address: Value

note: 
   ┌─ uniswap.fe:85:9
   │
85 │         emit Transfer(ctx, from, to: address(0), value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 5533489995250141934
   │
   = Event {
         name: "Transfer",
         fields: [
             EventField {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
                 is_indexed: false,
             },
         ],
     }

note: 
   ┌─ uniswap.fe:87:5
   │  
87 │ ╭     fn _approve(self, ctx: Context, owner: address, spender: address, value: u256):
88 │ │         self.allowances[owner][spender] = value
89 │ │         emit Approval(ctx, owner, spender, value)
   │ ╰─────────────────────────────────────────────────^ attributes hash: 16582163020557730049
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         ctx_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "ctx",
                 typ: Ok(
                     Struct(
                         Struct {
                             name: "Context",
                             field_count: 0,
                         },
                     ),
                 ),
             },
             FunctionParam {
                 name: "owner",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "spender",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Unit,
             ),
         ),
     }

note: 
   ┌─ uniswap.fe:88:9
   │
88 │         self.allowances[owner][spender] = value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:88:9
   │
88 │         self.allowances[owner][spender] = value
   │         ^^^^^^^^^^^^^^^ ^^^^^ address: Value
   │         │                
   │         Map<address, Map<address, u256>>: Storage { nonce: Some(1) }

note: 
   ┌─ uniswap.fe:88:9
   │
88 │         self.allowances[owner][spender] = value
   │         ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^ address: Value
   │         │                       
   │         Map<address, u256>: Storage { nonce: None }

note: 
   ┌─ uniswap.fe:88:9
   │
88 │         self.allowances[owner][spender] = value
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │         │                                  
   │         u256: Storage { nonce: None }
89 │         emit Approval(ctx, owner, spender, value)
   │                       ^^^  ^^^^^  ^^^^^^^  ^^^^^ u256: Value
   │                       │    │      │         
   │                       │    │      address: Value
   │                       │    address: Value
   │                       Context: Memory

note: 
   ┌─ uniswap.fe:89:9
   │
89 │         emit Approval(ctx, owner, spender, value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 8893313742751514912
   │
   = Event {
         name: "Approval",
         fields: [
             EventField {
                 name: "owner",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "spender",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
                 is_indexed: false,
             },
         ],
     }

note: 
   ┌─ uniswap.fe:91:5
   │  
91 │ ╭     fn _transfer(self, ctx: Context, from: address, to: address, value: u256):
92 │ │         self.balances[from] = self.balances[from] - value
93 │ │         self.balances[to] = self.balances[to] + value
94 │ │         emit Transfer(ctx, from, to, value)
   │ ╰───────────────────────────────────────────^ attributes hash: 10048024656457243946
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         ctx_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "ctx",
                 typ: Ok(
                     Struct(
                         Struct {
                             name: "Context",
                             field_count: 0,
                         },
                     ),
                 ),
             },
             FunctionParam {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Unit,
             ),
         ),
     }

note: 
   ┌─ uniswap.fe:92:9
   │
92 │         self.balances[from] = self.balances[from] - value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:92:9
   │
92 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^ ^^^^ address: Value
   │         │              
   │         Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ uniswap.fe:92:9
   │
92 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                      
   │         u256: Storage { nonce: None }

note: 
   ┌─ uniswap.fe:92:31
   │
92 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^ ^^^^ address: Value
   │                               │              
   │                               Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ uniswap.fe:92:31
   │
92 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                               │                      
   │                               u256: Storage { nonce: None } => Value

note: 
   ┌─ uniswap.fe:92:31
   │
92 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
93 │         self.balances[to] = self.balances[to] + value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:93:9
   │
93 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^ ^^ address: Value
   │         │              
   │         Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ uniswap.fe:93:9
   │
93 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                    
   │         u256: Storage { nonce: None }

note: 
   ┌─ uniswap.fe:93:29
   │
93 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^ ^^ address: Value
   │                             │              
   │                             Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ uniswap.fe:93:29
   │
93 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                             │                    
   │                             u256: Storage { nonce: None } => Value

note: 
   ┌─ uniswap.fe:93:29
   │
93 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
94 │         emit Transfer(ctx, from, to, value)
   │                       ^^^  ^^^^  ^^  ^^^^^ u256: Value
   │                       │    │     │    
   │                       │    │     address: Value
   │                       │    address: Value
   │                       Context: Memory

note: 
   ┌─ uniswap.fe:94:9
   │
94 │         emit Transfer(ctx, from, to, value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 5533489995250141934
   │
   = Event {
         name: "Transfer",
         fields: [
             EventField {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
                 is_indexed: false,
             },
         ],
     }

note: 
   ┌─ uniswap.fe:96:5
   │  
96 │ ╭     pub fn approve(self, ctx: Context, spender: address, value: u256) -> bool:
97 │ │         self._approve(ctx, ctx.msg_sender(), spender, value)
98 │ │         return true
   │ ╰───────────────────^ attributes hash: 15274000982762670572
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         ctx_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "ctx",
                 typ: Ok(
                     Struct(
                         Struct {
                             name: "Context",
                             field_count: 0,
                         },
                     ),
                 ),
             },
             FunctionParam {
                 name: "spender",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Bool,
             ),
         ),
     }

note: 
   ┌─ uniswap.fe:97:9
   │
97 │         self._approve(ctx, ctx.msg_sender(), spender, value)
   │         ^^^^          ^^^  ^^^ Context: Memory
   │         │             │     
   │         │             Context: Memory
   │         UniswapV2Pair: Value

note: 
   ┌─ uniswap.fe:97:28
   │
97 │         self._approve(ctx, ctx.msg_sender(), spender, value)
   │                            ^^^^^^^^^^^^^^^^  ^^^^^^^  ^^^^^ u256: Value
   │                            │                 │         
   │                            │                 address: Value
   │                            address: Value

note: 
   ┌─ uniswap.fe:97:9
   │
97 │         self._approve(ctx, ctx.msg_sender(), spender, value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
98 │         return true
   │                ^^^^ bool: Value

note: 
    ┌─ uniswap.fe:100:5
    │  
100 │ ╭     pub fn transfer(self, ctx: Context, to: address, value: u256) -> bool:
101 │ │         self._transfer(ctx, ctx.msg_sender(), to, value)
102 │ │         return true
    │ ╰───────────────────^ attributes hash: 13199048387464312392
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "value",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Bool,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:101:9
    │
101 │         self._transfer(ctx, ctx.msg_sender(), to, value)
    │         ^^^^           ^^^  ^^^ Context: Memory
    │         │              │     
    │         │              Context: Memory
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:101:29
    │
101 │         self._transfer(ctx, ctx.msg_sender(), to, value)
    │                             ^^^^^^^^^^^^^^^^  ^^  ^^^^^ u256: Value
    │                             │                 │    
    │                             │                 address: Value
    │                             address: Value

note: 
    ┌─ uniswap.fe:101:9
    │
101 │         self._transfer(ctx, ctx.msg_sender(), to, value)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
102 │         return true
    │                ^^^^ bool: Value

note: 
    ┌─ uniswap.fe:104:5
    │  
104 │ ╭     pub fn transferFrom(self, ctx: Context, from: address, to: address, value: u256) -> bool:
105 │ │         assert self.allowances[from][ctx.msg_sender()] >= value
106 │ │ 
107 │ │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
108 │ │         self._transfer(ctx, from, to, value)
109 │ │         return true
    │ ╰───────────────────^ attributes hash: 5815730021641750571
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "from",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "value",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Bool,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:105:16
    │
105 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:105:16
    │
105 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^^^^^^^^^^^^ ^^^^ address: Value
    │                │                
    │                Map<address, Map<address, u256>>: Storage { nonce: Some(1) }

note: 
    ┌─ uniswap.fe:105:16
    │
105 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^ ^^^ Context: Memory
    │                │                      
    │                Map<address, u256>: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:105:38
    │
105 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                                      ^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:105:16
    │
105 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^ u256: Value
    │                │                                           
    │                u256: Storage { nonce: None } => Value

note: 
    ┌─ uniswap.fe:105:16
    │
105 │         assert self.allowances[from][ctx.msg_sender()] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
106 │ 
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:107:9
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │         ^^^^^^^^^^^^^^^ ^^^^ address: Value
    │         │                
    │         Map<address, Map<address, u256>>: Storage { nonce: Some(1) }

note: 
    ┌─ uniswap.fe:107:9
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │         ^^^^^^^^^^^^^^^^^^^^^ ^^^ Context: Memory
    │         │                      
    │         Map<address, u256>: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:107:31
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                               ^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:107:9
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │         │                                          
    │         u256: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:107:51
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                   ^^^^^^^^^^^^^^^ ^^^^ address: Value
    │                                                   │                
    │                                                   Map<address, Map<address, u256>>: Storage { nonce: Some(1) }

note: 
    ┌─ uniswap.fe:107:51
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                   ^^^^^^^^^^^^^^^^^^^^^ ^^^ Context: Memory
    │                                                   │                      
    │                                                   Map<address, u256>: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:107:73
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                                         ^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:107:51
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
    │                                                   │                                          
    │                                                   u256: Storage { nonce: None } => Value

note: 
    ┌─ uniswap.fe:107:51
    │
107 │         self.allowances[from][ctx.msg_sender()] = self.allowances[from][ctx.msg_sender()] - value
    │                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
108 │         self._transfer(ctx, from, to, value)
    │         ^^^^           ^^^  ^^^^  ^^  ^^^^^ u256: Value
    │         │              │    │     │    
    │         │              │    │     address: Value
    │         │              │    address: Value
    │         │              Context: Memory
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:108:9
    │
108 │         self._transfer(ctx, from, to, value)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
109 │         return true
    │                ^^^^ bool: Value

note: 
    ┌─ uniswap.fe:111:5
    │  
111 │ ╭     pub fn balanceOf(self, account: address) -> u256:
112 │ │         return self.balances[account]
    │ ╰─────────────────────────────────────^ attributes hash: 3934661437648326967
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: None,
          params: [
              FunctionParam {
                  name: "account",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:112:16
    │
112 │         return self.balances[account]
    │                ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:112:16
    │
112 │         return self.balances[account]
    │                ^^^^^^^^^^^^^ ^^^^^^^ address: Value
    │                │              
    │                Map<address, u256>: Storage { nonce: Some(0) }

note: 
    ┌─ uniswap.fe:112:16
    │
112 │         return self.balances[account]
    │                ^^^^^^^^^^^^^^^^^^^^^^ u256: Storage { nonce: None } => Value

note: 
    ┌─ uniswap.fe:114:5
    │  
114 │ ╭     pub fn get_reserves(self) -> (u256, u256, u256):
115 │ │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │ ╰────────────────────────────────────────────────────────────────────────^ attributes hash: 3743538709625240197
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: None,
          params: [],
          return_type: Ok(
              Tuple(
                  Tuple {
                      items: [
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                      ],
                  },
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:115:17
    │
115 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                 ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:115:17
    │
115 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                 ^^^^^^^^^^^^^  ^^^^ UniswapV2Pair: Value
    │                 │               
    │                 u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ uniswap.fe:115:32
    │
115 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                                ^^^^^^^^^^^^^  ^^^^ UniswapV2Pair: Value
    │                                │               
    │                                u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ uniswap.fe:115:47
    │
115 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                                               ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(9) } => Value

note: 
    ┌─ uniswap.fe:115:16
    │
115 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (u256, u256, u256): Memory

note: 
    ┌─ uniswap.fe:118:5
    │  
118 │ ╭     pub fn initialize(self, ctx: Context, token0: address, token1: address):
119 │ │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
120 │ │         self.token0 = token0
121 │ │         self.token1 = token1
    │ ╰────────────────────────────^ attributes hash: 3314959592057453019
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "token0",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "token1",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:119:16
    │
119 │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
    │                ^^^ Context: Memory

note: 
    ┌─ uniswap.fe:119:16
    │
119 │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^    ^^^^ UniswapV2Pair: Value
    │                │                    
    │                address: Value

note: 
    ┌─ uniswap.fe:119:36
    │
119 │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
    │                                    ^^^^^^^^^^^^ address: Storage { nonce: Some(4) } => Value

note: 
    ┌─ uniswap.fe:119:16
    │
119 │         assert ctx.msg_sender() == self.factory, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>: Memory
    │                │                                  
    │                bool: Value
120 │         self.token0 = token0
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:120:9
    │
120 │         self.token0 = token0
    │         ^^^^^^^^^^^   ^^^^^^ address: Value
    │         │              
    │         address: Storage { nonce: Some(5) }
121 │         self.token1 = token1
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:121:9
    │
121 │         self.token1 = token1
    │         ^^^^^^^^^^^   ^^^^^^ address: Value
    │         │              
    │         address: Storage { nonce: Some(6) }

note: 
    ┌─ uniswap.fe:124:5
    │  
124 │ ╭     fn _update(self, ctx: Context, balance0: u256, balance1: u256, reserve0: u256, reserve1: u256):
125 │ │         # changed from u32s
126 │ │         let block_timestamp: u256 = ctx.block_timestamp() % 2**32
127 │ │         # TODO: reproduce desired overflow (https://github.com/ethereum/fe/issues/286)
    · │
136 │ │         self.block_timestamp_last = block_timestamp
137 │ │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
    │ ╰────────────────────────────────────────────────────────────────────────^ attributes hash: 17025925797500525970
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "balance0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "balance1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "reserve0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "reserve1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:126:30
    │
126 │         let block_timestamp: u256 = ctx.block_timestamp() % 2**32
    │                              ^^^^ u256
127 │         # TODO: reproduce desired overflow (https://github.com/ethereum/fe/issues/286)
128 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last # overflow is desired
    │                           ^^^^ u256

note: 
    ┌─ uniswap.fe:126:37
    │
126 │         let block_timestamp: u256 = ctx.block_timestamp() % 2**32
    │                                     ^^^ Context: Memory

note: 
    ┌─ uniswap.fe:126:37
    │
126 │         let block_timestamp: u256 = ctx.block_timestamp() % 2**32
    │                                     ^^^^^^^^^^^^^^^^^^^^^   ^  ^^ u256: Value
    │                                     │                       │   
    │                                     │                       u256: Value
    │                                     u256: Value

note: 
    ┌─ uniswap.fe:126:61
    │
126 │         let block_timestamp: u256 = ctx.block_timestamp() % 2**32
    │                                                             ^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:126:37
    │
126 │         let block_timestamp: u256 = ctx.block_timestamp() % 2**32
    │                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
127 │         # TODO: reproduce desired overflow (https://github.com/ethereum/fe/issues/286)
128 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last # overflow is desired
    │                                  ^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                                  │                  
    │                                  u256: Value

note: 
    ┌─ uniswap.fe:128:52
    │
128 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last # overflow is desired
    │                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(9) } => Value

note: 
    ┌─ uniswap.fe:128:34
    │
128 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last # overflow is desired
    │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
129 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │            ^^^^^^^^^^^^   ^ u256: Value
    │            │               
    │            u256: Value

note: 
    ┌─ uniswap.fe:129:12
    │
129 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │            ^^^^^^^^^^^^^^^^     ^^^^^^^^    ^ u256: Value
    │            │                    │            
    │            │                    u256: Value
    │            bool: Value

note: 
    ┌─ uniswap.fe:129:33
    │
129 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │                                 ^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:129:12
    │
129 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^    ^ u256: Value
    │            │                                      │            
    │            │                                      u256: Value
    │            bool: Value

note: 
    ┌─ uniswap.fe:129:51
    │
129 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │                                                   ^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:129:12
    │
129 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
130 │             # `*` never overflows, and + overflow is desired
131 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:131:13
    │
131 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │             │                              
    │             u256: Storage { nonce: Some(10) }

note: 
    ┌─ uniswap.fe:131:43
    │
131 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^   ^^^^^^^^ u256: Value
    │                                           │                              │           
    │                                           │                              u256: Value
    │                                           u256: Storage { nonce: Some(10) } => Value

note: 
    ┌─ uniswap.fe:131:73
    │
131 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                                                                         │                        
    │                                                                         u256: Value

note: 
    ┌─ uniswap.fe:131:73
    │
131 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:131:43
    │
131 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
132 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:132:13
    │
132 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │             │                              
    │             u256: Storage { nonce: Some(11) }

note: 
    ┌─ uniswap.fe:132:43
    │
132 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^   ^^^^^^^^ u256: Value
    │                                           │                              │           
    │                                           │                              u256: Value
    │                                           u256: Storage { nonce: Some(11) } => Value

note: 
    ┌─ uniswap.fe:132:73
    │
132 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                                                                         │                        
    │                                                                         u256: Value

note: 
    ┌─ uniswap.fe:132:73
    │
132 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:132:43
    │
132 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
133 │ 
134 │         self.reserve0 = balance0
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:134:9
    │
134 │         self.reserve0 = balance0
    │         ^^^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │         │                
    │         u256: Storage { nonce: Some(7) }
135 │         self.reserve1 = balance1
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:135:9
    │
135 │         self.reserve1 = balance1
    │         ^^^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │         │                
    │         u256: Storage { nonce: Some(8) }
136 │         self.block_timestamp_last = block_timestamp
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:136:9
    │
136 │         self.block_timestamp_last = block_timestamp
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^ u256: Value
    │         │                            
    │         u256: Storage { nonce: Some(9) }
137 │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
    │                   ^^^            ^^^^ UniswapV2Pair: Value
    │                   │               
    │                   Context: Memory

note: 
    ┌─ uniswap.fe:137:34
    │
137 │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
    │                                  ^^^^^^^^^^^^^            ^^^^ UniswapV2Pair: Value
    │                                  │                         
    │                                  u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ uniswap.fe:137:59
    │
137 │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
    │                                                           ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ uniswap.fe:137:9
    │
137 │         emit Sync(ctx, reserve0: self.reserve0, reserve1: self.reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 11491202868117077488
    │
    = Event {
          name: "Sync",
          fields: [
              EventField {
                  name: "reserve0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "reserve1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
          ],
      }

note: 
    ┌─ uniswap.fe:140:5
    │  
140 │ ╭     fn _mint_fee(self, ctx: Context, reserve0: u256, reserve1: u256) -> bool:
141 │ │         let fee_to: address = UniswapV2Factory(ctx, self.factory).fee_to()
142 │ │         let fee_on: bool = fee_to != address(0)
143 │ │         let k_last: u256 = self.k_last # gas savings
    · │
156 │ │ 
157 │ │         return fee_on
    │ ╰─────────────────────^ attributes hash: 6168697520626235838
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "reserve0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "reserve1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Bool,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:141:21
    │
141 │         let fee_to: address = UniswapV2Factory(ctx, self.factory).fee_to()
    │                     ^^^^^^^ address
142 │         let fee_on: bool = fee_to != address(0)
    │                     ^^^^ bool
143 │         let k_last: u256 = self.k_last # gas savings
    │                     ^^^^ u256
    ·
146 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                             ^^^^ u256
147 │                 let root_k_last: u256 = sqrt(k_last)
    │                                  ^^^^ u256
148 │                 if root_k > root_k_last:
149 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                    ^^^^ u256
150 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                      ^^^^ u256
151 │                     let liquidity: u256 = numerator / denominator
    │                                    ^^^^ u256

note: 
    ┌─ uniswap.fe:141:48
    │
141 │         let fee_to: address = UniswapV2Factory(ctx, self.factory).fee_to()
    │                                                ^^^  ^^^^ UniswapV2Pair: Value
    │                                                │     
    │                                                Context: Memory

note: 
    ┌─ uniswap.fe:141:53
    │
141 │         let fee_to: address = UniswapV2Factory(ctx, self.factory).fee_to()
    │                                                     ^^^^^^^^^^^^ address: Storage { nonce: Some(4) } => Value

note: 
    ┌─ uniswap.fe:141:31
    │
141 │         let fee_to: address = UniswapV2Factory(ctx, self.factory).fee_to()
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:141:31
    │
141 │         let fee_to: address = UniswapV2Factory(ctx, self.factory).fee_to()
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ address: Value
142 │         let fee_on: bool = fee_to != address(0)
    │                            ^^^^^^            ^ u256: Value
    │                            │                  
    │                            address: Value

note: 
    ┌─ uniswap.fe:142:38
    │
142 │         let fee_on: bool = fee_to != address(0)
    │                                      ^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:142:28
    │
142 │         let fee_on: bool = fee_to != address(0)
    │                            ^^^^^^^^^^^^^^^^^^^^ bool: Value
143 │         let k_last: u256 = self.k_last # gas savings
    │                            ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:143:28
    │
143 │         let k_last: u256 = self.k_last # gas savings
    │                            ^^^^^^^^^^^ u256: Storage { nonce: Some(12) } => Value
144 │         if fee_on:
    │            ^^^^^^ bool: Value
145 │             if k_last != 0:
    │                ^^^^^^    ^ u256: Value
    │                │          
    │                u256: Value

note: 
    ┌─ uniswap.fe:145:16
    │
145 │             if k_last != 0:
    │                ^^^^^^^^^^^ bool: Value
146 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                         ^^^^^^^^   ^^^^^^^^ u256: Value
    │                                         │           
    │                                         u256: Value

note: 
    ┌─ uniswap.fe:146:41
    │
146 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                         ^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:146:36
    │
146 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
147 │                 let root_k_last: u256 = sqrt(k_last)
    │                                              ^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:147:41
    │
147 │                 let root_k_last: u256 = sqrt(k_last)
    │                                         ^^^^^^^^^^^^ u256: Value
148 │                 if root_k > root_k_last:
    │                    ^^^^^^   ^^^^^^^^^^^ u256: Value
    │                    │         
    │                    u256: Value

note: 
    ┌─ uniswap.fe:148:20
    │
148 │                 if root_k > root_k_last:
    │                    ^^^^^^^^^^^^^^^^^^^^ bool: Value
149 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:149:43
    │
149 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^   ^^^^^^ u256: Value
    │                                           │                    
    │                                           u256: Storage { nonce: Some(2) } => Value

note: 
    ┌─ uniswap.fe:149:43
    │
149 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                           │                             
    │                                           u256: Value

note: 
    ┌─ uniswap.fe:149:43
    │
149 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
150 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^   ^ u256: Value
    │                                             │         
    │                                             u256: Value

note: 
    ┌─ uniswap.fe:150:45
    │
150 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                             │             
    │                                             u256: Value

note: 
    ┌─ uniswap.fe:150:45
    │
150 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
151 │                     let liquidity: u256 = numerator / denominator
    │                                           ^^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                           │            
    │                                           u256: Value

note: 
    ┌─ uniswap.fe:151:43
    │
151 │                     let liquidity: u256 = numerator / denominator
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
152 │                     if liquidity > 0:
    │                        ^^^^^^^^^   ^ u256: Value
    │                        │            
    │                        u256: Value

note: 
    ┌─ uniswap.fe:152:24
    │
152 │                     if liquidity > 0:
    │                        ^^^^^^^^^^^^^ bool: Value
153 │                         self._mint(ctx, fee_to, liquidity)
    │                         ^^^^       ^^^  ^^^^^^  ^^^^^^^^^ u256: Value
    │                         │          │    │        
    │                         │          │    address: Value
    │                         │          Context: Memory
    │                         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:153:25
    │
153 │                         self._mint(ctx, fee_to, liquidity)
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
154 │         elif k_last != 0:
    │              ^^^^^^    ^ u256: Value
    │              │          
    │              u256: Value

note: 
    ┌─ uniswap.fe:154:14
    │
154 │         elif k_last != 0:
    │              ^^^^^^^^^^^ bool: Value
155 │             self.k_last = 0
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:155:13
    │
155 │             self.k_last = 0
    │             ^^^^^^^^^^^   ^ u256: Value
    │             │              
    │             u256: Storage { nonce: Some(12) }
156 │ 
157 │         return fee_on
    │                ^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:160:5
    │  
160 │ ╭     pub fn mint(self, ctx: Context, to: address) -> u256:
161 │ │         let MINIMUM_LIQUIDITY: u256 = 1000
162 │ │         let reserve0: u256 = self.reserve0
163 │ │         let reserve1: u256 = self.reserve1
    · │
186 │ │         emit Mint(ctx, sender: ctx.msg_sender(), amount0, amount1)
187 │ │         return liquidity
    │ ╰────────────────────────^ attributes hash: 8211528275496689590
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:161:32
    │
161 │         let MINIMUM_LIQUIDITY: u256 = 1000
    │                                ^^^^ u256
162 │         let reserve0: u256 = self.reserve0
    │                       ^^^^ u256
163 │         let reserve1: u256 = self.reserve1
    │                       ^^^^ u256
164 │         let balance0: u256 = ERC20(ctx, self.token0).balanceOf(ctx.self_address())
    │                       ^^^^ u256
165 │         let balance1: u256 = ERC20(ctx, self.token1).balanceOf(ctx.self_address())
    │                       ^^^^ u256
166 │         let amount0: u256 = balance0 - self.reserve0
    │                      ^^^^ u256
167 │         let amount1: u256 = balance1 - self.reserve1
    │                      ^^^^ u256
168 │ 
169 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                     ^^^^ bool
170 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since totalSupply can update in _mintFee
    │                           ^^^^ u256
171 │         let liquidity: u256 = 0
    │                        ^^^^ u256

note: 
    ┌─ uniswap.fe:161:39
    │
161 │         let MINIMUM_LIQUIDITY: u256 = 1000
    │                                       ^^^^ u256: Value
162 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:162:30
    │
162 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value
163 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:163:30
    │
163 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value
164 │         let balance0: u256 = ERC20(ctx, self.token0).balanceOf(ctx.self_address())
    │                                    ^^^  ^^^^ UniswapV2Pair: Value
    │                                    │     
    │                                    Context: Memory

note: 
    ┌─ uniswap.fe:164:41
    │
164 │         let balance0: u256 = ERC20(ctx, self.token0).balanceOf(ctx.self_address())
    │                                         ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ uniswap.fe:164:30
    │
164 │         let balance0: u256 = ERC20(ctx, self.token0).balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^           ^^^ Context: Memory
    │                              │                                  
    │                              ERC20: Value

note: 
    ┌─ uniswap.fe:164:64
    │
164 │         let balance0: u256 = ERC20(ctx, self.token0).balanceOf(ctx.self_address())
    │                                                                ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:164:30
    │
164 │         let balance0: u256 = ERC20(ctx, self.token0).balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
165 │         let balance1: u256 = ERC20(ctx, self.token1).balanceOf(ctx.self_address())
    │                                    ^^^  ^^^^ UniswapV2Pair: Value
    │                                    │     
    │                                    Context: Memory

note: 
    ┌─ uniswap.fe:165:41
    │
165 │         let balance1: u256 = ERC20(ctx, self.token1).balanceOf(ctx.self_address())
    │                                         ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ uniswap.fe:165:30
    │
165 │         let balance1: u256 = ERC20(ctx, self.token1).balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^           ^^^ Context: Memory
    │                              │                                  
    │                              ERC20: Value

note: 
    ┌─ uniswap.fe:165:64
    │
165 │         let balance1: u256 = ERC20(ctx, self.token1).balanceOf(ctx.self_address())
    │                                                                ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:165:30
    │
165 │         let balance1: u256 = ERC20(ctx, self.token1).balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
166 │         let amount0: u256 = balance0 - self.reserve0
    │                             ^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                             │           
    │                             u256: Value

note: 
    ┌─ uniswap.fe:166:40
    │
166 │         let amount0: u256 = balance0 - self.reserve0
    │                                        ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ uniswap.fe:166:29
    │
166 │         let amount0: u256 = balance0 - self.reserve0
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
167 │         let amount1: u256 = balance1 - self.reserve1
    │                             ^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                             │           
    │                             u256: Value

note: 
    ┌─ uniswap.fe:167:40
    │
167 │         let amount1: u256 = balance1 - self.reserve1
    │                                        ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ uniswap.fe:167:29
    │
167 │         let amount1: u256 = balance1 - self.reserve1
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
168 │ 
169 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                            ^^^^           ^^^  ^^^^^^^^  ^^^^^^^^ u256: Value
    │                            │              │    │          
    │                            │              │    u256: Value
    │                            │              Context: Memory
    │                            UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:169:28
    │
169 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
170 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since totalSupply can update in _mintFee
    │                                  ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:170:34
    │
170 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since totalSupply can update in _mintFee
    │                                  ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(2) } => Value
171 │         let liquidity: u256 = 0
    │                               ^ u256: Value
172 │         if total_supply == 0:
    │            ^^^^^^^^^^^^    ^ u256: Value
    │            │                
    │            u256: Value

note: 
    ┌─ uniswap.fe:172:12
    │
172 │         if total_supply == 0:
    │            ^^^^^^^^^^^^^^^^^ bool: Value
173 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │             ^^^^^^^^^        ^^^^^^^   ^^^^^^^ u256: Value
    │             │                │          
    │             │                u256: Value
    │             u256: Value

note: 
    ┌─ uniswap.fe:173:30
    │
173 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                              ^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:173:25
    │
173 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                         ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^ u256: Value
    │                         │                          
    │                         u256: Value

note: 
    ┌─ uniswap.fe:173:25
    │
173 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
174 │             self._mint(ctx, address(0), MINIMUM_LIQUIDITY) # permanently lock the first MINIMUM_LIQUIDITY tokens
    │             ^^^^       ^^^          ^ u256: Value
    │             │          │             
    │             │          Context: Memory
    │             UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:174:29
    │
174 │             self._mint(ctx, address(0), MINIMUM_LIQUIDITY) # permanently lock the first MINIMUM_LIQUIDITY tokens
    │                             ^^^^^^^^^^  ^^^^^^^^^^^^^^^^^ u256: Value
    │                             │            
    │                             address: Value

note: 
    ┌─ uniswap.fe:174:13
    │
174 │             self._mint(ctx, address(0), MINIMUM_LIQUIDITY) # permanently lock the first MINIMUM_LIQUIDITY tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
175 │         else:
176 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │             ^^^^^^^^^        ^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │             │                │          
    │             │                u256: Value
    │             u256: Value

note: 
    ┌─ uniswap.fe:176:29
    │
176 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │                             │                           
    │                             u256: Value

note: 
    ┌─ uniswap.fe:176:29
    │
176 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                             │                                     │          
    │                             │                                     u256: Value
    │                             u256: Value

note: 
    ┌─ uniswap.fe:176:66
    │
176 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │                                                                  │                           
    │                                                                  u256: Value

note: 
    ┌─ uniswap.fe:176:66
    │
176 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:176:25
    │
176 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
177 │ 
178 │         assert liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED"
    │                ^^^^^^^^^   ^ u256: Value
    │                │            
    │                u256: Value

note: 
    ┌─ uniswap.fe:178:16
    │
178 │         assert liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED"
    │                ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<40>: Memory
    │                │               
    │                bool: Value
179 │ 
180 │         self._mint(ctx, to, liquidity)
    │         ^^^^       ^^^  ^^  ^^^^^^^^^ u256: Value
    │         │          │    │    
    │         │          │    address: Value
    │         │          Context: Memory
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:180:9
    │
180 │         self._mint(ctx, to, liquidity)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
181 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256: Value
    │         │            │    │         │         │          
    │         │            │    │         │         u256: Value
    │         │            │    │         u256: Value
    │         │            │    u256: Value
    │         │            Context: Memory
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:181:9
    │
181 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
182 │ 
183 │         if fee_on:
    │            ^^^^^^ bool: Value
184 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:184:13
    │
184 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │             ^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^^ u256: Value
    │             │             │           
    │             │             u256: Value
    │             u256: Storage { nonce: Some(12) }

note: 
    ┌─ uniswap.fe:184:27
    │
184 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │                           ^^^^^^^^^^^^^^^^^^^ u256: Value
185 │ 
186 │         emit Mint(ctx, sender: ctx.msg_sender(), amount0, amount1)
    │                   ^^^          ^^^ Context: Memory
    │                   │             
    │                   Context: Memory

note: 
    ┌─ uniswap.fe:186:32
    │
186 │         emit Mint(ctx, sender: ctx.msg_sender(), amount0, amount1)
    │                                ^^^^^^^^^^^^^^^^  ^^^^^^^  ^^^^^^^ u256: Value
    │                                │                 │         
    │                                │                 u256: Value
    │                                address: Value
187 │         return liquidity
    │                ^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:186:9
    │
186 │         emit Mint(ctx, sender: ctx.msg_sender(), amount0, amount1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 4243961805717991435
    │
    = Event {
          name: "Mint",
          fields: [
              EventField {
                  name: "sender",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "amount0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
          ],
      }

note: 
    ┌─ uniswap.fe:190:5
    │  
190 │ ╭     pub fn burn(self, ctx: Context, to: address) -> (u256, u256):
191 │ │         let reserve0: u256 = self.reserve0
192 │ │         let reserve1: u256 = self.reserve1
193 │ │         let token0: ERC20 = ERC20(ctx, self.token0)
    · │
215 │ │         emit Burn(ctx, sender: ctx.msg_sender(), amount0, amount1, to)
216 │ │         return (amount0, amount1)
    │ ╰─────────────────────────────────^ attributes hash: 6846356871376567296
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Tuple(
                  Tuple {
                      items: [
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                      ],
                  },
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:191:23
    │
191 │         let reserve0: u256 = self.reserve0
    │                       ^^^^ u256
192 │         let reserve1: u256 = self.reserve1
    │                       ^^^^ u256
193 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                     ^^^^^ ERC20
194 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                     ^^^^^ ERC20
195 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                       ^^^^ u256
196 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                       ^^^^ u256
197 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                        ^^^^ u256
198 │ 
199 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                     ^^^^ bool
200 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since total_supply can update in _mintFee
    │                           ^^^^ u256
201 │         let amount0: u256 = (liquidity * balance0) / total_supply # using balances ensures pro-rata distribution
    │                      ^^^^ u256
202 │         let amount1: u256 = (liquidity * balance1) / total_supply # using balances ensures pro-rata distribution
    │                      ^^^^ u256

note: 
    ┌─ uniswap.fe:191:30
    │
191 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:191:30
    │
191 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value
192 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:192:30
    │
192 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value
193 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                                   ^^^  ^^^^ UniswapV2Pair: Value
    │                                   │     
    │                                   Context: Memory

note: 
    ┌─ uniswap.fe:193:40
    │
193 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                                        ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ uniswap.fe:193:29
    │
193 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^ ERC20: Value
194 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                                   ^^^  ^^^^ UniswapV2Pair: Value
    │                                   │     
    │                                   Context: Memory

note: 
    ┌─ uniswap.fe:194:40
    │
194 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                                        ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ uniswap.fe:194:29
    │
194 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^ ERC20: Value
195 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                              ^^^^^^           ^^^ Context: Memory
    │                              │                 
    │                              ERC20: Value

note: 
    ┌─ uniswap.fe:195:47
    │
195 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                                               ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:195:30
    │
195 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
196 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                              ^^^^^^           ^^^ Context: Memory
    │                              │                 
    │                              ERC20: Value

note: 
    ┌─ uniswap.fe:196:47
    │
196 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                                               ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:196:30
    │
196 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
197 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                               ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:197:31
    │
197 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                               ^^^^^^^^^^^^^ ^^^ Context: Memory
    │                               │              
    │                               Map<address, u256>: Storage { nonce: Some(0) }

note: 
    ┌─ uniswap.fe:197:45
    │
197 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                                             ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:197:31
    │
197 │         let liquidity: u256 = self.balances[ctx.self_address()]
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Storage { nonce: None } => Value
198 │ 
199 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                            ^^^^           ^^^  ^^^^^^^^  ^^^^^^^^ u256: Value
    │                            │              │    │          
    │                            │              │    u256: Value
    │                            │              Context: Memory
    │                            UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:199:28
    │
199 │         let fee_on: bool = self._mint_fee(ctx, reserve0, reserve1)
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
200 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since total_supply can update in _mintFee
    │                                  ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:200:34
    │
200 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since total_supply can update in _mintFee
    │                                  ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(2) } => Value
201 │         let amount0: u256 = (liquidity * balance0) / total_supply # using balances ensures pro-rata distribution
    │                              ^^^^^^^^^   ^^^^^^^^ u256: Value
    │                              │            
    │                              u256: Value

note: 
    ┌─ uniswap.fe:201:29
    │
201 │         let amount0: u256 = (liquidity * balance0) / total_supply # using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                             │                         
    │                             u256: Value

note: 
    ┌─ uniswap.fe:201:29
    │
201 │         let amount0: u256 = (liquidity * balance0) / total_supply # using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
202 │         let amount1: u256 = (liquidity * balance1) / total_supply # using balances ensures pro-rata distribution
    │                              ^^^^^^^^^   ^^^^^^^^ u256: Value
    │                              │            
    │                              u256: Value

note: 
    ┌─ uniswap.fe:202:29
    │
202 │         let amount1: u256 = (liquidity * balance1) / total_supply # using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                             │                         
    │                             u256: Value

note: 
    ┌─ uniswap.fe:202:29
    │
202 │         let amount1: u256 = (liquidity * balance1) / total_supply # using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
203 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^   ^ u256: Value
    │                │          
    │                u256: Value

note: 
    ┌─ uniswap.fe:203:16
    │
203 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^^^^^     ^^^^^^^   ^ u256: Value
    │                │               │          
    │                │               u256: Value
    │                bool: Value

note: 
    ┌─ uniswap.fe:203:32
    │
203 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                                ^^^^^^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:203:16
    │
203 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<40>: Memory
    │                │                             
    │                bool: Value
204 │         self._burn(ctx, ctx.self_address(), liquidity)
    │         ^^^^       ^^^  ^^^ Context: Memory
    │         │          │     
    │         │          Context: Memory
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:204:25
    │
204 │         self._burn(ctx, ctx.self_address(), liquidity)
    │                         ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^ u256: Value
    │                         │                    
    │                         address: Value

note: 
    ┌─ uniswap.fe:204:9
    │
204 │         self._burn(ctx, ctx.self_address(), liquidity)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
205 │         token0.transfer(to, amount0)
    │         ^^^^^^          ^^  ^^^^^^^ u256: Value
    │         │               │    
    │         │               address: Value
    │         ERC20: Value

note: 
    ┌─ uniswap.fe:205:9
    │
205 │         token0.transfer(to, amount0)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
206 │         token1.transfer(to, amount1)
    │         ^^^^^^          ^^  ^^^^^^^ u256: Value
    │         │               │    
    │         │               address: Value
    │         ERC20: Value

note: 
    ┌─ uniswap.fe:206:9
    │
206 │         token1.transfer(to, amount1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
207 │         balance0 = token0.balanceOf(ctx.self_address())
    │         ^^^^^^^^   ^^^^^^           ^^^ Context: Memory
    │         │          │                 
    │         │          ERC20: Value
    │         u256: Value

note: 
    ┌─ uniswap.fe:207:37
    │
207 │         balance0 = token0.balanceOf(ctx.self_address())
    │                                     ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:207:20
    │
207 │         balance0 = token0.balanceOf(ctx.self_address())
    │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
208 │         balance1 = token1.balanceOf(ctx.self_address())
    │         ^^^^^^^^   ^^^^^^           ^^^ Context: Memory
    │         │          │                 
    │         │          ERC20: Value
    │         u256: Value

note: 
    ┌─ uniswap.fe:208:37
    │
208 │         balance1 = token1.balanceOf(ctx.self_address())
    │                                     ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:208:20
    │
208 │         balance1 = token1.balanceOf(ctx.self_address())
    │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
209 │ 
210 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256: Value
    │         │            │    │         │         │          
    │         │            │    │         │         u256: Value
    │         │            │    │         u256: Value
    │         │            │    u256: Value
    │         │            Context: Memory
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:210:9
    │
210 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
211 │ 
212 │         if fee_on:
    │            ^^^^^^ bool: Value
213 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:213:13
    │
213 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │             ^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^^ u256: Value
    │             │             │           
    │             │             u256: Value
    │             u256: Storage { nonce: Some(12) }

note: 
    ┌─ uniswap.fe:213:27
    │
213 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │                           ^^^^^^^^^^^^^^^^^^^ u256: Value
214 │ 
215 │         emit Burn(ctx, sender: ctx.msg_sender(), amount0, amount1, to)
    │                   ^^^          ^^^ Context: Memory
    │                   │             
    │                   Context: Memory

note: 
    ┌─ uniswap.fe:215:32
    │
215 │         emit Burn(ctx, sender: ctx.msg_sender(), amount0, amount1, to)
    │                                ^^^^^^^^^^^^^^^^  ^^^^^^^  ^^^^^^^  ^^ address: Value
    │                                │                 │        │         
    │                                │                 │        u256: Value
    │                                │                 u256: Value
    │                                address: Value
216 │         return (amount0, amount1)
    │                 ^^^^^^^  ^^^^^^^ u256: Value
    │                 │         
    │                 u256: Value

note: 
    ┌─ uniswap.fe:216:16
    │
216 │         return (amount0, amount1)
    │                ^^^^^^^^^^^^^^^^^^ (u256, u256): Memory

note: 
    ┌─ uniswap.fe:215:9
    │
215 │         emit Burn(ctx, sender: ctx.msg_sender(), amount0, amount1, to)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 10738919684795162003
    │
    = Event {
          name: "Burn",
          fields: [
              EventField {
                  name: "sender",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "amount0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
          ],
      }

note: 
    ┌─ uniswap.fe:221:5
    │  
221 │ ╭     pub fn swap(self, ctx: Context, amount0_out: u256, amount1_out: u256, to: address):
222 │ │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
223 │ │         let reserve0: u256 = self.reserve0
224 │ │         let reserve1: u256 = self.reserve1
    · │
254 │ │         self._update(ctx, balance0, balance1, reserve0, reserve1)
255 │ │         emit Swap(ctx, sender: ctx.msg_sender(), amount0_in, amount1_in, amount0_out, amount1_out, to)
    │ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────^ attributes hash: 8119592611084218706
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "amount0_out",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "amount1_out",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:223:23
    │
223 │         let reserve0: u256 = self.reserve0
    │                       ^^^^ u256
224 │         let reserve1: u256 = self.reserve1
    │                       ^^^^ u256
    ·
227 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                     ^^^^^ ERC20
228 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                     ^^^^^ ERC20
    ·
241 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                       ^^^^ u256
242 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                       ^^^^ u256
243 │ 
244 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                         ^^^^ u256
245 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                         ^^^^ u256
    ·
249 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                ^^^^ u256
250 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                ^^^^ u256

note: 
    ┌─ uniswap.fe:222:16
    │
222 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^   ^ u256: Value
    │                │              
    │                u256: Value

note: 
    ┌─ uniswap.fe:222:16
    │
222 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^    ^^^^^^^^^^^   ^ u256: Value
    │                │                  │              
    │                │                  u256: Value
    │                bool: Value

note: 
    ┌─ uniswap.fe:222:35
    │
222 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                                   ^^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:222:16
    │
222 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<37>: Memory
    │                │                                    
    │                bool: Value
223 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:223:30
    │
223 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value
224 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:224:30
    │
224 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value
225 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │                │              
    │                u256: Value

note: 
    ┌─ uniswap.fe:225:16
    │
225 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │                │                          │              
    │                │                          u256: Value
    │                bool: Value

note: 
    ┌─ uniswap.fe:225:43
    │
225 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                                           ^^^^^^^^^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:225:16
    │
225 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<33>: Memory
    │                │                                                   
    │                bool: Value
226 │ 
227 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                                   ^^^  ^^^^ UniswapV2Pair: Value
    │                                   │     
    │                                   Context: Memory

note: 
    ┌─ uniswap.fe:227:40
    │
227 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                                        ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ uniswap.fe:227:29
    │
227 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^ ERC20: Value
228 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                                   ^^^  ^^^^ UniswapV2Pair: Value
    │                                   │     
    │                                   Context: Memory

note: 
    ┌─ uniswap.fe:228:40
    │
228 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                                        ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ uniswap.fe:228:29
    │
228 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^ ERC20: Value
    ·
231 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^            ^^^^^^ ERC20: Value
    │                │              
    │                address: Value

note: 
    ┌─ uniswap.fe:231:22
    │
231 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                      ^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:231:16
    │
231 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^^^^^^^^^^^^^^^^^^^^     ^^            ^^^^^^ ERC20: Value
    │                │                         │              
    │                │                         address: Value
    │                bool: Value

note: 
    ┌─ uniswap.fe:231:48
    │
231 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                                                ^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:231:42
    │
231 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                                          ^^^^^^^^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:231:16
    │
231 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^ String<21>: Memory
    │                │                                                 
    │                bool: Value
232 │ 
233 │         if amount0_out > 0:
    │            ^^^^^^^^^^^   ^ u256: Value
    │            │              
    │            u256: Value

note: 
    ┌─ uniswap.fe:233:12
    │
233 │         if amount0_out > 0:
    │            ^^^^^^^^^^^^^^^ bool: Value
234 │             token0.transfer(to, amount0_out) # optimistically transfer tokens
    │             ^^^^^^          ^^  ^^^^^^^^^^^ u256: Value
    │             │               │    
    │             │               address: Value
    │             ERC20: Value

note: 
    ┌─ uniswap.fe:234:13
    │
234 │             token0.transfer(to, amount0_out) # optimistically transfer tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
235 │         if amount1_out > 0:
    │            ^^^^^^^^^^^   ^ u256: Value
    │            │              
    │            u256: Value

note: 
    ┌─ uniswap.fe:235:12
    │
235 │         if amount1_out > 0:
    │            ^^^^^^^^^^^^^^^ bool: Value
236 │             token1.transfer(to, amount1_out) # optimistically transfer tokens
    │             ^^^^^^          ^^  ^^^^^^^^^^^ u256: Value
    │             │               │    
    │             │               address: Value
    │             ERC20: Value

note: 
    ┌─ uniswap.fe:236:13
    │
236 │             token1.transfer(to, amount1_out) # optimistically transfer tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
    ·
241 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                              ^^^^^^           ^^^ Context: Memory
    │                              │                 
    │                              ERC20: Value

note: 
    ┌─ uniswap.fe:241:47
    │
241 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                                               ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:241:30
    │
241 │         let balance0: u256 = token0.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
242 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                              ^^^^^^           ^^^ Context: Memory
    │                              │                 
    │                              ERC20: Value

note: 
    ┌─ uniswap.fe:242:47
    │
242 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                                               ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:242:30
    │
242 │         let balance1: u256 = token1.balanceOf(ctx.self_address())
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
243 │ 
244 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                                                       ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                                                       │          │           
    │                                                                       │          u256: Value
    │                                                                       u256: Value

note: 
    ┌─ uniswap.fe:244:82
    │
244 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                                                                  ^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:244:32
    │
244 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
    │                                │                                       
    │                                u256: Value

note: 
    ┌─ uniswap.fe:244:44
    │
244 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                            ^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                            │           
    │                                            u256: Value

note: 
    ┌─ uniswap.fe:244:43
    │
244 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:244:32
    │
244 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                           ^ u256: Value
    │                                │                                                                              
    │                                u256: Value

note: 
    ┌─ uniswap.fe:244:32
    │
244 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
245 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                                                       ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                                                       │          │           
    │                                                                       │          u256: Value
    │                                                                       u256: Value

note: 
    ┌─ uniswap.fe:245:82
    │
245 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                                                                  ^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:245:32
    │
245 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
    │                                │                                       
    │                                u256: Value

note: 
    ┌─ uniswap.fe:245:44
    │
245 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                            ^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                            │           
    │                                            u256: Value

note: 
    ┌─ uniswap.fe:245:43
    │
245 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:245:32
    │
245 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                           ^ u256: Value
    │                                │                                                                              
    │                                u256: Value

note: 
    ┌─ uniswap.fe:245:32
    │
245 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
246 │ 
247 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^   ^ u256: Value
    │                │             
    │                u256: Value

note: 
    ┌─ uniswap.fe:247:16
    │
247 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^    ^^^^^^^^^^   ^ u256: Value
    │                │                 │             
    │                │                 u256: Value
    │                bool: Value

note: 
    ┌─ uniswap.fe:247:34
    │
247 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                                  ^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:247:16
    │
247 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<36>: Memory
    │                │                                  
    │                bool: Value
248 │ 
249 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^   ^^^^ u256: Value
    │                                       │           
    │                                       u256: Value

note: 
    ┌─ uniswap.fe:249:39
    │
249 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^^^^^^^^   ^^^^^^^^^^   ^ u256: Value
    │                                       │                 │             
    │                                       │                 u256: Value
    │                                       u256: Value

note: 
    ┌─ uniswap.fe:249:57
    │
249 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                                         ^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:249:39
    │
249 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
250 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^   ^^^^ u256: Value
    │                                       │           
    │                                       u256: Value

note: 
    ┌─ uniswap.fe:250:39
    │
250 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^^^^^^^^   ^^^^^^^^^^   ^ u256: Value
    │                                       │                 │             
    │                                       │                 u256: Value
    │                                       u256: Value

note: 
    ┌─ uniswap.fe:250:57
    │
250 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                                         ^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:250:39
    │
250 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
251 │ 
252 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^ u256: Value
    │                │                    
    │                u256: Value

note: 
    ┌─ uniswap.fe:252:16
    │
252 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^   ^^^^^^^^ u256: Value
    │                │                                        │           
    │                │                                        u256: Value
    │                u256: Value

note: 
    ┌─ uniswap.fe:252:57
    │
252 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                                                         ^^^^^^^^^^^^^^^^^^^   ^^^^^^^ u256: Value
    │                                                         │                      
    │                                                         u256: Value

note: 
    ┌─ uniswap.fe:252:57
    │
252 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:252:16
    │
252 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^ String<12>: Memory
    │                │                                                                        
    │                bool: Value
253 │ 
254 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256: Value
    │         │            │    │         │         │          
    │         │            │    │         │         u256: Value
    │         │            │    │         u256: Value
    │         │            │    u256: Value
    │         │            Context: Memory
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:254:9
    │
254 │         self._update(ctx, balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
255 │         emit Swap(ctx, sender: ctx.msg_sender(), amount0_in, amount1_in, amount0_out, amount1_out, to)
    │                   ^^^          ^^^ Context: Memory
    │                   │             
    │                   Context: Memory

note: 
    ┌─ uniswap.fe:255:32
    │
255 │         emit Swap(ctx, sender: ctx.msg_sender(), amount0_in, amount1_in, amount0_out, amount1_out, to)
    │                                ^^^^^^^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^  ^^ address: Value
    │                                │                 │           │           │            │             
    │                                │                 │           │           │            u256: Value
    │                                │                 │           │           u256: Value
    │                                │                 │           u256: Value
    │                                │                 u256: Value
    │                                address: Value

note: 
    ┌─ uniswap.fe:255:9
    │
255 │         emit Swap(ctx, sender: ctx.msg_sender(), amount0_in, amount1_in, amount0_out, amount1_out, to)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 16055667627771619025
    │
    = Event {
          name: "Swap",
          fields: [
              EventField {
                  name: "sender",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "amount0_in",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount1_in",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount0_out",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount1_out",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
          ],
      }

note: 
    ┌─ uniswap.fe:258:5
    │  
258 │ ╭     pub fn skim(self, ctx: Context, to: address):
259 │ │         let token0: ERC20 = ERC20(ctx, self.token0) # gas savings
260 │ │         let token1: ERC20 = ERC20(ctx, self.token1) # gas savings
261 │ │ 
262 │ │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
263 │ │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │ ╰─────────────────────────────────────────────────────────────────────────────────^ attributes hash: 15257920618683114493
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:259:21
    │
259 │         let token0: ERC20 = ERC20(ctx, self.token0) # gas savings
    │                     ^^^^^ ERC20
260 │         let token1: ERC20 = ERC20(ctx, self.token1) # gas savings
    │                     ^^^^^ ERC20

note: 
    ┌─ uniswap.fe:259:35
    │
259 │         let token0: ERC20 = ERC20(ctx, self.token0) # gas savings
    │                                   ^^^  ^^^^ UniswapV2Pair: Value
    │                                   │     
    │                                   Context: Memory

note: 
    ┌─ uniswap.fe:259:40
    │
259 │         let token0: ERC20 = ERC20(ctx, self.token0) # gas savings
    │                                        ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ uniswap.fe:259:29
    │
259 │         let token0: ERC20 = ERC20(ctx, self.token0) # gas savings
    │                             ^^^^^^^^^^^^^^^^^^^^^^^ ERC20: Value
260 │         let token1: ERC20 = ERC20(ctx, self.token1) # gas savings
    │                                   ^^^  ^^^^ UniswapV2Pair: Value
    │                                   │     
    │                                   Context: Memory

note: 
    ┌─ uniswap.fe:260:40
    │
260 │         let token1: ERC20 = ERC20(ctx, self.token1) # gas savings
    │                                        ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ uniswap.fe:260:29
    │
260 │         let token1: ERC20 = ERC20(ctx, self.token1) # gas savings
    │                             ^^^^^^^^^^^^^^^^^^^^^^^ ERC20: Value
261 │ 
262 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │         ^^^^^^          ^^  ^^^^^^           ^^^ Context: Memory
    │         │               │   │                 
    │         │               │   ERC20: Value
    │         │               address: Value
    │         ERC20: Value

note: 
    ┌─ uniswap.fe:262:46
    │
262 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │                                              ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:262:29
    │
262 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                             │                                       
    │                             u256: Value

note: 
    ┌─ uniswap.fe:262:68
    │
262 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │                                                                    ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ uniswap.fe:262:29
    │
262 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:262:9
    │
262 │         token0.transfer(to, token0.balanceOf(ctx.self_address()) - self.reserve0)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
263 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │         ^^^^^^          ^^  ^^^^^^           ^^^ Context: Memory
    │         │               │   │                 
    │         │               │   ERC20: Value
    │         │               address: Value
    │         ERC20: Value

note: 
    ┌─ uniswap.fe:263:46
    │
263 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │                                              ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:263:29
    │
263 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                             │                                       
    │                             u256: Value

note: 
    ┌─ uniswap.fe:263:68
    │
263 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │                                                                    ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ uniswap.fe:263:29
    │
263 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:263:9
    │
263 │         token1.transfer(to, token1.balanceOf(ctx.self_address()) - self.reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ uniswap.fe:266:5
    │  
266 │ ╭     pub fn sync(self, ctx: Context):
267 │ │         let token0: ERC20 = ERC20(ctx, self.token0)
268 │ │         let token1: ERC20 = ERC20(ctx, self.token1)
269 │ │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │ ╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────^ attributes hash: 5828909688388067108
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:267:21
    │
267 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                     ^^^^^ ERC20
268 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                     ^^^^^ ERC20

note: 
    ┌─ uniswap.fe:267:35
    │
267 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                                   ^^^  ^^^^ UniswapV2Pair: Value
    │                                   │     
    │                                   Context: Memory

note: 
    ┌─ uniswap.fe:267:40
    │
267 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                                        ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ uniswap.fe:267:29
    │
267 │         let token0: ERC20 = ERC20(ctx, self.token0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^ ERC20: Value
268 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                                   ^^^  ^^^^ UniswapV2Pair: Value
    │                                   │     
    │                                   Context: Memory

note: 
    ┌─ uniswap.fe:268:40
    │
268 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                                        ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ uniswap.fe:268:29
    │
268 │         let token1: ERC20 = ERC20(ctx, self.token1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^ ERC20: Value
269 │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │         ^^^^         ^^^  ^^^^^^           ^^^ Context: Memory
    │         │            │    │                 
    │         │            │    ERC20: Value
    │         │            Context: Memory
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:269:44
    │
269 │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │                                            ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:269:27
    │
269 │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^           ^^^ Context: Memory
    │                           │                                     │                 
    │                           │                                     ERC20: Value
    │                           u256: Value

note: 
    ┌─ uniswap.fe:269:82
    │
269 │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │                                                                                  ^^^^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:269:65
    │
269 │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^ UniswapV2Pair: Value
    │                                                                 │                                      
    │                                                                 u256: Value

note: 
    ┌─ uniswap.fe:269:103
    │
269 │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │                                                                                                       ^^^^^^^^^^^^^  ^^^^ UniswapV2Pair: Value
    │                                                                                                       │               
    │                                                                                                       u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ uniswap.fe:269:118
    │
269 │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │                                                                                                                      ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ uniswap.fe:269:9
    │
269 │         self._update(ctx, token0.balanceOf(ctx.self_address()), token1.balanceOf(ctx.self_address()), self.reserve0, self.reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value

note: 
    ┌─ uniswap.fe:271:5
    │  
271 │ ╭     fn sqrt(val: u256) -> u256:
272 │ │         let z: u256
273 │ │         if (val > 3):
274 │ │             z = val
    · │
280 │ │             z = 1
281 │ │         return z
    │ ╰────────────────^ attributes hash: 6692289661045278817
    │  
    = FunctionSignature {
          self_decl: None,
          ctx_decl: None,
          params: [
              FunctionParam {
                  name: "val",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:272:16
    │
272 │         let z: u256
    │                ^^^^ u256
    ·
275 │             let x: u256 = val / 2 + 1
    │                    ^^^^ u256

note: 
    ┌─ uniswap.fe:273:13
    │
273 │         if (val > 3):
    │             ^^^   ^ u256: Value
    │             │      
    │             u256: Value

note: 
    ┌─ uniswap.fe:273:12
    │
273 │         if (val > 3):
    │            ^^^^^^^^^ bool: Value
274 │             z = val
    │             ^   ^^^ u256: Value
    │             │    
    │             u256: Value
275 │             let x: u256 = val / 2 + 1
    │                           ^^^   ^ u256: Value
    │                           │      
    │                           u256: Value

note: 
    ┌─ uniswap.fe:275:27
    │
275 │             let x: u256 = val / 2 + 1
    │                           ^^^^^^^   ^ u256: Value
    │                           │          
    │                           u256: Value

note: 
    ┌─ uniswap.fe:275:27
    │
275 │             let x: u256 = val / 2 + 1
    │                           ^^^^^^^^^^^ u256: Value
276 │             while (x < z):
    │                    ^   ^ u256: Value
    │                    │    
    │                    u256: Value

note: 
    ┌─ uniswap.fe:276:19
    │
276 │             while (x < z):
    │                   ^^^^^^^ bool: Value
277 │                 z = x
    │                 ^   ^ u256: Value
    │                 │    
    │                 u256: Value
278 │                 x = (val / x + x) / 2
    │                 ^    ^^^   ^ u256: Value
    │                 │    │      
    │                 │    u256: Value
    │                 u256: Value

note: 
    ┌─ uniswap.fe:278:22
    │
278 │                 x = (val / x + x) / 2
    │                      ^^^^^^^   ^ u256: Value
    │                      │          
    │                      u256: Value

note: 
    ┌─ uniswap.fe:278:21
    │
278 │                 x = (val / x + x) / 2
    │                     ^^^^^^^^^^^^^   ^ u256: Value
    │                     │                
    │                     u256: Value

note: 
    ┌─ uniswap.fe:278:21
    │
278 │                 x = (val / x + x) / 2
    │                     ^^^^^^^^^^^^^^^^^ u256: Value
279 │         elif (val != 0):
    │               ^^^    ^ u256: Value
    │               │       
    │               u256: Value

note: 
    ┌─ uniswap.fe:279:14
    │
279 │         elif (val != 0):
    │              ^^^^^^^^^^ bool: Value
280 │             z = 1
    │             ^   ^ u256: Value
    │             │    
    │             u256: Value
281 │         return z
    │                ^ u256: Value

note: 
    ┌─ uniswap.fe:283:5
    │  
283 │ ╭     fn min(x: u256, y: u256) -> u256:
284 │ │         return x if x < y else y
    │ ╰────────────────────────────────^ attributes hash: 3620942230080591742
    │  
    = FunctionSignature {
          self_decl: None,
          ctx_decl: None,
          params: [
              FunctionParam {
                  name: "x",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "y",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:284:21
    │
284 │         return x if x < y else y
    │                     ^   ^ u256: Value
    │                     │    
    │                     u256: Value

note: 
    ┌─ uniswap.fe:284:16
    │
284 │         return x if x < y else y
    │                ^    ^^^^^      ^ u256: Value
    │                │    │           
    │                │    bool: Value
    │                u256: Value

note: 
    ┌─ uniswap.fe:284:16
    │
284 │         return x if x < y else y
    │                ^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ uniswap.fe:287:5
    │
287 │     fee_to: address
    │     ^^^^^^^^^^^^^^^ address
288 │     fee_to_setter: address
    │     ^^^^^^^^^^^^^^^^^^^^^^ address
289 │ 
290 │     pairs: Map<address, Map<address, address>>
    │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, Map<address, address>>
291 │ 
292 │     all_pairs: Array<address, 100>
    │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Array<address, 100>
293 │     pair_counter: u256
    │     ^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:296:9
    │
296 │         idx token0: address
    │         ^^^^^^^^^^^^^^^^^^^ address
297 │         idx token1: address
    │         ^^^^^^^^^^^^^^^^^^^ address
298 │         pair: address
    │         ^^^^^^^^^^^^^ address
299 │         index: u256
    │         ^^^^^^^^^^^ u256

note: 
    ┌─ uniswap.fe:304:5
    │  
304 │ ╭     pub fn fee_to(self) -> address:
305 │ │         return self.fee_to
    │ ╰──────────────────────────^ attributes hash: 227275695522088782
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: None,
          params: [],
          return_type: Ok(
              Base(
                  Address,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:305:16
    │
305 │         return self.fee_to
    │                ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:305:16
    │
305 │         return self.fee_to
    │                ^^^^^^^^^^^ address: Storage { nonce: Some(0) } => Value

note: 
    ┌─ uniswap.fe:307:5
    │  
307 │ ╭     pub fn fee_to_setter(self) -> address:
308 │ │         return self.fee_to_setter
    │ ╰─────────────────────────────────^ attributes hash: 227275695522088782
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: None,
          params: [],
          return_type: Ok(
              Base(
                  Address,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:308:16
    │
308 │         return self.fee_to_setter
    │                ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:308:16
    │
308 │         return self.fee_to_setter
    │                ^^^^^^^^^^^^^^^^^^ address: Storage { nonce: Some(1) } => Value

note: 
    ┌─ uniswap.fe:310:5
    │  
310 │ ╭     pub fn all_pairs_length(self) -> u256:
311 │ │         return self.pair_counter
    │ ╰────────────────────────────────^ attributes hash: 11773348765973600208
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: None,
          params: [],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:311:16
    │
311 │         return self.pair_counter
    │                ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:311:16
    │
311 │         return self.pair_counter
    │                ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(4) } => Value

note: 
    ┌─ uniswap.fe:313:5
    │  
313 │ ╭     pub fn create_pair(self, ctx: Context, token_a: address, token_b: address) -> address:
314 │ │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
315 │ │ 
316 │ │         let token0: address = token_a if token_a < token_b else token_b
    · │
330 │ │         emit PairCreated(ctx, token0, token1, pair: address(pair), index: self.pair_counter)
331 │ │         return address(pair)
    │ ╰────────────────────────────^ attributes hash: 4632903327058450706
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "token_a",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "token_b",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Address,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:316:21
    │
316 │         let token0: address = token_a if token_a < token_b else token_b
    │                     ^^^^^^^ address
317 │         let token1: address = token_a if token_a > token_b else token_b
    │                     ^^^^^^^ address
    ·
321 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                   ^^^^ u256
322 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(ctx, 0, salt)
    │                   ^^^^^^^^^^^^^ UniswapV2Pair

note: 
    ┌─ uniswap.fe:314:16
    │
314 │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
    │                ^^^^^^^    ^^^^^^^ address: Value
    │                │           
    │                address: Value

note: 
    ┌─ uniswap.fe:314:16
    │
314 │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
    │                ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<30>: Memory
    │                │                    
    │                bool: Value
315 │ 
316 │         let token0: address = token_a if token_a < token_b else token_b
    │                                          ^^^^^^^   ^^^^^^^ address: Value
    │                                          │          
    │                                          address: Value

note: 
    ┌─ uniswap.fe:316:31
    │
316 │         let token0: address = token_a if token_a < token_b else token_b
    │                               ^^^^^^^    ^^^^^^^^^^^^^^^^^      ^^^^^^^ address: Value
    │                               │          │                       
    │                               │          bool: Value
    │                               address: Value

note: 
    ┌─ uniswap.fe:316:31
    │
316 │         let token0: address = token_a if token_a < token_b else token_b
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ address: Value
317 │         let token1: address = token_a if token_a > token_b else token_b
    │                                          ^^^^^^^   ^^^^^^^ address: Value
    │                                          │          
    │                                          address: Value

note: 
    ┌─ uniswap.fe:317:31
    │
317 │         let token1: address = token_a if token_a > token_b else token_b
    │                               ^^^^^^^    ^^^^^^^^^^^^^^^^^      ^^^^^^^ address: Value
    │                               │          │                       
    │                               │          bool: Value
    │                               address: Value

note: 
    ┌─ uniswap.fe:317:31
    │
317 │         let token1: address = token_a if token_a > token_b else token_b
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ address: Value
318 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                ^^^^^^            ^ u256: Value
    │                │                  
    │                address: Value

note: 
    ┌─ uniswap.fe:318:26
    │
318 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                          ^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:318:16
    │
318 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^ String<23>: Memory
    │                │                      
    │                bool: Value
319 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:319:16
    │
319 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^ ^^^^^^ address: Value
    │                │           
    │                Map<address, Map<address, address>>: Storage { nonce: Some(2) }

note: 
    ┌─ uniswap.fe:319:16
    │
319 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^ ^^^^^^ address: Value
    │                │                   
    │                Map<address, address>: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:319:16
    │
319 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^            ^ u256: Value
    │                │                                      
    │                address: Storage { nonce: None } => Value

note: 
    ┌─ uniswap.fe:319:46
    │
319 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                                              ^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:319:16
    │
319 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^ String<22>: Memory
    │                │                                          
    │                bool: Value
320 │ 
321 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                     ^^^^^^  ^^^^^^ address: Value
    │                                     │        
    │                                     address: Value

note: 
    ┌─ uniswap.fe:321:36
    │
321 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                    ^^^^^^^^^^^^^^^^ (address, address): Memory

note: 
    ┌─ uniswap.fe:321:36
    │
321 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Array<u8, 64>: Memory

note: 
    ┌─ uniswap.fe:321:26
    │
321 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
322 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(ctx, 0, salt)
    │                                                         ^^^  ^  ^^^^ u256: Value
    │                                                         │    │   
    │                                                         │    u256: Value
    │                                                         Context: Memory

note: 
    ┌─ uniswap.fe:322:35
    │
322 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(ctx, 0, salt)
    │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UniswapV2Pair: Value
323 │         pair.initialize(token0, token1)
    │         ^^^^            ^^^^^^  ^^^^^^ address: Value
    │         │               │        
    │         │               address: Value
    │         UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:323:9
    │
323 │         pair.initialize(token0, token1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
324 │ 
325 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:325:9
    │
325 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^ ^^^^^^ address: Value
    │         │           
    │         Map<address, Map<address, address>>: Storage { nonce: Some(2) }

note: 
    ┌─ uniswap.fe:325:9
    │
325 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^ ^^^^^^ address: Value
    │         │                   
    │         Map<address, address>: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:325:9
    │
325 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │                                     
    │         address: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:325:38
    │
325 │         self.pairs[token0][token1] = address(pair)
    │                                      ^^^^^^^^^^^^^ address: Value
326 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:326:9
    │
326 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^ ^^^^^^ address: Value
    │         │           
    │         Map<address, Map<address, address>>: Storage { nonce: Some(2) }

note: 
    ┌─ uniswap.fe:326:9
    │
326 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^ ^^^^^^ address: Value
    │         │                   
    │         Map<address, address>: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:326:9
    │
326 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │                                     
    │         address: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:326:38
    │
326 │         self.pairs[token1][token0] = address(pair)
    │                                      ^^^^^^^^^^^^^ address: Value
327 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:327:9
    │
327 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^^^^^^^^^^^ ^^^^ UniswapV2Factory: Value
    │         │               
    │         Array<address, 100>: Storage { nonce: Some(3) }

note: 
    ┌─ uniswap.fe:327:24
    │
327 │         self.all_pairs[self.pair_counter] = address(pair)
    │                        ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(4) } => Value

note: 
    ┌─ uniswap.fe:327:9
    │
327 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │                                            
    │         address: Storage { nonce: None }

note: 
    ┌─ uniswap.fe:327:45
    │
327 │         self.all_pairs[self.pair_counter] = address(pair)
    │                                             ^^^^^^^^^^^^^ address: Value
328 │         self.pair_counter = self.pair_counter + 1
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:328:9
    │
328 │         self.pair_counter = self.pair_counter + 1
    │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Factory: Value
    │         │                    
    │         u256: Storage { nonce: Some(4) }

note: 
    ┌─ uniswap.fe:328:29
    │
328 │         self.pair_counter = self.pair_counter + 1
    │                             ^^^^^^^^^^^^^^^^^   ^ u256: Value
    │                             │                    
    │                             u256: Storage { nonce: Some(4) } => Value

note: 
    ┌─ uniswap.fe:328:29
    │
328 │         self.pair_counter = self.pair_counter + 1
    │                             ^^^^^^^^^^^^^^^^^^^^^ u256: Value
329 │ 
330 │         emit PairCreated(ctx, token0, token1, pair: address(pair), index: self.pair_counter)
    │                          ^^^  ^^^^^^  ^^^^^^                ^^^^ UniswapV2Pair: Value
    │                          │    │       │                      
    │                          │    │       address: Value
    │                          │    address: Value
    │                          Context: Memory

note: 
    ┌─ uniswap.fe:330:53
    │
330 │         emit PairCreated(ctx, token0, token1, pair: address(pair), index: self.pair_counter)
    │                                                     ^^^^^^^^^^^^^         ^^^^ UniswapV2Factory: Value
    │                                                     │                      
    │                                                     address: Value

note: 
    ┌─ uniswap.fe:330:75
    │
330 │         emit PairCreated(ctx, token0, token1, pair: address(pair), index: self.pair_counter)
    │                                                                           ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(4) } => Value
331 │         return address(pair)
    │                        ^^^^ UniswapV2Pair: Value

note: 
    ┌─ uniswap.fe:331:16
    │
331 │         return address(pair)
    │                ^^^^^^^^^^^^^ address: Value

note: 
    ┌─ uniswap.fe:330:9
    │
330 │         emit PairCreated(ctx, token0, token1, pair: address(pair), index: self.pair_counter)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 13094055123344570742
    │
    = Event {
          name: "PairCreated",
          fields: [
              EventField {
                  name: "token0",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "token1",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "pair",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "index",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
          ],
      }

note: 
    ┌─ uniswap.fe:333:5
    │  
333 │ ╭     pub fn set_fee_to(self, ctx: Context, fee_to: address):
334 │ │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
335 │ │         self.fee_to = fee_to
    │ ╰────────────────────────────^ attributes hash: 13077527319267994201
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "fee_to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:334:16
    │
334 │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^ Context: Memory

note: 
    ┌─ uniswap.fe:334:16
    │
334 │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^    ^^^^ UniswapV2Factory: Value
    │                │                    
    │                address: Value

note: 
    ┌─ uniswap.fe:334:36
    │
334 │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                                    ^^^^^^^^^^^^^^^^^^ address: Storage { nonce: Some(1) } => Value

note: 
    ┌─ uniswap.fe:334:16
    │
334 │         assert ctx.msg_sender() == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>: Memory
    │                │                                        
    │                bool: Value
335 │         self.fee_to = fee_to
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:335:9
    │
335 │         self.fee_to = fee_to
    │         ^^^^^^^^^^^   ^^^^^^ address: Value
    │         │              
    │         address: Storage { nonce: Some(0) }

note: 
    ┌─ uniswap.fe:337:5
    │  
337 │ ╭     pub fn set_fee_to_setter(self, ctx: Context, fee_to_setter: address):
338 │ │         assert ctx.msg_sender() == fee_to_setter, "UniswapV2: FORBIDDEN"
339 │ │         self.fee_to_setter = fee_to_setter
    │ ╰──────────────────────────────────────────^ attributes hash: 492104934844627339
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          ctx_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "ctx",
                  typ: Ok(
                      Struct(
                          Struct {
                              name: "Context",
                              field_count: 0,
                          },
                      ),
                  ),
              },
              FunctionParam {
                  name: "fee_to_setter",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ uniswap.fe:338:16
    │
338 │         assert ctx.msg_sender() == fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^ Context: Memory

note: 
    ┌─ uniswap.fe:338:16
    │
338 │         assert ctx.msg_sender() == fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^ address: Value
    │                │                    
    │                address: Value

note: 
    ┌─ uniswap.fe:338:16
    │
338 │         assert ctx.msg_sender() == fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>: Memory
    │                │                                   
    │                bool: Value
339 │         self.fee_to_setter = fee_to_setter
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ uniswap.fe:339:9
    │
339 │         self.fee_to_setter = fee_to_setter
    │         ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ address: Value
    │         │                     
    │         address: Storage { nonce: Some(1) }


