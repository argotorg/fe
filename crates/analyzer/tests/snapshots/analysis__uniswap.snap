---
source: crates/analyzer/tests/analysis.rs
expression: "build_snapshot(&files, module_id, &db)"

---
note: 
  ┌─ demos/uniswap.fe:2:5
  │  
2 │ ╭     pub fn balanceOf(account: address) -> u256:
3 │ │         return 0
  │ ╰────────────────^ attributes hash: 2140140122946032557
  │  
  = FunctionSignature {
        self_decl: None,
        params: [
            FunctionParam {
                name: "account",
                typ: Ok(
                    Base(
                        Address,
                    ),
                ),
            },
        ],
        return_type: Ok(
            Base(
                Numeric(
                    U256,
                ),
            ),
        ),
    }

note: 
  ┌─ demos/uniswap.fe:3:16
  │
3 │         return 0
  │                ^ u256: Value

note: 
  ┌─ demos/uniswap.fe:5:5
  │  
5 │ ╭     pub fn transfer(recipient: address, amount: u256) -> bool:
6 │ │         return false
  │ ╰────────────────────^ attributes hash: 8296406261133122468
  │  
  = FunctionSignature {
        self_decl: None,
        params: [
            FunctionParam {
                name: "recipient",
                typ: Ok(
                    Base(
                        Address,
                    ),
                ),
            },
            FunctionParam {
                name: "amount",
                typ: Ok(
                    Base(
                        Numeric(
                            U256,
                        ),
                    ),
                ),
            },
        ],
        return_type: Ok(
            Base(
                Bool,
            ),
        ),
    }

note: 
  ┌─ demos/uniswap.fe:6:16
  │
6 │         return false
  │                ^^^^^ bool: Value

note: 
   ┌─ demos/uniswap.fe:12:5
   │
12 │     balances: Map<address, u256>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, u256>
13 │     allowances: Map<address, Map<address, u256>>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, Map<address, u256>>
14 │     total_supply: u256
   │     ^^^^^^^^^^^^^^^^^^ u256
15 │ 
16 │     nonces: Map<address, u256>
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, u256>
17 │ 
18 │     factory: address
   │     ^^^^^^^^^^^^^^^^ address
19 │     token0: address
   │     ^^^^^^^^^^^^^^^ address
20 │     token1: address
   │     ^^^^^^^^^^^^^^^ address
21 │ 
22 │     reserve0: u256
   │     ^^^^^^^^^^^^^^ u256
23 │     reserve1: u256
   │     ^^^^^^^^^^^^^^ u256
24 │     block_timestamp_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
25 │ 
26 │     price0_cumulative_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
27 │     price1_cumulative_last: u256
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256
28 │     k_last: u256
   │     ^^^^^^^^^^^^ u256

note: 
   ┌─ demos/uniswap.fe:31:9
   │
31 │         idx owner: address
   │         ^^^^^^^^^^^^^^^^^^ address
32 │         idx spender: address
   │         ^^^^^^^^^^^^^^^^^^^^ address
33 │         value: u256
   │         ^^^^^^^^^^^ u256

note: 
   ┌─ demos/uniswap.fe:36:9
   │
36 │         idx from: address
   │         ^^^^^^^^^^^^^^^^^ address
37 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address
38 │         value: u256
   │         ^^^^^^^^^^^ u256

note: 
   ┌─ demos/uniswap.fe:41:9
   │
41 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
42 │         amount0: u256
   │         ^^^^^^^^^^^^^ u256
43 │         amount1: u256
   │         ^^^^^^^^^^^^^ u256

note: 
   ┌─ demos/uniswap.fe:46:9
   │
46 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
47 │         amount0: u256
   │         ^^^^^^^^^^^^^ u256
48 │         amount1: u256
   │         ^^^^^^^^^^^^^ u256
49 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address

note: 
   ┌─ demos/uniswap.fe:52:9
   │
52 │         idx sender: address
   │         ^^^^^^^^^^^^^^^^^^^ address
53 │         amount0_in: u256
   │         ^^^^^^^^^^^^^^^^ u256
54 │         amount1_in: u256
   │         ^^^^^^^^^^^^^^^^ u256
55 │         amount0_out: u256
   │         ^^^^^^^^^^^^^^^^^ u256
56 │         amount1_out: u256
   │         ^^^^^^^^^^^^^^^^^ u256
57 │         idx to: address
   │         ^^^^^^^^^^^^^^^ address

note: 
   ┌─ demos/uniswap.fe:60:9
   │
60 │         reserve0: u256
   │         ^^^^^^^^^^^^^^ u256
61 │         reserve1: u256
   │         ^^^^^^^^^^^^^^ u256

note: 
   ┌─ demos/uniswap.fe:66:5
   │  
66 │ ╭     pub fn factory(self) -> address:
67 │ │         return self.factory
   │ ╰───────────────────────────^ attributes hash: 10447292744135180405
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         params: [],
         return_type: Ok(
             Base(
                 Address,
             ),
         ),
     }

note: 
   ┌─ demos/uniswap.fe:67:16
   │
67 │         return self.factory
   │                ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:67:16
   │
67 │         return self.factory
   │                ^^^^^^^^^^^^ address: Storage { nonce: Some(4) } => Value

note: 
   ┌─ demos/uniswap.fe:69:5
   │  
69 │ ╭     pub fn token0(self) -> address:
70 │ │         return self.token0
   │ ╰──────────────────────────^ attributes hash: 10447292744135180405
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         params: [],
         return_type: Ok(
             Base(
                 Address,
             ),
         ),
     }

note: 
   ┌─ demos/uniswap.fe:70:16
   │
70 │         return self.token0
   │                ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:70:16
   │
70 │         return self.token0
   │                ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
   ┌─ demos/uniswap.fe:72:5
   │  
72 │ ╭     pub fn token1(self) -> address:
73 │ │         return self.token1
   │ ╰──────────────────────────^ attributes hash: 10447292744135180405
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         params: [],
         return_type: Ok(
             Base(
                 Address,
             ),
         ),
     }

note: 
   ┌─ demos/uniswap.fe:73:16
   │
73 │         return self.token1
   │                ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:73:16
   │
73 │         return self.token1
   │                ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
   ┌─ demos/uniswap.fe:75:5
   │  
75 │ ╭     fn _mint(self, to: address, value: u256):
76 │ │         self.total_supply = self.total_supply + value
77 │ │         self.balances[to] = self.balances[to] + value
78 │ │         emit Transfer(from=address(0), to, value)
   │ ╰─────────────────────────────────────────────────^ attributes hash: 12612842918375381504
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Unit,
             ),
         ),
     }

note: 
   ┌─ demos/uniswap.fe:76:9
   │
76 │         self.total_supply = self.total_supply + value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:76:9
   │
76 │         self.total_supply = self.total_supply + value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                    
   │         u256: Storage { nonce: Some(2) }

note: 
   ┌─ demos/uniswap.fe:76:29
   │
76 │         self.total_supply = self.total_supply + value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                             │                    
   │                             u256: Storage { nonce: Some(2) } => Value

note: 
   ┌─ demos/uniswap.fe:76:29
   │
76 │         self.total_supply = self.total_supply + value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
77 │         self.balances[to] = self.balances[to] + value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:77:9
   │
77 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^ ^^ address: Value
   │         │              
   │         Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ demos/uniswap.fe:77:9
   │
77 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                    
   │         u256: Storage { nonce: None }

note: 
   ┌─ demos/uniswap.fe:77:29
   │
77 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^ ^^ address: Value
   │                             │              
   │                             Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ demos/uniswap.fe:77:29
   │
77 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                             │                    
   │                             u256: Storage { nonce: None } => Value

note: 
   ┌─ demos/uniswap.fe:77:29
   │
77 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
78 │         emit Transfer(from=address(0), to, value)
   │                                    ^ u256: Value

note: 
   ┌─ demos/uniswap.fe:78:28
   │
78 │         emit Transfer(from=address(0), to, value)
   │                            ^^^^^^^^^^  ^^  ^^^^^ u256: Value
   │                            │           │    
   │                            │           address: Value
   │                            address: Value

note: 
   ┌─ demos/uniswap.fe:78:9
   │
78 │         emit Transfer(from=address(0), to, value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 5533489995250141934
   │
   = Event {
         name: "Transfer",
         fields: [
             EventField {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
                 is_indexed: false,
             },
         ],
     }

note: 
   ┌─ demos/uniswap.fe:78:28
   │
78 │         emit Transfer(from=address(0), to, value)
   │                            ^^^^^^^ TypeConstructor(Base(Address))

note: 
   ┌─ demos/uniswap.fe:80:5
   │  
80 │ ╭     fn _burn(self, from: address, value: u256):
81 │ │         self.balances[from] = self.balances[from] - value
82 │ │         self.total_supply = self.total_supply - value
83 │ │         emit Transfer(from, to=address(0), value)
   │ ╰─────────────────────────────────────────────────^ attributes hash: 1338340295882506748
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Unit,
             ),
         ),
     }

note: 
   ┌─ demos/uniswap.fe:81:9
   │
81 │         self.balances[from] = self.balances[from] - value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:81:9
   │
81 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^ ^^^^ address: Value
   │         │              
   │         Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ demos/uniswap.fe:81:9
   │
81 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                      
   │         u256: Storage { nonce: None }

note: 
   ┌─ demos/uniswap.fe:81:31
   │
81 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^ ^^^^ address: Value
   │                               │              
   │                               Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ demos/uniswap.fe:81:31
   │
81 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                               │                      
   │                               u256: Storage { nonce: None } => Value

note: 
   ┌─ demos/uniswap.fe:81:31
   │
81 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
82 │         self.total_supply = self.total_supply - value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:82:9
   │
82 │         self.total_supply = self.total_supply - value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                    
   │         u256: Storage { nonce: Some(2) }

note: 
   ┌─ demos/uniswap.fe:82:29
   │
82 │         self.total_supply = self.total_supply - value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                             │                    
   │                             u256: Storage { nonce: Some(2) } => Value

note: 
   ┌─ demos/uniswap.fe:82:29
   │
82 │         self.total_supply = self.total_supply - value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
83 │         emit Transfer(from, to=address(0), value)
   │                       ^^^^             ^ u256: Value
   │                       │                 
   │                       address: Value

note: 
   ┌─ demos/uniswap.fe:83:32
   │
83 │         emit Transfer(from, to=address(0), value)
   │                                ^^^^^^^^^^  ^^^^^ u256: Value
   │                                │            
   │                                address: Value

note: 
   ┌─ demos/uniswap.fe:83:9
   │
83 │         emit Transfer(from, to=address(0), value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 5533489995250141934
   │
   = Event {
         name: "Transfer",
         fields: [
             EventField {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
                 is_indexed: false,
             },
         ],
     }

note: 
   ┌─ demos/uniswap.fe:83:32
   │
83 │         emit Transfer(from, to=address(0), value)
   │                                ^^^^^^^ TypeConstructor(Base(Address))

note: 
   ┌─ demos/uniswap.fe:85:5
   │  
85 │ ╭     fn _approve(self, owner: address, spender: address, value: u256):
86 │ │         self.allowances[owner][spender] = value
87 │ │         emit Approval(owner, spender, value)
   │ ╰────────────────────────────────────────────^ attributes hash: 18402794614707408512
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "owner",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "spender",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Unit,
             ),
         ),
     }

note: 
   ┌─ demos/uniswap.fe:86:9
   │
86 │         self.allowances[owner][spender] = value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:86:9
   │
86 │         self.allowances[owner][spender] = value
   │         ^^^^^^^^^^^^^^^ ^^^^^ address: Value
   │         │                
   │         Map<address, Map<address, u256>>: Storage { nonce: Some(1) }

note: 
   ┌─ demos/uniswap.fe:86:9
   │
86 │         self.allowances[owner][spender] = value
   │         ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^ address: Value
   │         │                       
   │         Map<address, u256>: Storage { nonce: None }

note: 
   ┌─ demos/uniswap.fe:86:9
   │
86 │         self.allowances[owner][spender] = value
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │         │                                  
   │         u256: Storage { nonce: None }
87 │         emit Approval(owner, spender, value)
   │                       ^^^^^  ^^^^^^^  ^^^^^ u256: Value
   │                       │      │         
   │                       │      address: Value
   │                       address: Value

note: 
   ┌─ demos/uniswap.fe:87:9
   │
87 │         emit Approval(owner, spender, value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 8893313742751514912
   │
   = Event {
         name: "Approval",
         fields: [
             EventField {
                 name: "owner",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "spender",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
                 is_indexed: false,
             },
         ],
     }

note: 
   ┌─ demos/uniswap.fe:89:5
   │  
89 │ ╭     fn _transfer(self, from: address, to: address, value: u256):
90 │ │         self.balances[from] = self.balances[from] - value
91 │ │         self.balances[to] = self.balances[to] + value
92 │ │         emit Transfer(from, to, value)
   │ ╰──────────────────────────────────────^ attributes hash: 10286209570728537585
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Unit,
             ),
         ),
     }

note: 
   ┌─ demos/uniswap.fe:90:9
   │
90 │         self.balances[from] = self.balances[from] - value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:90:9
   │
90 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^ ^^^^ address: Value
   │         │              
   │         Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ demos/uniswap.fe:90:9
   │
90 │         self.balances[from] = self.balances[from] - value
   │         ^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                      
   │         u256: Storage { nonce: None }

note: 
   ┌─ demos/uniswap.fe:90:31
   │
90 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^ ^^^^ address: Value
   │                               │              
   │                               Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ demos/uniswap.fe:90:31
   │
90 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                               │                      
   │                               u256: Storage { nonce: None } => Value

note: 
   ┌─ demos/uniswap.fe:90:31
   │
90 │         self.balances[from] = self.balances[from] - value
   │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
91 │         self.balances[to] = self.balances[to] + value
   │         ^^^^ UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:91:9
   │
91 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^ ^^ address: Value
   │         │              
   │         Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ demos/uniswap.fe:91:9
   │
91 │         self.balances[to] = self.balances[to] + value
   │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
   │         │                    
   │         u256: Storage { nonce: None }

note: 
   ┌─ demos/uniswap.fe:91:29
   │
91 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^ ^^ address: Value
   │                             │              
   │                             Map<address, u256>: Storage { nonce: Some(0) }

note: 
   ┌─ demos/uniswap.fe:91:29
   │
91 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
   │                             │                    
   │                             u256: Storage { nonce: None } => Value

note: 
   ┌─ demos/uniswap.fe:91:29
   │
91 │         self.balances[to] = self.balances[to] + value
   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
92 │         emit Transfer(from, to, value)
   │                       ^^^^  ^^  ^^^^^ u256: Value
   │                       │     │    
   │                       │     address: Value
   │                       address: Value

note: 
   ┌─ demos/uniswap.fe:92:9
   │
92 │         emit Transfer(from, to, value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 5533489995250141934
   │
   = Event {
         name: "Transfer",
         fields: [
             EventField {
                 name: "from",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "to",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
                 is_indexed: true,
             },
             EventField {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
                 is_indexed: false,
             },
         ],
     }

note: 
   ┌─ demos/uniswap.fe:94:5
   │  
94 │ ╭     pub fn approve(self, spender: address, value: u256) -> bool:
95 │ │         self._approve(msg.sender, spender, value)
96 │ │         return true
   │ ╰───────────────────^ attributes hash: 844763422390851240
   │  
   = FunctionSignature {
         self_decl: Some(
             Mutable,
         ),
         params: [
             FunctionParam {
                 name: "spender",
                 typ: Ok(
                     Base(
                         Address,
                     ),
                 ),
             },
             FunctionParam {
                 name: "value",
                 typ: Ok(
                     Base(
                         Numeric(
                             U256,
                         ),
                     ),
                 ),
             },
         ],
         return_type: Ok(
             Base(
                 Bool,
             ),
         ),
     }

note: 
   ┌─ demos/uniswap.fe:95:9
   │
95 │         self._approve(msg.sender, spender, value)
   │         ^^^^          ^^^^^^^^^^  ^^^^^^^  ^^^^^ u256: Value
   │         │             │           │         
   │         │             │           address: Value
   │         │             address: Value
   │         UniswapV2Pair: Value

note: 
   ┌─ demos/uniswap.fe:95:9
   │
95 │         self._approve(msg.sender, spender, value)
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
96 │         return true
   │                ^^^^ bool: Value

note: 
   ┌─ demos/uniswap.fe:95:9
   │
95 │         self._approve(msg.sender, spender, value)
   │         ^^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(8) }

note: 
    ┌─ demos/uniswap.fe:98:5
    │  
 98 │ ╭     pub fn transfer(self, to: address, value: u256) -> bool:
 99 │ │         self._transfer(msg.sender, to, value)
100 │ │         return true
    │ ╰───────────────────^ attributes hash: 2643035404557072522
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "value",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Bool,
              ),
          ),
      }

note: 
   ┌─ demos/uniswap.fe:99:9
   │
99 │         self._transfer(msg.sender, to, value)
   │         ^^^^           ^^^^^^^^^^  ^^  ^^^^^ u256: Value
   │         │              │           │    
   │         │              │           address: Value
   │         │              address: Value
   │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:99:9
    │
 99 │         self._transfer(msg.sender, to, value)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
100 │         return true
    │                ^^^^ bool: Value

note: 
   ┌─ demos/uniswap.fe:99:9
   │
99 │         self._transfer(msg.sender, to, value)
   │         ^^^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(9) }

note: 
    ┌─ demos/uniswap.fe:102:5
    │  
102 │ ╭     pub fn transferFrom(self, from: address, to: address, value: u256) -> bool:
103 │ │         assert self.allowances[from][msg.sender] >= value
104 │ │ 
105 │ │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
106 │ │         self._transfer(from, to, value)
107 │ │         return true
    │ ╰───────────────────^ attributes hash: 9819594473760969007
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "from",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "value",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Bool,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:103:16
    │
103 │         assert self.allowances[from][msg.sender] >= value
    │                ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:103:16
    │
103 │         assert self.allowances[from][msg.sender] >= value
    │                ^^^^^^^^^^^^^^^ ^^^^ address: Value
    │                │                
    │                Map<address, Map<address, u256>>: Storage { nonce: Some(1) }

note: 
    ┌─ demos/uniswap.fe:103:16
    │
103 │         assert self.allowances[from][msg.sender] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^ address: Value
    │                │                      
    │                Map<address, u256>: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:103:16
    │
103 │         assert self.allowances[from][msg.sender] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^ u256: Value
    │                │                                     
    │                u256: Storage { nonce: None } => Value

note: 
    ┌─ demos/uniswap.fe:103:16
    │
103 │         assert self.allowances[from][msg.sender] >= value
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
104 │ 
105 │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:105:9
    │
105 │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
    │         ^^^^^^^^^^^^^^^ ^^^^ address: Value
    │         │                
    │         Map<address, Map<address, u256>>: Storage { nonce: Some(1) }

note: 
    ┌─ demos/uniswap.fe:105:9
    │
105 │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
    │         ^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^ address: Value
    │         │                      
    │         Map<address, u256>: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:105:9
    │
105 │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │         │                                    
    │         u256: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:105:45
    │
105 │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
    │                                             ^^^^^^^^^^^^^^^ ^^^^ address: Value
    │                                             │                
    │                                             Map<address, Map<address, u256>>: Storage { nonce: Some(1) }

note: 
    ┌─ demos/uniswap.fe:105:45
    │
105 │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
    │                                             ^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^ address: Value
    │                                             │                      
    │                                             Map<address, u256>: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:105:45
    │
105 │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
    │                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^ u256: Value
    │                                             │                                    
    │                                             u256: Storage { nonce: None } => Value

note: 
    ┌─ demos/uniswap.fe:105:45
    │
105 │         self.allowances[from][msg.sender] = self.allowances[from][msg.sender] - value
    │                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
106 │         self._transfer(from, to, value)
    │         ^^^^           ^^^^  ^^  ^^^^^ u256: Value
    │         │              │     │    
    │         │              │     address: Value
    │         │              address: Value
    │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:106:9
    │
106 │         self._transfer(from, to, value)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
107 │         return true
    │                ^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:106:9
    │
106 │         self._transfer(from, to, value)
    │         ^^^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(9) }

note: 
    ┌─ demos/uniswap.fe:109:5
    │  
109 │ ╭     pub fn balanceOf(self, account: address) -> u256:
110 │ │         return self.balances[account]
    │ ╰─────────────────────────────────────^ attributes hash: 993550877953897347
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "account",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:110:16
    │
110 │         return self.balances[account]
    │                ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:110:16
    │
110 │         return self.balances[account]
    │                ^^^^^^^^^^^^^ ^^^^^^^ address: Value
    │                │              
    │                Map<address, u256>: Storage { nonce: Some(0) }

note: 
    ┌─ demos/uniswap.fe:110:16
    │
110 │         return self.balances[account]
    │                ^^^^^^^^^^^^^^^^^^^^^^ u256: Storage { nonce: None } => Value

note: 
    ┌─ demos/uniswap.fe:112:5
    │  
112 │ ╭     pub fn get_reserves(self) -> (u256, u256, u256):
113 │ │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │ ╰────────────────────────────────────────────────────────────────────────^ attributes hash: 9520366806068670781
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [],
          return_type: Ok(
              Tuple(
                  Tuple {
                      items: [
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                      ],
                  },
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:113:17
    │
113 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                 ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:113:17
    │
113 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                 ^^^^^^^^^^^^^  ^^^^ UniswapV2Pair: Value
    │                 │               
    │                 u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ demos/uniswap.fe:113:32
    │
113 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                                ^^^^^^^^^^^^^  ^^^^ UniswapV2Pair: Value
    │                                │               
    │                                u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ demos/uniswap.fe:113:47
    │
113 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                                               ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(9) } => Value

note: 
    ┌─ demos/uniswap.fe:113:16
    │
113 │         return (self.reserve0, self.reserve1, self.block_timestamp_last)
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (u256, u256, u256): Memory

note: 
    ┌─ demos/uniswap.fe:116:5
    │  
116 │ ╭     pub fn initialize(self, token0: address, token1: address):
117 │ │         assert msg.sender == self.factory, "UniswapV2: FORBIDDEN"
118 │ │         self.token0 = token0
119 │ │         self.token1 = token1
    │ ╰────────────────────────────^ attributes hash: 10764996905806361023
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "token0",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "token1",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:117:16
    │
117 │         assert msg.sender == self.factory, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^    ^^^^ UniswapV2Pair: Value
    │                │              
    │                address: Value

note: 
    ┌─ demos/uniswap.fe:117:30
    │
117 │         assert msg.sender == self.factory, "UniswapV2: FORBIDDEN"
    │                              ^^^^^^^^^^^^ address: Storage { nonce: Some(4) } => Value

note: 
    ┌─ demos/uniswap.fe:117:16
    │
117 │         assert msg.sender == self.factory, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>: Memory
    │                │                            
    │                bool: Value
118 │         self.token0 = token0
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:118:9
    │
118 │         self.token0 = token0
    │         ^^^^^^^^^^^   ^^^^^^ address: Value
    │         │              
    │         address: Storage { nonce: Some(5) }
119 │         self.token1 = token1
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:119:9
    │
119 │         self.token1 = token1
    │         ^^^^^^^^^^^   ^^^^^^ address: Value
    │         │              
    │         address: Storage { nonce: Some(6) }

note: 
    ┌─ demos/uniswap.fe:122:5
    │  
122 │ ╭     fn _update(self, balance0: u256, balance1: u256, reserve0: u256, reserve1: u256):
123 │ │         # changed from u32s
124 │ │         let block_timestamp: u256 = block.timestamp % 2**32
125 │ │         # TODO: reproduce desired overflow (https://github.com/ethereum/fe/issues/286)
    · │
134 │ │         self.block_timestamp_last = block_timestamp
135 │ │         emit Sync(reserve0=self.reserve0, reserve1=self.reserve1)
    │ ╰─────────────────────────────────────────────────────────────────^ attributes hash: 15880403329314631128
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "balance0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "balance1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "reserve0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "reserve1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:124:30
    │
124 │         let block_timestamp: u256 = block.timestamp % 2**32
    │                              ^^^^ u256
125 │         # TODO: reproduce desired overflow (https://github.com/ethereum/fe/issues/286)
126 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last # overflow is desired
    │                           ^^^^ u256

note: 
    ┌─ demos/uniswap.fe:124:37
    │
124 │         let block_timestamp: u256 = block.timestamp % 2**32
    │                                     ^^^^^^^^^^^^^^^   ^  ^^ u256: Value
    │                                     │                 │   
    │                                     │                 u256: Value
    │                                     u256: Value

note: 
    ┌─ demos/uniswap.fe:124:55
    │
124 │         let block_timestamp: u256 = block.timestamp % 2**32
    │                                                       ^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:124:37
    │
124 │         let block_timestamp: u256 = block.timestamp % 2**32
    │                                     ^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
125 │         # TODO: reproduce desired overflow (https://github.com/ethereum/fe/issues/286)
126 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last # overflow is desired
    │                                  ^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                                  │                  
    │                                  u256: Value

note: 
    ┌─ demos/uniswap.fe:126:52
    │
126 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last # overflow is desired
    │                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(9) } => Value

note: 
    ┌─ demos/uniswap.fe:126:34
    │
126 │         let time_elapsed: u256 = block_timestamp - self.block_timestamp_last # overflow is desired
    │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
127 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │            ^^^^^^^^^^^^   ^ u256: Value
    │            │               
    │            u256: Value

note: 
    ┌─ demos/uniswap.fe:127:12
    │
127 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │            ^^^^^^^^^^^^^^^^     ^^^^^^^^    ^ u256: Value
    │            │                    │            
    │            │                    u256: Value
    │            bool: Value

note: 
    ┌─ demos/uniswap.fe:127:33
    │
127 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │                                 ^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:127:12
    │
127 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^    ^ u256: Value
    │            │                                      │            
    │            │                                      u256: Value
    │            bool: Value

note: 
    ┌─ demos/uniswap.fe:127:51
    │
127 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │                                                   ^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:127:12
    │
127 │         if time_elapsed > 0 and reserve0 != 0 and reserve1 != 0:
    │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
128 │             # `*` never overflows, and + overflow is desired
129 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:129:13
    │
129 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │             │                              
    │             u256: Storage { nonce: Some(10) }

note: 
    ┌─ demos/uniswap.fe:129:43
    │
129 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^   ^^^^^^^^ u256: Value
    │                                           │                              │           
    │                                           │                              u256: Value
    │                                           u256: Storage { nonce: Some(10) } => Value

note: 
    ┌─ demos/uniswap.fe:129:73
    │
129 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                                                                         │                        
    │                                                                         u256: Value

note: 
    ┌─ demos/uniswap.fe:129:73
    │
129 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:129:43
    │
129 │             self.price0_cumulative_last = self.price0_cumulative_last + (reserve1 / reserve0) * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
130 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:130:13
    │
130 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │             │                              
    │             u256: Storage { nonce: Some(11) }

note: 
    ┌─ demos/uniswap.fe:130:43
    │
130 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^   ^^^^^^^^ u256: Value
    │                                           │                              │           
    │                                           │                              u256: Value
    │                                           u256: Storage { nonce: Some(11) } => Value

note: 
    ┌─ demos/uniswap.fe:130:73
    │
130 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                                                                         │                        
    │                                                                         u256: Value

note: 
    ┌─ demos/uniswap.fe:130:73
    │
130 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:130:43
    │
130 │             self.price1_cumulative_last = self.price1_cumulative_last + (reserve0 / reserve1) * time_elapsed
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
131 │ 
132 │         self.reserve0 = balance0
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:132:9
    │
132 │         self.reserve0 = balance0
    │         ^^^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │         │                
    │         u256: Storage { nonce: Some(7) }
133 │         self.reserve1 = balance1
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:133:9
    │
133 │         self.reserve1 = balance1
    │         ^^^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │         │                
    │         u256: Storage { nonce: Some(8) }
134 │         self.block_timestamp_last = block_timestamp
    │         ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:134:9
    │
134 │         self.block_timestamp_last = block_timestamp
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^ u256: Value
    │         │                            
    │         u256: Storage { nonce: Some(9) }
135 │         emit Sync(reserve0=self.reserve0, reserve1=self.reserve1)
    │                            ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:135:28
    │
135 │         emit Sync(reserve0=self.reserve0, reserve1=self.reserve1)
    │                            ^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │                            │                        
    │                            u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ demos/uniswap.fe:135:52
    │
135 │         emit Sync(reserve0=self.reserve0, reserve1=self.reserve1)
    │                                                    ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ demos/uniswap.fe:135:9
    │
135 │         emit Sync(reserve0=self.reserve0, reserve1=self.reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 11491202868117077488
    │
    = Event {
          name: "Sync",
          fields: [
              EventField {
                  name: "reserve0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "reserve1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
          ],
      }

note: 
    ┌─ demos/uniswap.fe:138:5
    │  
138 │ ╭     fn _mint_fee(self, reserve0: u256, reserve1: u256) -> bool:
139 │ │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
140 │ │         let fee_on: bool = fee_to != address(0)
141 │ │         let k_last: u256 = self.k_last # gas savings
    · │
154 │ │ 
155 │ │         return fee_on
    │ ╰─────────────────────^ attributes hash: 1326723887586965558
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "reserve0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "reserve1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Bool,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:139:21
    │
139 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                     ^^^^^^^ address
140 │         let fee_on: bool = fee_to != address(0)
    │                     ^^^^ bool
141 │         let k_last: u256 = self.k_last # gas savings
    │                     ^^^^ u256
    ·
144 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                             ^^^^ u256
145 │                 let root_k_last: u256 = sqrt(k_last)
    │                                  ^^^^ u256
146 │                 if root_k > root_k_last:
147 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                    ^^^^ u256
148 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                      ^^^^ u256
149 │                     let liquidity: u256 = numerator / denominator
    │                                    ^^^^ u256

note: 
    ┌─ demos/uniswap.fe:139:48
    │
139 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                                                ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:139:48
    │
139 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                                                ^^^^^^^^^^^^ address: Storage { nonce: Some(4) } => Value

note: 
    ┌─ demos/uniswap.fe:139:31
    │
139 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:139:31
    │
139 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ address: Value
140 │         let fee_on: bool = fee_to != address(0)
    │                            ^^^^^^            ^ u256: Value
    │                            │                  
    │                            address: Value

note: 
    ┌─ demos/uniswap.fe:140:38
    │
140 │         let fee_on: bool = fee_to != address(0)
    │                                      ^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:140:28
    │
140 │         let fee_on: bool = fee_to != address(0)
    │                            ^^^^^^^^^^^^^^^^^^^^ bool: Value
141 │         let k_last: u256 = self.k_last # gas savings
    │                            ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:141:28
    │
141 │         let k_last: u256 = self.k_last # gas savings
    │                            ^^^^^^^^^^^ u256: Storage { nonce: Some(12) } => Value
142 │         if fee_on:
    │            ^^^^^^ bool: Value
143 │             if k_last != 0:
    │                ^^^^^^    ^ u256: Value
    │                │          
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:143:16
    │
143 │             if k_last != 0:
    │                ^^^^^^^^^^^ bool: Value
144 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                         ^^^^^^^^   ^^^^^^^^ u256: Value
    │                                         │           
    │                                         u256: Value

note: 
    ┌─ demos/uniswap.fe:144:41
    │
144 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                         ^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:144:36
    │
144 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
145 │                 let root_k_last: u256 = sqrt(k_last)
    │                                              ^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:145:41
    │
145 │                 let root_k_last: u256 = sqrt(k_last)
    │                                         ^^^^^^^^^^^^ u256: Value
146 │                 if root_k > root_k_last:
    │                    ^^^^^^   ^^^^^^^^^^^ u256: Value
    │                    │         
    │                    u256: Value

note: 
    ┌─ demos/uniswap.fe:146:20
    │
146 │                 if root_k > root_k_last:
    │                    ^^^^^^^^^^^^^^^^^^^^ bool: Value
147 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:147:43
    │
147 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^   ^^^^^^ u256: Value
    │                                           │                    
    │                                           u256: Storage { nonce: Some(2) } => Value

note: 
    ┌─ demos/uniswap.fe:147:43
    │
147 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                           │                             
    │                                           u256: Value

note: 
    ┌─ demos/uniswap.fe:147:43
    │
147 │                     let numerator: u256 = self.total_supply * root_k - root_k_last
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
148 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^   ^ u256: Value
    │                                             │         
    │                                             u256: Value

note: 
    ┌─ demos/uniswap.fe:148:45
    │
148 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                             │             
    │                                             u256: Value

note: 
    ┌─ demos/uniswap.fe:148:45
    │
148 │                     let denominator: u256 = root_k * 5 + root_k_last
    │                                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
149 │                     let liquidity: u256 = numerator / denominator
    │                                           ^^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                           │            
    │                                           u256: Value

note: 
    ┌─ demos/uniswap.fe:149:43
    │
149 │                     let liquidity: u256 = numerator / denominator
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
150 │                     if liquidity > 0:
    │                        ^^^^^^^^^   ^ u256: Value
    │                        │            
    │                        u256: Value

note: 
    ┌─ demos/uniswap.fe:150:24
    │
150 │                     if liquidity > 0:
    │                        ^^^^^^^^^^^^^ bool: Value
151 │                         self._mint(fee_to, liquidity)
    │                         ^^^^       ^^^^^^  ^^^^^^^^^ u256: Value
    │                         │          │        
    │                         │          address: Value
    │                         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:151:25
    │
151 │                         self._mint(fee_to, liquidity)
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
152 │         elif k_last != 0:
    │              ^^^^^^    ^ u256: Value
    │              │          
    │              u256: Value

note: 
    ┌─ demos/uniswap.fe:152:14
    │
152 │         elif k_last != 0:
    │              ^^^^^^^^^^^ bool: Value
153 │             self.k_last = 0
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:153:13
    │
153 │             self.k_last = 0
    │             ^^^^^^^^^^^   ^ u256: Value
    │             │              
    │             u256: Storage { nonce: Some(12) }
154 │ 
155 │         return fee_on
    │                ^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:139:31
    │
139 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                               ^^^^^^^^^^^^^^^^ TypeConstructor(Contract(Contract { name: "UniswapV2Factory", id: ContractId(2) }))

note: 
    ┌─ demos/uniswap.fe:139:31
    │
139 │         let fee_to: address = UniswapV2Factory(self.factory).fee_to()
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ External { contract: ContractId(2), function: FunctionId(26) }
140 │         let fee_on: bool = fee_to != address(0)
    │                                      ^^^^^^^ TypeConstructor(Base(Address))
    ·
144 │                 let root_k: u256 = sqrt(reserve0 * reserve1)
    │                                    ^^^^ Pure(FunctionId(23))
145 │                 let root_k_last: u256 = sqrt(k_last)
    │                                         ^^^^ Pure(FunctionId(23))
    ·
151 │                         self._mint(fee_to, liquidity)
    │                         ^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(6) }

note: 
    ┌─ demos/uniswap.fe:158:5
    │  
158 │ ╭     pub fn mint(self, to: address) -> u256:
159 │ │         let MINIMUM_LIQUIDITY: u256 = 1000
160 │ │         let reserve0: u256 = self.reserve0
161 │ │         let reserve1: u256 = self.reserve1
    · │
184 │ │         emit Mint(sender=msg.sender, amount0, amount1)
185 │ │         return liquidity
    │ ╰────────────────────────^ attributes hash: 11001367211577482977
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:159:32
    │
159 │         let MINIMUM_LIQUIDITY: u256 = 1000
    │                                ^^^^ u256
160 │         let reserve0: u256 = self.reserve0
    │                       ^^^^ u256
161 │         let reserve1: u256 = self.reserve1
    │                       ^^^^ u256
162 │         let balance0: u256 = ERC20(self.token0).balanceOf(self.address)
    │                       ^^^^ u256
163 │         let balance1: u256 = ERC20(self.token1).balanceOf(self.address)
    │                       ^^^^ u256
164 │         let amount0: u256 = balance0 - self.reserve0
    │                      ^^^^ u256
165 │         let amount1: u256 = balance1 - self.reserve1
    │                      ^^^^ u256
166 │ 
167 │         let fee_on: bool = self._mint_fee(reserve0, reserve1)
    │                     ^^^^ bool
168 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since totalSupply can update in _mintFee
    │                           ^^^^ u256
169 │         let liquidity: u256 = 0
    │                        ^^^^ u256

note: 
    ┌─ demos/uniswap.fe:159:39
    │
159 │         let MINIMUM_LIQUIDITY: u256 = 1000
    │                                       ^^^^ u256: Value
160 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:160:30
    │
160 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value
161 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:161:30
    │
161 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value
162 │         let balance0: u256 = ERC20(self.token0).balanceOf(self.address)
    │                                    ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:162:36
    │
162 │         let balance0: u256 = ERC20(self.token0).balanceOf(self.address)
    │                                    ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ demos/uniswap.fe:162:30
    │
162 │         let balance0: u256 = ERC20(self.token0).balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │                              │                             
    │                              ERC20: Value

note: 
    ┌─ demos/uniswap.fe:162:59
    │
162 │         let balance0: u256 = ERC20(self.token0).balanceOf(self.address)
    │                                                           ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:162:30
    │
162 │         let balance0: u256 = ERC20(self.token0).balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
163 │         let balance1: u256 = ERC20(self.token1).balanceOf(self.address)
    │                                    ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:163:36
    │
163 │         let balance1: u256 = ERC20(self.token1).balanceOf(self.address)
    │                                    ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ demos/uniswap.fe:163:30
    │
163 │         let balance1: u256 = ERC20(self.token1).balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │                              │                             
    │                              ERC20: Value

note: 
    ┌─ demos/uniswap.fe:163:59
    │
163 │         let balance1: u256 = ERC20(self.token1).balanceOf(self.address)
    │                                                           ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:163:30
    │
163 │         let balance1: u256 = ERC20(self.token1).balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
164 │         let amount0: u256 = balance0 - self.reserve0
    │                             ^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                             │           
    │                             u256: Value

note: 
    ┌─ demos/uniswap.fe:164:40
    │
164 │         let amount0: u256 = balance0 - self.reserve0
    │                                        ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ demos/uniswap.fe:164:29
    │
164 │         let amount0: u256 = balance0 - self.reserve0
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
165 │         let amount1: u256 = balance1 - self.reserve1
    │                             ^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                             │           
    │                             u256: Value

note: 
    ┌─ demos/uniswap.fe:165:40
    │
165 │         let amount1: u256 = balance1 - self.reserve1
    │                                        ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ demos/uniswap.fe:165:29
    │
165 │         let amount1: u256 = balance1 - self.reserve1
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
166 │ 
167 │         let fee_on: bool = self._mint_fee(reserve0, reserve1)
    │                            ^^^^           ^^^^^^^^  ^^^^^^^^ u256: Value
    │                            │              │          
    │                            │              u256: Value
    │                            UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:167:28
    │
167 │         let fee_on: bool = self._mint_fee(reserve0, reserve1)
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
168 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since totalSupply can update in _mintFee
    │                                  ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:168:34
    │
168 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since totalSupply can update in _mintFee
    │                                  ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(2) } => Value
169 │         let liquidity: u256 = 0
    │                               ^ u256: Value
170 │         if total_supply == 0:
    │            ^^^^^^^^^^^^    ^ u256: Value
    │            │                
    │            u256: Value

note: 
    ┌─ demos/uniswap.fe:170:12
    │
170 │         if total_supply == 0:
    │            ^^^^^^^^^^^^^^^^^ bool: Value
171 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │             ^^^^^^^^^        ^^^^^^^   ^^^^^^^ u256: Value
    │             │                │          
    │             │                u256: Value
    │             u256: Value

note: 
    ┌─ demos/uniswap.fe:171:30
    │
171 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                              ^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:171:25
    │
171 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                         ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^ u256: Value
    │                         │                          
    │                         u256: Value

note: 
    ┌─ demos/uniswap.fe:171:25
    │
171 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
172 │             self._mint(address(0), MINIMUM_LIQUIDITY) # permanently lock the first MINIMUM_LIQUIDITY tokens
    │             ^^^^               ^ u256: Value
    │             │                   
    │             UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:172:24
    │
172 │             self._mint(address(0), MINIMUM_LIQUIDITY) # permanently lock the first MINIMUM_LIQUIDITY tokens
    │                        ^^^^^^^^^^  ^^^^^^^^^^^^^^^^^ u256: Value
    │                        │            
    │                        address: Value

note: 
    ┌─ demos/uniswap.fe:172:13
    │
172 │             self._mint(address(0), MINIMUM_LIQUIDITY) # permanently lock the first MINIMUM_LIQUIDITY tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
173 │         else:
174 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │             ^^^^^^^^^        ^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │             │                │          
    │             │                u256: Value
    │             u256: Value

note: 
    ┌─ demos/uniswap.fe:174:29
    │
174 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │                             │                           
    │                             u256: Value

note: 
    ┌─ demos/uniswap.fe:174:29
    │
174 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                             │                                     │          
    │                             │                                     u256: Value
    │                             u256: Value

note: 
    ┌─ demos/uniswap.fe:174:66
    │
174 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │                                                                  │                           
    │                                                                  u256: Value

note: 
    ┌─ demos/uniswap.fe:174:66
    │
174 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:174:25
    │
174 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
175 │ 
176 │         assert liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED"
    │                ^^^^^^^^^   ^ u256: Value
    │                │            
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:176:16
    │
176 │         assert liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED"
    │                ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<40>: Memory
    │                │               
    │                bool: Value
177 │ 
178 │         self._mint(to, liquidity)
    │         ^^^^       ^^  ^^^^^^^^^ u256: Value
    │         │          │    
    │         │          address: Value
    │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:178:9
    │
178 │         self._mint(to, liquidity)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
179 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256: Value
    │         │            │         │         │          
    │         │            │         │         u256: Value
    │         │            │         u256: Value
    │         │            u256: Value
    │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:179:9
    │
179 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
180 │ 
181 │         if fee_on:
    │            ^^^^^^ bool: Value
182 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:182:13
    │
182 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │             ^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^^ u256: Value
    │             │             │           
    │             │             u256: Value
    │             u256: Storage { nonce: Some(12) }

note: 
    ┌─ demos/uniswap.fe:182:27
    │
182 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │                           ^^^^^^^^^^^^^^^^^^^ u256: Value
183 │ 
184 │         emit Mint(sender=msg.sender, amount0, amount1)
    │                          ^^^^^^^^^^  ^^^^^^^  ^^^^^^^ u256: Value
    │                          │           │         
    │                          │           u256: Value
    │                          address: Value
185 │         return liquidity
    │                ^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:184:9
    │
184 │         emit Mint(sender=msg.sender, amount0, amount1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 4243961805717991435
    │
    = Event {
          name: "Mint",
          fields: [
              EventField {
                  name: "sender",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "amount0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
          ],
      }

note: 
    ┌─ demos/uniswap.fe:162:30
    │
162 │         let balance0: u256 = ERC20(self.token0).balanceOf(self.address)
    │                              ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))

note: 
    ┌─ demos/uniswap.fe:162:30
    │
162 │         let balance0: u256 = ERC20(self.token0).balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
163 │         let balance1: u256 = ERC20(self.token1).balanceOf(self.address)
    │                              ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))

note: 
    ┌─ demos/uniswap.fe:163:30
    │
163 │         let balance1: u256 = ERC20(self.token1).balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
    ·
167 │         let fee_on: bool = self._mint_fee(reserve0, reserve1)
    │                            ^^^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(17) }
    ·
171 │             liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY
    │                         ^^^^ Pure(FunctionId(23))
172 │             self._mint(address(0), MINIMUM_LIQUIDITY) # permanently lock the first MINIMUM_LIQUIDITY tokens
    │                        ^^^^^^^ TypeConstructor(Base(Address))

note: 
    ┌─ demos/uniswap.fe:172:13
    │
172 │             self._mint(address(0), MINIMUM_LIQUIDITY) # permanently lock the first MINIMUM_LIQUIDITY tokens
    │             ^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(6) }
173 │         else:
174 │             liquidity = min((amount0 * total_supply) / reserve0, (amount1 * total_supply) / reserve1)
    │                         ^^^ Pure(FunctionId(24))
    ·
178 │         self._mint(to, liquidity)
    │         ^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(6) }
179 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(16) }

note: 
    ┌─ demos/uniswap.fe:188:5
    │  
188 │ ╭     pub fn burn(self, to: address) -> (u256, u256):
189 │ │         let reserve0: u256 = self.reserve0
190 │ │         let reserve1: u256 = self.reserve1
191 │ │         let token0: ERC20 = ERC20(self.token0)
    · │
213 │ │         emit Burn(sender=msg.sender, amount0, amount1, to)
214 │ │         return (amount0, amount1)
    │ ╰─────────────────────────────────^ attributes hash: 2815259610692259424
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Tuple(
                  Tuple {
                      items: [
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                          Base(
                              Numeric(
                                  U256,
                              ),
                          ),
                      ],
                  },
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:189:23
    │
189 │         let reserve0: u256 = self.reserve0
    │                       ^^^^ u256
190 │         let reserve1: u256 = self.reserve1
    │                       ^^^^ u256
191 │         let token0: ERC20 = ERC20(self.token0)
    │                     ^^^^^ ERC20
192 │         let token1: ERC20 = ERC20(self.token1)
    │                     ^^^^^ ERC20
193 │         let balance0: u256 = token0.balanceOf(self.address)
    │                       ^^^^ u256
194 │         let balance1: u256 = token1.balanceOf(self.address)
    │                       ^^^^ u256
195 │         let liquidity: u256 = self.balances[self.address]
    │                        ^^^^ u256
196 │ 
197 │         let fee_on: bool = self._mint_fee(reserve0, reserve1)
    │                     ^^^^ bool
198 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since total_supply can update in _mintFee
    │                           ^^^^ u256
199 │         let amount0: u256 = (liquidity * balance0) / total_supply # using balances ensures pro-rata distribution
    │                      ^^^^ u256
200 │         let amount1: u256 = (liquidity * balance1) / total_supply # using balances ensures pro-rata distribution
    │                      ^^^^ u256

note: 
    ┌─ demos/uniswap.fe:189:30
    │
189 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:189:30
    │
189 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value
190 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:190:30
    │
190 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value
191 │         let token0: ERC20 = ERC20(self.token0)
    │                                   ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:191:35
    │
191 │         let token0: ERC20 = ERC20(self.token0)
    │                                   ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ demos/uniswap.fe:191:29
    │
191 │         let token0: ERC20 = ERC20(self.token0)
    │                             ^^^^^^^^^^^^^^^^^^ ERC20: Value
192 │         let token1: ERC20 = ERC20(self.token1)
    │                                   ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:192:35
    │
192 │         let token1: ERC20 = ERC20(self.token1)
    │                                   ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ demos/uniswap.fe:192:29
    │
192 │         let token1: ERC20 = ERC20(self.token1)
    │                             ^^^^^^^^^^^^^^^^^^ ERC20: Value
193 │         let balance0: u256 = token0.balanceOf(self.address)
    │                              ^^^^^^           ^^^^ UniswapV2Pair: Value
    │                              │                 
    │                              ERC20: Value

note: 
    ┌─ demos/uniswap.fe:193:47
    │
193 │         let balance0: u256 = token0.balanceOf(self.address)
    │                                               ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:193:30
    │
193 │         let balance0: u256 = token0.balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
194 │         let balance1: u256 = token1.balanceOf(self.address)
    │                              ^^^^^^           ^^^^ UniswapV2Pair: Value
    │                              │                 
    │                              ERC20: Value

note: 
    ┌─ demos/uniswap.fe:194:47
    │
194 │         let balance1: u256 = token1.balanceOf(self.address)
    │                                               ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:194:30
    │
194 │         let balance1: u256 = token1.balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
195 │         let liquidity: u256 = self.balances[self.address]
    │                               ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:195:31
    │
195 │         let liquidity: u256 = self.balances[self.address]
    │                               ^^^^^^^^^^^^^ ^^^^ UniswapV2Pair: Value
    │                               │              
    │                               Map<address, u256>: Storage { nonce: Some(0) }

note: 
    ┌─ demos/uniswap.fe:195:45
    │
195 │         let liquidity: u256 = self.balances[self.address]
    │                                             ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:195:31
    │
195 │         let liquidity: u256 = self.balances[self.address]
    │                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Storage { nonce: None } => Value
196 │ 
197 │         let fee_on: bool = self._mint_fee(reserve0, reserve1)
    │                            ^^^^           ^^^^^^^^  ^^^^^^^^ u256: Value
    │                            │              │          
    │                            │              u256: Value
    │                            UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:197:28
    │
197 │         let fee_on: bool = self._mint_fee(reserve0, reserve1)
    │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
198 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since total_supply can update in _mintFee
    │                                  ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:198:34
    │
198 │         let total_supply: u256 = self.total_supply # gas savings, must be defined here since total_supply can update in _mintFee
    │                                  ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(2) } => Value
199 │         let amount0: u256 = (liquidity * balance0) / total_supply # using balances ensures pro-rata distribution
    │                              ^^^^^^^^^   ^^^^^^^^ u256: Value
    │                              │            
    │                              u256: Value

note: 
    ┌─ demos/uniswap.fe:199:29
    │
199 │         let amount0: u256 = (liquidity * balance0) / total_supply # using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                             │                         
    │                             u256: Value

note: 
    ┌─ demos/uniswap.fe:199:29
    │
199 │         let amount0: u256 = (liquidity * balance0) / total_supply # using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
200 │         let amount1: u256 = (liquidity * balance1) / total_supply # using balances ensures pro-rata distribution
    │                              ^^^^^^^^^   ^^^^^^^^ u256: Value
    │                              │            
    │                              u256: Value

note: 
    ┌─ demos/uniswap.fe:200:29
    │
200 │         let amount1: u256 = (liquidity * balance1) / total_supply # using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^ u256: Value
    │                             │                         
    │                             u256: Value

note: 
    ┌─ demos/uniswap.fe:200:29
    │
200 │         let amount1: u256 = (liquidity * balance1) / total_supply # using balances ensures pro-rata distribution
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
201 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^   ^ u256: Value
    │                │          
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:201:16
    │
201 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^^^^^     ^^^^^^^   ^ u256: Value
    │                │               │          
    │                │               u256: Value
    │                bool: Value

note: 
    ┌─ demos/uniswap.fe:201:32
    │
201 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                                ^^^^^^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:201:16
    │
201 │         assert amount0 > 0 and amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<40>: Memory
    │                │                             
    │                bool: Value
202 │         self._burn(self.address, liquidity)
    │         ^^^^       ^^^^ UniswapV2Pair: Value
    │         │           
    │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:202:20
    │
202 │         self._burn(self.address, liquidity)
    │                    ^^^^^^^^^^^^  ^^^^^^^^^ u256: Value
    │                    │              
    │                    address: Value

note: 
    ┌─ demos/uniswap.fe:202:9
    │
202 │         self._burn(self.address, liquidity)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
203 │         token0.transfer(to, amount0)
    │         ^^^^^^          ^^  ^^^^^^^ u256: Value
    │         │               │    
    │         │               address: Value
    │         ERC20: Value

note: 
    ┌─ demos/uniswap.fe:203:9
    │
203 │         token0.transfer(to, amount0)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
204 │         token1.transfer(to, amount1)
    │         ^^^^^^          ^^  ^^^^^^^ u256: Value
    │         │               │    
    │         │               address: Value
    │         ERC20: Value

note: 
    ┌─ demos/uniswap.fe:204:9
    │
204 │         token1.transfer(to, amount1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
205 │         balance0 = token0.balanceOf(self.address)
    │         ^^^^^^^^   ^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │          │                 
    │         │          ERC20: Value
    │         u256: Value

note: 
    ┌─ demos/uniswap.fe:205:37
    │
205 │         balance0 = token0.balanceOf(self.address)
    │                                     ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:205:20
    │
205 │         balance0 = token0.balanceOf(self.address)
    │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
206 │         balance1 = token1.balanceOf(self.address)
    │         ^^^^^^^^   ^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │          │                 
    │         │          ERC20: Value
    │         u256: Value

note: 
    ┌─ demos/uniswap.fe:206:37
    │
206 │         balance1 = token1.balanceOf(self.address)
    │                                     ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:206:20
    │
206 │         balance1 = token1.balanceOf(self.address)
    │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
207 │ 
208 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256: Value
    │         │            │         │         │          
    │         │            │         │         u256: Value
    │         │            │         u256: Value
    │         │            u256: Value
    │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:208:9
    │
208 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
209 │ 
210 │         if fee_on:
    │            ^^^^^^ bool: Value
211 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │             ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:211:13
    │
211 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │             ^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^^ u256: Value
    │             │             │           
    │             │             u256: Value
    │             u256: Storage { nonce: Some(12) }

note: 
    ┌─ demos/uniswap.fe:211:27
    │
211 │             self.k_last = reserve0 * reserve1 # reserve0 and reserve1 are up-to-date
    │                           ^^^^^^^^^^^^^^^^^^^ u256: Value
212 │ 
213 │         emit Burn(sender=msg.sender, amount0, amount1, to)
    │                          ^^^^^^^^^^  ^^^^^^^  ^^^^^^^  ^^ address: Value
    │                          │           │        │         
    │                          │           │        u256: Value
    │                          │           u256: Value
    │                          address: Value
214 │         return (amount0, amount1)
    │                 ^^^^^^^  ^^^^^^^ u256: Value
    │                 │         
    │                 u256: Value

note: 
    ┌─ demos/uniswap.fe:214:16
    │
214 │         return (amount0, amount1)
    │                ^^^^^^^^^^^^^^^^^^ (u256, u256): Memory

note: 
    ┌─ demos/uniswap.fe:213:9
    │
213 │         emit Burn(sender=msg.sender, amount0, amount1, to)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 10738919684795162003
    │
    = Event {
          name: "Burn",
          fields: [
              EventField {
                  name: "sender",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "amount0",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount1",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
          ],
      }

note: 
    ┌─ demos/uniswap.fe:191:29
    │
191 │         let token0: ERC20 = ERC20(self.token0)
    │                             ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))
192 │         let token1: ERC20 = ERC20(self.token1)
    │                             ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))
193 │         let balance0: u256 = token0.balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
194 │         let balance1: u256 = token1.balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
    ·
197 │         let fee_on: bool = self._mint_fee(reserve0, reserve1)
    │                            ^^^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(17) }
    ·
202 │         self._burn(self.address, liquidity)
    │         ^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(7) }
203 │         token0.transfer(to, amount0)
    │         ^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(1) }
204 │         token1.transfer(to, amount1)
    │         ^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(1) }
205 │         balance0 = token0.balanceOf(self.address)
    │                    ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
206 │         balance1 = token1.balanceOf(self.address)
    │                    ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
207 │ 
208 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(16) }

note: 
    ┌─ demos/uniswap.fe:219:5
    │  
219 │ ╭     pub fn swap(self, amount0_out: u256, amount1_out: u256, to: address):
220 │ │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
221 │ │         let reserve0: u256 = self.reserve0
222 │ │         let reserve1: u256 = self.reserve1
    · │
252 │ │         self._update(balance0, balance1, reserve0, reserve1)
253 │ │         emit Swap(sender=msg.sender, amount0_in, amount1_in, amount0_out, amount1_out, to)
    │ ╰──────────────────────────────────────────────────────────────────────────────────────────^ attributes hash: 5877065548740974671
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "amount0_out",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "amount1_out",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:221:23
    │
221 │         let reserve0: u256 = self.reserve0
    │                       ^^^^ u256
222 │         let reserve1: u256 = self.reserve1
    │                       ^^^^ u256
    ·
225 │         let token0: ERC20 = ERC20(self.token0)
    │                     ^^^^^ ERC20
226 │         let token1: ERC20 = ERC20(self.token1)
    │                     ^^^^^ ERC20
    ·
239 │         let balance0: u256 = token0.balanceOf(self.address)
    │                       ^^^^ u256
240 │         let balance1: u256 = token1.balanceOf(self.address)
    │                       ^^^^ u256
241 │ 
242 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                         ^^^^ u256
243 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                         ^^^^ u256
    ·
247 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                ^^^^ u256
248 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                ^^^^ u256

note: 
    ┌─ demos/uniswap.fe:220:16
    │
220 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^   ^ u256: Value
    │                │              
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:220:16
    │
220 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^    ^^^^^^^^^^^   ^ u256: Value
    │                │                  │              
    │                │                  u256: Value
    │                bool: Value

note: 
    ┌─ demos/uniswap.fe:220:35
    │
220 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                                   ^^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:220:16
    │
220 │         assert amount0_out > 0 or amount1_out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<37>: Memory
    │                │                                    
    │                bool: Value
221 │         let reserve0: u256 = self.reserve0
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:221:30
    │
221 │         let reserve0: u256 = self.reserve0
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value
222 │         let reserve1: u256 = self.reserve1
    │                              ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:222:30
    │
222 │         let reserve1: u256 = self.reserve1
    │                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value
223 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │                │              
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:223:16
    │
223 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^   ^^^^^^^^ u256: Value
    │                │                          │              
    │                │                          u256: Value
    │                bool: Value

note: 
    ┌─ demos/uniswap.fe:223:43
    │
223 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                                           ^^^^^^^^^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:223:16
    │
223 │         assert amount0_out < reserve0 and amount1_out < reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<33>: Memory
    │                │                                                   
    │                bool: Value
224 │ 
225 │         let token0: ERC20 = ERC20(self.token0)
    │                                   ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:225:35
    │
225 │         let token0: ERC20 = ERC20(self.token0)
    │                                   ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ demos/uniswap.fe:225:29
    │
225 │         let token0: ERC20 = ERC20(self.token0)
    │                             ^^^^^^^^^^^^^^^^^^ ERC20: Value
226 │         let token1: ERC20 = ERC20(self.token1)
    │                                   ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:226:35
    │
226 │         let token1: ERC20 = ERC20(self.token1)
    │                                   ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ demos/uniswap.fe:226:29
    │
226 │         let token1: ERC20 = ERC20(self.token1)
    │                             ^^^^^^^^^^^^^^^^^^ ERC20: Value
    ·
229 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^            ^^^^^^ ERC20: Value
    │                │              
    │                address: Value

note: 
    ┌─ demos/uniswap.fe:229:22
    │
229 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                      ^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:229:16
    │
229 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^^^^^^^^^^^^^^^^^^^^     ^^            ^^^^^^ ERC20: Value
    │                │                         │              
    │                │                         address: Value
    │                bool: Value

note: 
    ┌─ demos/uniswap.fe:229:48
    │
229 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                                                ^^^^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:229:42
    │
229 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                                          ^^^^^^^^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:229:16
    │
229 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^ String<21>: Memory
    │                │                                                 
    │                bool: Value
230 │ 
231 │         if amount0_out > 0:
    │            ^^^^^^^^^^^   ^ u256: Value
    │            │              
    │            u256: Value

note: 
    ┌─ demos/uniswap.fe:231:12
    │
231 │         if amount0_out > 0:
    │            ^^^^^^^^^^^^^^^ bool: Value
232 │             token0.transfer(to, amount0_out) # optimistically transfer tokens
    │             ^^^^^^          ^^  ^^^^^^^^^^^ u256: Value
    │             │               │    
    │             │               address: Value
    │             ERC20: Value

note: 
    ┌─ demos/uniswap.fe:232:13
    │
232 │             token0.transfer(to, amount0_out) # optimistically transfer tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
233 │         if amount1_out > 0:
    │            ^^^^^^^^^^^   ^ u256: Value
    │            │              
    │            u256: Value

note: 
    ┌─ demos/uniswap.fe:233:12
    │
233 │         if amount1_out > 0:
    │            ^^^^^^^^^^^^^^^ bool: Value
234 │             token1.transfer(to, amount1_out) # optimistically transfer tokens
    │             ^^^^^^          ^^  ^^^^^^^^^^^ u256: Value
    │             │               │    
    │             │               address: Value
    │             ERC20: Value

note: 
    ┌─ demos/uniswap.fe:234:13
    │
234 │             token1.transfer(to, amount1_out) # optimistically transfer tokens
    │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
    ·
239 │         let balance0: u256 = token0.balanceOf(self.address)
    │                              ^^^^^^           ^^^^ UniswapV2Pair: Value
    │                              │                 
    │                              ERC20: Value

note: 
    ┌─ demos/uniswap.fe:239:47
    │
239 │         let balance0: u256 = token0.balanceOf(self.address)
    │                                               ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:239:30
    │
239 │         let balance0: u256 = token0.balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
240 │         let balance1: u256 = token1.balanceOf(self.address)
    │                              ^^^^^^           ^^^^ UniswapV2Pair: Value
    │                              │                 
    │                              ERC20: Value

note: 
    ┌─ demos/uniswap.fe:240:47
    │
240 │         let balance1: u256 = token1.balanceOf(self.address)
    │                                               ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:240:30
    │
240 │         let balance1: u256 = token1.balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
241 │ 
242 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                                                       ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                                                       │          │           
    │                                                                       │          u256: Value
    │                                                                       u256: Value

note: 
    ┌─ demos/uniswap.fe:242:82
    │
242 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                                                                  ^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:242:32
    │
242 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
    │                                │                                       
    │                                u256: Value

note: 
    ┌─ demos/uniswap.fe:242:44
    │
242 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                            ^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                            │           
    │                                            u256: Value

note: 
    ┌─ demos/uniswap.fe:242:43
    │
242 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:242:32
    │
242 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                           ^ u256: Value
    │                                │                                                                              
    │                                u256: Value

note: 
    ┌─ demos/uniswap.fe:242:32
    │
242 │         let amount0_in: u256 = balance0 - (reserve0 - amount0_out) if balance0 > reserve0 - amount0_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
243 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                                                       ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                                                       │          │           
    │                                                                       │          u256: Value
    │                                                                       u256: Value

note: 
    ┌─ demos/uniswap.fe:243:82
    │
243 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                                                                  ^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:243:32
    │
243 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
    │                                │                                       
    │                                u256: Value

note: 
    ┌─ demos/uniswap.fe:243:44
    │
243 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                            ^^^^^^^^   ^^^^^^^^^^^ u256: Value
    │                                            │           
    │                                            u256: Value

note: 
    ┌─ demos/uniswap.fe:243:43
    │
243 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                           ^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:243:32
    │
243 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                           ^ u256: Value
    │                                │                                                                              
    │                                u256: Value

note: 
    ┌─ demos/uniswap.fe:243:32
    │
243 │         let amount1_in: u256 = balance1 - (reserve1 - amount1_out) if balance1 > reserve1 - amount1_out else 0
    │                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
244 │ 
245 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^   ^ u256: Value
    │                │             
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:245:16
    │
245 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^    ^^^^^^^^^^   ^ u256: Value
    │                │                 │             
    │                │                 u256: Value
    │                bool: Value

note: 
    ┌─ demos/uniswap.fe:245:34
    │
245 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                                  ^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:245:16
    │
245 │         assert amount0_in > 0 or amount1_in > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<36>: Memory
    │                │                                  
    │                bool: Value
246 │ 
247 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^   ^^^^ u256: Value
    │                                       │           
    │                                       u256: Value

note: 
    ┌─ demos/uniswap.fe:247:39
    │
247 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^^^^^^^^   ^^^^^^^^^^   ^ u256: Value
    │                                       │                 │             
    │                                       │                 u256: Value
    │                                       u256: Value

note: 
    ┌─ demos/uniswap.fe:247:57
    │
247 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                                         ^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:247:39
    │
247 │         let balance0_adjusted: u256 = balance0 * 1000 - amount0_in * 3
    │                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
248 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^   ^^^^ u256: Value
    │                                       │           
    │                                       u256: Value

note: 
    ┌─ demos/uniswap.fe:248:39
    │
248 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^^^^^^^^   ^^^^^^^^^^   ^ u256: Value
    │                                       │                 │             
    │                                       │                 u256: Value
    │                                       u256: Value

note: 
    ┌─ demos/uniswap.fe:248:57
    │
248 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                                         ^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:248:39
    │
248 │         let balance1_adjusted: u256 = balance1 * 1000 - amount1_in * 3
    │                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
249 │ 
250 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^ u256: Value
    │                │                    
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:250:16
    │
250 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^   ^^^^^^^^ u256: Value
    │                │                                        │           
    │                │                                        u256: Value
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:250:57
    │
250 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                                                         ^^^^^^^^^^^^^^^^^^^   ^^^^^^^ u256: Value
    │                                                         │                      
    │                                                         u256: Value

note: 
    ┌─ demos/uniswap.fe:250:57
    │
250 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:250:16
    │
250 │         assert balance0_adjusted * balance1_adjusted >= reserve0 * reserve1 * 1000000, "UniswapV2: K"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^ String<12>: Memory
    │                │                                                                        
    │                bool: Value
251 │ 
252 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^         ^^^^^^^^  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^ u256: Value
    │         │            │         │         │          
    │         │            │         │         u256: Value
    │         │            │         u256: Value
    │         │            u256: Value
    │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:252:9
    │
252 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
253 │         emit Swap(sender=msg.sender, amount0_in, amount1_in, amount0_out, amount1_out, to)
    │                          ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^  ^^ address: Value
    │                          │           │           │           │            │             
    │                          │           │           │           │            u256: Value
    │                          │           │           │           u256: Value
    │                          │           │           u256: Value
    │                          │           u256: Value
    │                          address: Value

note: 
    ┌─ demos/uniswap.fe:253:9
    │
253 │         emit Swap(sender=msg.sender, amount0_in, amount1_in, amount0_out, amount1_out, to)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 16055667627771619025
    │
    = Event {
          name: "Swap",
          fields: [
              EventField {
                  name: "sender",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "amount0_in",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount1_in",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount0_out",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "amount1_out",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
          ],
      }

note: 
    ┌─ demos/uniswap.fe:225:29
    │
225 │         let token0: ERC20 = ERC20(self.token0)
    │                             ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))
226 │         let token1: ERC20 = ERC20(self.token1)
    │                             ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))
    ·
229 │         assert to != address(token0) and to != address(token1), "UniswapV2: INVALID_TO"
    │                      ^^^^^^^                   ^^^^^^^ TypeConstructor(Base(Address))
    │                      │                          
    │                      TypeConstructor(Base(Address))
    ·
232 │             token0.transfer(to, amount0_out) # optimistically transfer tokens
    │             ^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(1) }
233 │         if amount1_out > 0:
234 │             token1.transfer(to, amount1_out) # optimistically transfer tokens
    │             ^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(1) }
    ·
239 │         let balance0: u256 = token0.balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
240 │         let balance1: u256 = token1.balanceOf(self.address)
    │                              ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
    ·
252 │         self._update(balance0, balance1, reserve0, reserve1)
    │         ^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(16) }

note: 
    ┌─ demos/uniswap.fe:256:5
    │  
256 │ ╭     pub fn skim(self, to: address):
257 │ │         let token0: ERC20 = ERC20(self.token0) # gas savings
258 │ │         let token1: ERC20 = ERC20(self.token1) # gas savings
259 │ │ 
260 │ │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
261 │ │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │ ╰───────────────────────────────────────────────────────────────────────────^ attributes hash: 2743839557985291820
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:257:21
    │
257 │         let token0: ERC20 = ERC20(self.token0) # gas savings
    │                     ^^^^^ ERC20
258 │         let token1: ERC20 = ERC20(self.token1) # gas savings
    │                     ^^^^^ ERC20

note: 
    ┌─ demos/uniswap.fe:257:35
    │
257 │         let token0: ERC20 = ERC20(self.token0) # gas savings
    │                                   ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:257:35
    │
257 │         let token0: ERC20 = ERC20(self.token0) # gas savings
    │                                   ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ demos/uniswap.fe:257:29
    │
257 │         let token0: ERC20 = ERC20(self.token0) # gas savings
    │                             ^^^^^^^^^^^^^^^^^^ ERC20: Value
258 │         let token1: ERC20 = ERC20(self.token1) # gas savings
    │                                   ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:258:35
    │
258 │         let token1: ERC20 = ERC20(self.token1) # gas savings
    │                                   ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ demos/uniswap.fe:258:29
    │
258 │         let token1: ERC20 = ERC20(self.token1) # gas savings
    │                             ^^^^^^^^^^^^^^^^^^ ERC20: Value
259 │ 
260 │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
    │         ^^^^^^          ^^  ^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │               │   │                 
    │         │               │   ERC20: Value
    │         │               address: Value
    │         ERC20: Value

note: 
    ┌─ demos/uniswap.fe:260:46
    │
260 │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
    │                                              ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:260:29
    │
260 │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                             │                                 
    │                             u256: Value

note: 
    ┌─ demos/uniswap.fe:260:62
    │
260 │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
    │                                                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ demos/uniswap.fe:260:29
    │
260 │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:260:9
    │
260 │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value
261 │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │         ^^^^^^          ^^  ^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │               │   │                 
    │         │               │   ERC20: Value
    │         │               address: Value
    │         ERC20: Value

note: 
    ┌─ demos/uniswap.fe:261:46
    │
261 │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │                                              ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:261:29
    │
261 │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Pair: Value
    │                             │                                 
    │                             u256: Value

note: 
    ┌─ demos/uniswap.fe:261:62
    │
261 │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │                                                              ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ demos/uniswap.fe:261:29
    │
261 │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:261:9
    │
261 │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ bool: Value

note: 
    ┌─ demos/uniswap.fe:257:29
    │
257 │         let token0: ERC20 = ERC20(self.token0) # gas savings
    │                             ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))
258 │         let token1: ERC20 = ERC20(self.token1) # gas savings
    │                             ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))
259 │ 
260 │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
    │                             ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }

note: 
    ┌─ demos/uniswap.fe:260:9
    │
260 │         token0.transfer(to, token0.balanceOf(self.address) - self.reserve0)
    │         ^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(1) }
261 │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │                             ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }

note: 
    ┌─ demos/uniswap.fe:261:9
    │
261 │         token1.transfer(to, token1.balanceOf(self.address) - self.reserve1)
    │         ^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(1) }

note: 
    ┌─ demos/uniswap.fe:264:5
    │  
264 │ ╭     pub fn sync(self):
265 │ │         let token0: ERC20 = ERC20(self.token0)
266 │ │         let token1: ERC20 = ERC20(self.token1)
267 │ │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────^ attributes hash: 17603814563784536273
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:265:21
    │
265 │         let token0: ERC20 = ERC20(self.token0)
    │                     ^^^^^ ERC20
266 │         let token1: ERC20 = ERC20(self.token1)
    │                     ^^^^^ ERC20

note: 
    ┌─ demos/uniswap.fe:265:35
    │
265 │         let token0: ERC20 = ERC20(self.token0)
    │                                   ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:265:35
    │
265 │         let token0: ERC20 = ERC20(self.token0)
    │                                   ^^^^^^^^^^^ address: Storage { nonce: Some(5) } => Value

note: 
    ┌─ demos/uniswap.fe:265:29
    │
265 │         let token0: ERC20 = ERC20(self.token0)
    │                             ^^^^^^^^^^^^^^^^^^ ERC20: Value
266 │         let token1: ERC20 = ERC20(self.token1)
    │                                   ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:266:35
    │
266 │         let token1: ERC20 = ERC20(self.token1)
    │                                   ^^^^^^^^^^^ address: Storage { nonce: Some(6) } => Value

note: 
    ┌─ demos/uniswap.fe:266:29
    │
266 │         let token1: ERC20 = ERC20(self.token1)
    │                             ^^^^^^^^^^^^^^^^^^ ERC20: Value
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │         ^^^^         ^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │            │                 
    │         │            ERC20: Value
    │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:267:39
    │
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │                                       ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:267:22
    │
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^           ^^^^ UniswapV2Pair: Value
    │                      │                               │                 
    │                      │                               ERC20: Value
    │                      u256: Value

note: 
    ┌─ demos/uniswap.fe:267:71
    │
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │                                                                       ^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:267:54
    │
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^ UniswapV2Pair: Value
    │                                                      │                                
    │                                                      u256: Value

note: 
    ┌─ demos/uniswap.fe:267:86
    │
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │                                                                                      ^^^^^^^^^^^^^  ^^^^ UniswapV2Pair: Value
    │                                                                                      │               
    │                                                                                      u256: Storage { nonce: Some(7) } => Value

note: 
    ┌─ demos/uniswap.fe:267:101
    │
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │                                                                                                     ^^^^^^^^^^^^^ u256: Storage { nonce: Some(8) } => Value

note: 
    ┌─ demos/uniswap.fe:267:9
    │
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value

note: 
    ┌─ demos/uniswap.fe:265:29
    │
265 │         let token0: ERC20 = ERC20(self.token0)
    │                             ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))
266 │         let token1: ERC20 = ERC20(self.token1)
    │                             ^^^^^ TypeConstructor(Contract(Contract { name: "ERC20", id: ContractId(0) }))
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │                      ^^^^^^^^^^^^^^^^                ^^^^^^^^^^^^^^^^ External { contract: ContractId(0), function: FunctionId(0) }
    │                      │                                
    │                      External { contract: ContractId(0), function: FunctionId(0) }

note: 
    ┌─ demos/uniswap.fe:267:9
    │
267 │         self._update(token0.balanceOf(self.address), token1.balanceOf(self.address), self.reserve0, self.reserve1)
    │         ^^^^^^^^^^^^ ValueMethod { is_self: true, class: Contract(ContractId(1)), method: FunctionId(16) }

note: 
    ┌─ demos/uniswap.fe:269:5
    │  
269 │ ╭     fn sqrt(val: u256) -> u256:
270 │ │         let z: u256
271 │ │         if (val > 3):
272 │ │             z = val
    · │
278 │ │             z = 1
279 │ │         return z
    │ ╰────────────────^ attributes hash: 3075818098030342593
    │  
    = FunctionSignature {
          self_decl: None,
          params: [
              FunctionParam {
                  name: "val",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:270:16
    │
270 │         let z: u256
    │                ^^^^ u256
    ·
273 │             let x: u256 = val / 2 + 1
    │                    ^^^^ u256

note: 
    ┌─ demos/uniswap.fe:271:13
    │
271 │         if (val > 3):
    │             ^^^   ^ u256: Value
    │             │      
    │             u256: Value

note: 
    ┌─ demos/uniswap.fe:271:12
    │
271 │         if (val > 3):
    │            ^^^^^^^^^ bool: Value
272 │             z = val
    │             ^   ^^^ u256: Value
    │             │    
    │             u256: Value
273 │             let x: u256 = val / 2 + 1
    │                           ^^^   ^ u256: Value
    │                           │      
    │                           u256: Value

note: 
    ┌─ demos/uniswap.fe:273:27
    │
273 │             let x: u256 = val / 2 + 1
    │                           ^^^^^^^   ^ u256: Value
    │                           │          
    │                           u256: Value

note: 
    ┌─ demos/uniswap.fe:273:27
    │
273 │             let x: u256 = val / 2 + 1
    │                           ^^^^^^^^^^^ u256: Value
274 │             while (x < z):
    │                    ^   ^ u256: Value
    │                    │    
    │                    u256: Value

note: 
    ┌─ demos/uniswap.fe:274:19
    │
274 │             while (x < z):
    │                   ^^^^^^^ bool: Value
275 │                 z = x
    │                 ^   ^ u256: Value
    │                 │    
    │                 u256: Value
276 │                 x = (val / x + x) / 2
    │                 ^    ^^^   ^ u256: Value
    │                 │    │      
    │                 │    u256: Value
    │                 u256: Value

note: 
    ┌─ demos/uniswap.fe:276:22
    │
276 │                 x = (val / x + x) / 2
    │                      ^^^^^^^   ^ u256: Value
    │                      │          
    │                      u256: Value

note: 
    ┌─ demos/uniswap.fe:276:21
    │
276 │                 x = (val / x + x) / 2
    │                     ^^^^^^^^^^^^^   ^ u256: Value
    │                     │                
    │                     u256: Value

note: 
    ┌─ demos/uniswap.fe:276:21
    │
276 │                 x = (val / x + x) / 2
    │                     ^^^^^^^^^^^^^^^^^ u256: Value
277 │         elif (val != 0):
    │               ^^^    ^ u256: Value
    │               │       
    │               u256: Value

note: 
    ┌─ demos/uniswap.fe:277:14
    │
277 │         elif (val != 0):
    │              ^^^^^^^^^^ bool: Value
278 │             z = 1
    │             ^   ^ u256: Value
    │             │    
    │             u256: Value
279 │         return z
    │                ^ u256: Value

note: 
    ┌─ demos/uniswap.fe:281:5
    │  
281 │ ╭     fn min(x: u256, y: u256) -> u256:
282 │ │         return x if x < y else y
    │ ╰────────────────────────────────^ attributes hash: 4022593831796629401
    │  
    = FunctionSignature {
          self_decl: None,
          params: [
              FunctionParam {
                  name: "x",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
              FunctionParam {
                  name: "y",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:282:21
    │
282 │         return x if x < y else y
    │                     ^   ^ u256: Value
    │                     │    
    │                     u256: Value

note: 
    ┌─ demos/uniswap.fe:282:16
    │
282 │         return x if x < y else y
    │                ^    ^^^^^      ^ u256: Value
    │                │    │           
    │                │    bool: Value
    │                u256: Value

note: 
    ┌─ demos/uniswap.fe:282:16
    │
282 │         return x if x < y else y
    │                ^^^^^^^^^^^^^^^^^ u256: Value

note: 
    ┌─ demos/uniswap.fe:285:5
    │
285 │     fee_to: address
    │     ^^^^^^^^^^^^^^^ address
286 │     fee_to_setter: address
    │     ^^^^^^^^^^^^^^^^^^^^^^ address
287 │ 
288 │     pairs: Map<address, Map<address, address>>
    │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map<address, Map<address, address>>
289 │ 
290 │     all_pairs: Array<address, 100>
    │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Array<address, 100>
291 │     pair_counter: u256
    │     ^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ demos/uniswap.fe:294:9
    │
294 │         idx token0: address
    │         ^^^^^^^^^^^^^^^^^^^ address
295 │         idx token1: address
    │         ^^^^^^^^^^^^^^^^^^^ address
296 │         pair: address
    │         ^^^^^^^^^^^^^ address
297 │         index: u256
    │         ^^^^^^^^^^^ u256

note: 
    ┌─ demos/uniswap.fe:302:5
    │  
302 │ ╭     pub fn fee_to(self) -> address:
303 │ │         return self.fee_to
    │ ╰──────────────────────────^ attributes hash: 10447292744135180405
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [],
          return_type: Ok(
              Base(
                  Address,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:303:16
    │
303 │         return self.fee_to
    │                ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:303:16
    │
303 │         return self.fee_to
    │                ^^^^^^^^^^^ address: Storage { nonce: Some(0) } => Value

note: 
    ┌─ demos/uniswap.fe:305:5
    │  
305 │ ╭     pub fn fee_to_setter(self) -> address:
306 │ │         return self.fee_to_setter
    │ ╰─────────────────────────────────^ attributes hash: 10447292744135180405
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [],
          return_type: Ok(
              Base(
                  Address,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:306:16
    │
306 │         return self.fee_to_setter
    │                ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:306:16
    │
306 │         return self.fee_to_setter
    │                ^^^^^^^^^^^^^^^^^^ address: Storage { nonce: Some(1) } => Value

note: 
    ┌─ demos/uniswap.fe:308:5
    │  
308 │ ╭     pub fn all_pairs_length(self) -> u256:
309 │ │         return self.pair_counter
    │ ╰────────────────────────────────^ attributes hash: 2875164910451995213
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [],
          return_type: Ok(
              Base(
                  Numeric(
                      U256,
                  ),
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:309:16
    │
309 │         return self.pair_counter
    │                ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:309:16
    │
309 │         return self.pair_counter
    │                ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(4) } => Value

note: 
    ┌─ demos/uniswap.fe:311:5
    │  
311 │ ╭     pub fn create_pair(self, token_a: address, token_b: address) -> address:
312 │ │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
313 │ │ 
314 │ │         let token0: address = token_a 
    · │
328 │ │         emit PairCreated(token0, token1, pair=address(pair), index=self.pair_counter)
329 │ │         return address(pair)
    │ ╰────────────────────────────^ attributes hash: 1028840135620418462
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "token_a",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
              FunctionParam {
                  name: "token_b",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Address,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:314:21
    │
314 │         let token0: address = token_a 
    │                     ^^^^^^^ address
315 │         let token1: address = token_b
    │                     ^^^^^^^ address
    ·
319 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                   ^^^^ u256
320 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(0, salt)
    │                   ^^^^^^^^^^^^^ UniswapV2Pair

note: 
    ┌─ demos/uniswap.fe:312:16
    │
312 │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
    │                ^^^^^^^    ^^^^^^^ address: Value
    │                │           
    │                address: Value

note: 
    ┌─ demos/uniswap.fe:312:16
    │
312 │         assert token_a != token_b, "UniswapV2: IDENTICAL_ADDRESSES"
    │                ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ String<30>: Memory
    │                │                    
    │                bool: Value
313 │ 
314 │         let token0: address = token_a 
    │                               ^^^^^^^ address: Value
315 │         let token1: address = token_b
    │                               ^^^^^^^ address: Value
316 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                ^^^^^^            ^ u256: Value
    │                │                  
    │                address: Value

note: 
    ┌─ demos/uniswap.fe:316:26
    │
316 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                          ^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:316:16
    │
316 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^ String<23>: Memory
    │                │                      
    │                bool: Value
317 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:317:16
    │
317 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^ ^^^^^^ address: Value
    │                │           
    │                Map<address, Map<address, address>>: Storage { nonce: Some(2) }

note: 
    ┌─ demos/uniswap.fe:317:16
    │
317 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^ ^^^^^^ address: Value
    │                │                   
    │                Map<address, address>: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:317:16
    │
317 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^            ^ u256: Value
    │                │                                      
    │                address: Storage { nonce: None } => Value

note: 
    ┌─ demos/uniswap.fe:317:46
    │
317 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                                              ^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:317:16
    │
317 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^ String<22>: Memory
    │                │                                          
    │                bool: Value
318 │ 
319 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                     ^^^^^^  ^^^^^^ address: Value
    │                                     │        
    │                                     address: Value

note: 
    ┌─ demos/uniswap.fe:319:36
    │
319 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                    ^^^^^^^^^^^^^^^^ (address, address): Memory

note: 
    ┌─ demos/uniswap.fe:319:36
    │
319 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Array<u8, 64>: Memory

note: 
    ┌─ demos/uniswap.fe:319:26
    │
319 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256: Value
320 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(0, salt)
    │                                                         ^  ^^^^ u256: Value
    │                                                         │   
    │                                                         u256: Value

note: 
    ┌─ demos/uniswap.fe:320:35
    │
320 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(0, salt)
    │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UniswapV2Pair: Value
321 │         pair.initialize(token0, token1)
    │         ^^^^            ^^^^^^  ^^^^^^ address: Value
    │         │               │        
    │         │               address: Value
    │         UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:321:9
    │
321 │         pair.initialize(token0, token1)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (): Value
322 │ 
323 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:323:9
    │
323 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^ ^^^^^^ address: Value
    │         │           
    │         Map<address, Map<address, address>>: Storage { nonce: Some(2) }

note: 
    ┌─ demos/uniswap.fe:323:9
    │
323 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^ ^^^^^^ address: Value
    │         │                   
    │         Map<address, address>: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:323:9
    │
323 │         self.pairs[token0][token1] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │                                     
    │         address: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:323:38
    │
323 │         self.pairs[token0][token1] = address(pair)
    │                                      ^^^^^^^^^^^^^ address: Value
324 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:324:9
    │
324 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^ ^^^^^^ address: Value
    │         │           
    │         Map<address, Map<address, address>>: Storage { nonce: Some(2) }

note: 
    ┌─ demos/uniswap.fe:324:9
    │
324 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^ ^^^^^^ address: Value
    │         │                   
    │         Map<address, address>: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:324:9
    │
324 │         self.pairs[token1][token0] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │                                     
    │         address: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:324:38
    │
324 │         self.pairs[token1][token0] = address(pair)
    │                                      ^^^^^^^^^^^^^ address: Value
325 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:325:9
    │
325 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^^^^^^^^^^^ ^^^^ UniswapV2Factory: Value
    │         │               
    │         Array<address, 100>: Storage { nonce: Some(3) }

note: 
    ┌─ demos/uniswap.fe:325:24
    │
325 │         self.all_pairs[self.pair_counter] = address(pair)
    │                        ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(4) } => Value

note: 
    ┌─ demos/uniswap.fe:325:9
    │
325 │         self.all_pairs[self.pair_counter] = address(pair)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^^^ UniswapV2Pair: Value
    │         │                                            
    │         address: Storage { nonce: None }

note: 
    ┌─ demos/uniswap.fe:325:45
    │
325 │         self.all_pairs[self.pair_counter] = address(pair)
    │                                             ^^^^^^^^^^^^^ address: Value
326 │         self.pair_counter = self.pair_counter + 1
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:326:9
    │
326 │         self.pair_counter = self.pair_counter + 1
    │         ^^^^^^^^^^^^^^^^^   ^^^^ UniswapV2Factory: Value
    │         │                    
    │         u256: Storage { nonce: Some(4) }

note: 
    ┌─ demos/uniswap.fe:326:29
    │
326 │         self.pair_counter = self.pair_counter + 1
    │                             ^^^^^^^^^^^^^^^^^   ^ u256: Value
    │                             │                    
    │                             u256: Storage { nonce: Some(4) } => Value

note: 
    ┌─ demos/uniswap.fe:326:29
    │
326 │         self.pair_counter = self.pair_counter + 1
    │                             ^^^^^^^^^^^^^^^^^^^^^ u256: Value
327 │ 
328 │         emit PairCreated(token0, token1, pair=address(pair), index=self.pair_counter)
    │                          ^^^^^^  ^^^^^^               ^^^^ UniswapV2Pair: Value
    │                          │       │                     
    │                          │       address: Value
    │                          address: Value

note: 
    ┌─ demos/uniswap.fe:328:47
    │
328 │         emit PairCreated(token0, token1, pair=address(pair), index=self.pair_counter)
    │                                               ^^^^^^^^^^^^^        ^^^^ UniswapV2Factory: Value
    │                                               │                     
    │                                               address: Value

note: 
    ┌─ demos/uniswap.fe:328:68
    │
328 │         emit PairCreated(token0, token1, pair=address(pair), index=self.pair_counter)
    │                                                                    ^^^^^^^^^^^^^^^^^ u256: Storage { nonce: Some(4) } => Value
329 │         return address(pair)
    │                        ^^^^ UniswapV2Pair: Value

note: 
    ┌─ demos/uniswap.fe:329:16
    │
329 │         return address(pair)
    │                ^^^^^^^^^^^^^ address: Value

note: 
    ┌─ demos/uniswap.fe:328:9
    │
328 │         emit PairCreated(token0, token1, pair=address(pair), index=self.pair_counter)
    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attributes hash: 13094055123344570742
    │
    = Event {
          name: "PairCreated",
          fields: [
              EventField {
                  name: "token0",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "token1",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: true,
              },
              EventField {
                  name: "pair",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
                  is_indexed: false,
              },
              EventField {
                  name: "index",
                  typ: Ok(
                      Base(
                          Numeric(
                              U256,
                          ),
                      ),
                  ),
                  is_indexed: false,
              },
          ],
      }

note: 
    ┌─ demos/uniswap.fe:316:26
    │
316 │         assert token0 != address(0), "UniswapV2: ZERO_ADDRESS"
    │                          ^^^^^^^ TypeConstructor(Base(Address))
317 │         assert self.pairs[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"
    │                                              ^^^^^^^ TypeConstructor(Base(Address))
318 │ 
319 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ BuiltinValueMethod { method: AbiEncode, typ: Tuple(Tuple { items: [Base(Address), Base(Address)] }) }

note: 
    ┌─ demos/uniswap.fe:319:26
    │
319 │         let salt: u256 = keccak256((token0, token1).abi_encode())
    │                          ^^^^^^^^^ BuiltinFunction(Keccak256)
320 │         let pair: UniswapV2Pair = UniswapV2Pair.create2(0, salt)
    │                                   ^^^^^^^^^^^^^^^^^^^^^ BuiltinAssociatedFunction { contract: ContractId(1), function: Create2 }
321 │         pair.initialize(token0, token1)
    │         ^^^^^^^^^^^^^^^ External { contract: ContractId(1), function: FunctionId(15) }
322 │ 
323 │         self.pairs[token0][token1] = address(pair)
    │                                      ^^^^^^^ TypeConstructor(Base(Address))
324 │         self.pairs[token1][token0] = address(pair)
    │                                      ^^^^^^^ TypeConstructor(Base(Address))
325 │         self.all_pairs[self.pair_counter] = address(pair)
    │                                             ^^^^^^^ TypeConstructor(Base(Address))
    ·
328 │         emit PairCreated(token0, token1, pair=address(pair), index=self.pair_counter)
    │                                               ^^^^^^^ TypeConstructor(Base(Address))
329 │         return address(pair)
    │                ^^^^^^^ TypeConstructor(Base(Address))

note: 
    ┌─ demos/uniswap.fe:331:5
    │  
331 │ ╭     pub fn set_fee_to(self, fee_to: address):
332 │ │         assert msg.sender == self.fee_to_setter, "UniswapV2: FORBIDDEN"
333 │ │         self.fee_to = fee_to
    │ ╰────────────────────────────^ attributes hash: 9065496511898574892
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "fee_to",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:332:16
    │
332 │         assert msg.sender == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^    ^^^^ UniswapV2Factory: Value
    │                │              
    │                address: Value

note: 
    ┌─ demos/uniswap.fe:332:30
    │
332 │         assert msg.sender == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                              ^^^^^^^^^^^^^^^^^^ address: Storage { nonce: Some(1) } => Value

note: 
    ┌─ demos/uniswap.fe:332:16
    │
332 │         assert msg.sender == self.fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>: Memory
    │                │                                  
    │                bool: Value
333 │         self.fee_to = fee_to
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:333:9
    │
333 │         self.fee_to = fee_to
    │         ^^^^^^^^^^^   ^^^^^^ address: Value
    │         │              
    │         address: Storage { nonce: Some(0) }

note: 
    ┌─ demos/uniswap.fe:335:5
    │  
335 │ ╭     pub fn set_fee_to_setter(self, fee_to_setter: address):
336 │ │         assert msg.sender == fee_to_setter, "UniswapV2: FORBIDDEN"
337 │ │         self.fee_to_setter = fee_to_setter
    │ ╰──────────────────────────────────────────^ attributes hash: 13278168041135876934
    │  
    = FunctionSignature {
          self_decl: Some(
              Mutable,
          ),
          params: [
              FunctionParam {
                  name: "fee_to_setter",
                  typ: Ok(
                      Base(
                          Address,
                      ),
                  ),
              },
          ],
          return_type: Ok(
              Base(
                  Unit,
              ),
          ),
      }

note: 
    ┌─ demos/uniswap.fe:336:16
    │
336 │         assert msg.sender == fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^    ^^^^^^^^^^^^^ address: Value
    │                │              
    │                address: Value

note: 
    ┌─ demos/uniswap.fe:336:16
    │
336 │         assert msg.sender == fee_to_setter, "UniswapV2: FORBIDDEN"
    │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ String<20>: Memory
    │                │                             
    │                bool: Value
337 │         self.fee_to_setter = fee_to_setter
    │         ^^^^ UniswapV2Factory: Value

note: 
    ┌─ demos/uniswap.fe:337:9
    │
337 │         self.fee_to_setter = fee_to_setter
    │         ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ address: Value
    │         │                     
    │         address: Storage { nonce: Some(1) }


