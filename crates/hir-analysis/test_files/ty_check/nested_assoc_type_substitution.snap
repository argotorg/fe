---
source: crates/hir-analysis/tests/ty_check.rs
expression: res
input_file: test_files/ty_check/nested_assoc_type_substitution.fe
---
note: 
   ┌─ nested_assoc_type_substitution.fe:44:59
   │  
44 │   fn extract_value<T: Level1>() -> T::Middle::Nested::Value {
   │ ╭───────────────────────────────────────────────────────────^
45 │ │     todo()
46 │ │ }
   │ ╰─^ T::Middle::Nested::Value

note: 
   ┌─ nested_assoc_type_substitution.fe:45:5
   │
45 │     todo()
   │     ^^^^ fn todo

note: 
   ┌─ nested_assoc_type_substitution.fe:45:5
   │
45 │     todo()
   │     ^^^^^^ T::Middle::Nested::Value

note: 
   ┌─ nested_assoc_type_substitution.fe:49:29
   │  
49 │   fn test_nested_with_param() {
   │ ╭─────────────────────────────^
50 │ │     // This should resolve through the chain preserving the u32 parameter:
51 │ │     // ConcreteLevel1<u32> -> ConcreteLevel2<u32> -> ConcreteLevel3<u32> -> u32
52 │ │     let v1: u32 = extract_value<ConcreteLevel1<u32>>()
   · │
56 │ │     let v2: u256 = extract_value<ConcreteLevel1<u256>>()
57 │ │ }
   │ ╰─^ ()

note: 
   ┌─ nested_assoc_type_substitution.fe:52:9
   │
52 │     let v1: u32 = extract_value<ConcreteLevel1<u32>>()
   │         ^^ u32

note: 
   ┌─ nested_assoc_type_substitution.fe:52:19
   │
52 │     let v1: u32 = extract_value<ConcreteLevel1<u32>>()
   │                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ fn extract_value<ConcreteLevel1<u32>>

note: 
   ┌─ nested_assoc_type_substitution.fe:52:19
   │
52 │     let v1: u32 = extract_value<ConcreteLevel1<u32>>()
   │                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u32

note: 
   ┌─ nested_assoc_type_substitution.fe:56:9
   │
56 │     let v2: u256 = extract_value<ConcreteLevel1<u256>>()
   │         ^^ u256

note: 
   ┌─ nested_assoc_type_substitution.fe:56:20
   │
56 │     let v2: u256 = extract_value<ConcreteLevel1<u256>>()
   │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ fn extract_value<ConcreteLevel1<u256>>

note: 
   ┌─ nested_assoc_type_substitution.fe:56:20
   │
56 │     let v2: u256 = extract_value<ConcreteLevel1<u256>>()
   │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
   ┌─ nested_assoc_type_substitution.fe:87:46
   │  
87 │       fn encode(self) -> Self::Encoder::Output {
   │ ╭──────────────────────────────────────────────^
88 │ │    todo()
89 │ │     }
   │ ╰─────^ T

note: 
   ┌─ nested_assoc_type_substitution.fe:88:4
   │
88 │    todo()
   │    ^^^^ fn todo

note: 
   ┌─ nested_assoc_type_substitution.fe:88:4
   │
88 │    todo()
   │    ^^^^^^ T

note: 
   ┌─ nested_assoc_type_substitution.fe:93:59
   │  
93 │   fn encode_value<C: Codec>(codec: C) -> C::Encoder::Output {
   │ ╭───────────────────────────────────────────────────────────^
94 │ │     codec.encode()
95 │ │ }
   │ ╰─^ C::Encoder::Output

note: 
   ┌─ nested_assoc_type_substitution.fe:94:5
   │
94 │     codec.encode()
   │     ^^^^^ C

note: 
   ┌─ nested_assoc_type_substitution.fe:94:5
   │
94 │     codec.encode()
   │     ^^^^^^^^^^^^^^ C::Encoder::Output

note: 
    ┌─ nested_assoc_type_substitution.fe:97:17
    │  
 97 │   fn test_codec() {
    │ ╭─────────────────^
 98 │ │     let codec32: MyCodec<u32> = MyCodec { phantom: 0 }
 99 │ │     let codec256: MyCodec<u256> = MyCodec { phantom: 0 }
100 │ │ 
    · │
106 │ │     let encoded2: u256 = encode_value(codec: codec256)
107 │ │ }
    │ ╰─^ ()

note: 
   ┌─ nested_assoc_type_substitution.fe:98:9
   │
98 │     let codec32: MyCodec<u32> = MyCodec { phantom: 0 }
   │         ^^^^^^^ MyCodec<u32>

note: 
   ┌─ nested_assoc_type_substitution.fe:98:33
   │
98 │     let codec32: MyCodec<u32> = MyCodec { phantom: 0 }
   │                                 ^^^^^^^^^^^^^^^^^^^^^^ MyCodec<u32>

note: 
   ┌─ nested_assoc_type_substitution.fe:98:52
   │
98 │     let codec32: MyCodec<u32> = MyCodec { phantom: 0 }
   │                                                    ^ u32

note: 
   ┌─ nested_assoc_type_substitution.fe:99:9
   │
99 │     let codec256: MyCodec<u256> = MyCodec { phantom: 0 }
   │         ^^^^^^^^ MyCodec<u256>

note: 
   ┌─ nested_assoc_type_substitution.fe:99:35
   │
99 │     let codec256: MyCodec<u256> = MyCodec { phantom: 0 }
   │                                   ^^^^^^^^^^^^^^^^^^^^^^ MyCodec<u256>

note: 
   ┌─ nested_assoc_type_substitution.fe:99:54
   │
99 │     let codec256: MyCodec<u256> = MyCodec { phantom: 0 }
   │                                                      ^ u256

note: 
    ┌─ nested_assoc_type_substitution.fe:103:9
    │
103 │     let encoded1: u32 = encode_value(codec: codec32)
    │         ^^^^^^^^ u32

note: 
    ┌─ nested_assoc_type_substitution.fe:103:25
    │
103 │     let encoded1: u32 = encode_value(codec: codec32)
    │                         ^^^^^^^^^^^^ fn encode_value<MyCodec<u32>>

note: 
    ┌─ nested_assoc_type_substitution.fe:103:25
    │
103 │     let encoded1: u32 = encode_value(codec: codec32)
    │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u32

note: 
    ┌─ nested_assoc_type_substitution.fe:103:45
    │
103 │     let encoded1: u32 = encode_value(codec: codec32)
    │                                             ^^^^^^^ MyCodec<u32>

note: 
    ┌─ nested_assoc_type_substitution.fe:106:9
    │
106 │     let encoded2: u256 = encode_value(codec: codec256)
    │         ^^^^^^^^ u256

note: 
    ┌─ nested_assoc_type_substitution.fe:106:26
    │
106 │     let encoded2: u256 = encode_value(codec: codec256)
    │                          ^^^^^^^^^^^^ fn encode_value<MyCodec<u256>>

note: 
    ┌─ nested_assoc_type_substitution.fe:106:26
    │
106 │     let encoded2: u256 = encode_value(codec: codec256)
    │                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u256

note: 
    ┌─ nested_assoc_type_substitution.fe:106:46
    │
106 │     let encoded2: u256 = encode_value(codec: codec256)
    │                                              ^^^^^^^^ MyCodec<u256>

note: 
    ┌─ nested_assoc_type_substitution.fe:117:1
    │  
117 │ ╭ {
118 │ │     // Here we need T::Assoc to resolve to something that implements Level1
119 │ │     // and then we use its nested associated type
120 │ │     let _nested: T::Assoc::Middle::Nested::Value = todo()
121 │ │     todo()
122 │ │ }
    │ ╰─^ T::Assoc

note: 
    ┌─ nested_assoc_type_substitution.fe:120:9
    │
120 │     let _nested: T::Assoc::Middle::Nested::Value = todo()
    │         ^^^^^^^ T::Assoc::Middle::Nested::Value

note: 
    ┌─ nested_assoc_type_substitution.fe:120:52
    │
120 │     let _nested: T::Assoc::Middle::Nested::Value = todo()
    │                                                    ^^^^ fn todo

note: 
    ┌─ nested_assoc_type_substitution.fe:120:52
    │
120 │     let _nested: T::Assoc::Middle::Nested::Value = todo()
    │                                                    ^^^^^^ T::Assoc::Middle::Nested::Value

note: 
    ┌─ nested_assoc_type_substitution.fe:121:5
    │
121 │     todo()
    │     ^^^^ fn todo

note: 
    ┌─ nested_assoc_type_substitution.fe:121:5
    │
121 │     todo()
    │     ^^^^^^ T::Assoc

note: 
    ┌─ nested_assoc_type_substitution.fe:130:23
    │  
130 │   fn test_constrained() {
    │ ╭───────────────────────^
131 │ │     let h: HasLevel1 = HasLevel1{}
132 │ │     // This should work: HasLevel1::Assoc = ConcreteLevel1<bool>
133 │ │     // ConcreteLevel1<bool>::Middle::Nested::Value = bool
134 │ │     let result: ConcreteLevel1<bool> = constrained(t: h)
135 │ │ }
    │ ╰─^ ()

note: 
    ┌─ nested_assoc_type_substitution.fe:131:9
    │
131 │     let h: HasLevel1 = HasLevel1{}
    │         ^ HasLevel1

note: 
    ┌─ nested_assoc_type_substitution.fe:131:24
    │
131 │     let h: HasLevel1 = HasLevel1{}
    │                        ^^^^^^^^^^^ HasLevel1

note: 
    ┌─ nested_assoc_type_substitution.fe:134:9
    │
134 │     let result: ConcreteLevel1<bool> = constrained(t: h)
    │         ^^^^^^ ConcreteLevel1<bool>

note: 
    ┌─ nested_assoc_type_substitution.fe:134:40
    │
134 │     let result: ConcreteLevel1<bool> = constrained(t: h)
    │                                        ^^^^^^^^^^^ fn constrained<HasLevel1>

note: 
    ┌─ nested_assoc_type_substitution.fe:134:40
    │
134 │     let result: ConcreteLevel1<bool> = constrained(t: h)
    │                                        ^^^^^^^^^^^^^^^^^ ConcreteLevel1<bool>

note: 
    ┌─ nested_assoc_type_substitution.fe:134:55
    │
134 │     let result: ConcreteLevel1<bool> = constrained(t: h)
    │                                                       ^ HasLevel1
