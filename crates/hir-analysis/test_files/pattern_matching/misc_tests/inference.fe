// Edge case tests for pattern matching without clear expected types

enum Option<T> {
    Some(T),
    None
}

enum Result<T, E> {
    Ok(T),
    Err(E)
}

// Test 1: Simple match with inferred type
fn test_inferred_type() -> i32 {
    let opt = Option::Some(42)
    
    match opt {
        Option::Some(x) => x
        Option::None => 0
    }
}

// Test 2: Match where scrutinee type comes from if-else
fn test_conditional_type() -> i32 {
    let value = if true {
        Option::Some(100)
    } else {
        Option::None
    }
    
    match value {
        Option::Some(n) => n
        Option::None => 0
    }
}

// Test 3: Generic function with pattern matching
fn generic_match<T>(opt: Option<T>) -> bool {
    match opt {
        Option::Some(_) => true
        Option::None => false
    }
}

// Test 4: Nested generic patterns
fn test_nested_generics() -> i32 {
    let nested: Option<Result<i32, bool>> = Option::Some(Result::Ok(42))
    
    match nested {
        Option::Some(Result::Ok(val)) => val
        Option::Some(Result::Err(_)) => -1
        Option::None => 0
    }
}

// Test 5: Pattern with wildcard that doesn't constrain type
fn test_wildcard_patterns(data: (Option<i32>, bool)) -> i32 {
    match data {
        (Option::Some(x), _) => x
        (Option::None, true) => 1
        (Option::None, false) => 2
    }
}

// Test 6: Or patterns
fn test_or_patterns(opt: Option<i32>) -> i32 {
    match opt {
        Option::Some(0) | Option::None => 0
        Option::Some(x) => x
    }
}

// Test 7: Match in expression position
fn test_match_expression() -> i32 {
    let result = match Option::Some(42) {
        Option::Some(x) => x * 2
        Option::None => 0
    }
    
    result
}

// Test 8: Multiple matches with same enum
fn test_multiple_matches() -> i32 {
    let opt1 = Option::Some(10)
    let opt2 = Option::Some(20)
    
    let sum = match opt1 {
        Option::Some(a) => {
            match opt2 {
                Option::Some(b) => a + b
                Option::None => a
            }
        }
        Option::None => {
            match opt2 {
                Option::Some(b) => b
                Option::None => 0
            }
        }
    }
    
    sum
}

// Test 9: Pattern matching with literals
fn test_literal_patterns(opt: Option<i32>) -> i32 {
    match opt {
        Option::Some(42) => 1
        Option::Some(0) => 2
        Option::Some(x) => x
        Option::None => -1
    }
}

// Test 10: Empty tuple variants (unit-like)
fn test_unit_variants() -> i32 {
    let opt: Option<i32> = Option::None
    
    match opt {
        Option::Some(x) => x
        Option::None => 42
    }
}

// Test 11: Complex nested match
fn test_complex_nesting() -> i32 {
    let data = (Option::Some(1), Option::Some(2))
    
    match data {
        (Option::Some(a), Option::Some(b)) => a + b
        (Option::Some(a), Option::None) => a
        (Option::None, Option::Some(b)) => b
        (Option::None, Option::None) => 0
    }
}

// Test 12: Match with different generic instantiations
fn test_different_instantiations() -> i32 {
    let int_opt: Option<i32> = Option::Some(42)
    let bool_opt: Option<bool> = Option::Some(true)
    
    let result1 = match int_opt {
        Option::Some(x) => x
        Option::None => 0
    }
    
    let result2 = match bool_opt {
        Option::Some(true) => 1
        Option::Some(false) => 0
        Option::None => -1
    }
    
    result1 + result2
}

// Test 13: Cases that might need type annotations
fn test_no_literal_inference() -> i32 {
    // This might need annotation since there's no literal to infer from
    let empty_none = Option::None
    
    match empty_none {
        Option::Some(x) => x
        Option::None => 42
    }
}

// Test 14: Unknown error type in Result
fn test_unknown_error_type() -> i32 {
    // The Ok value has a literal, but Err type is unknown
    let result = Result::Ok(100)
    
    match result {
        Result::Ok(val) => val
        Result::Err(_) => 0
    }
}

// Test 15: Generic function return without context
fn identity<T>(value: T) -> T {
    value
}

fn test_generic_return() -> i32 {
    // The return type of identity can't be inferred without context
    let value = identity(Option::None)
    
    match value {
        Option::Some(x) => x
        Option::None => 0
    }
}

// Test 16: Nested generics with partial information
fn test_partial_generic_info() -> i32 {
    // Inner Option type can't be inferred
    let outer = Result::Ok(Option::None)
    
    match outer {
        Result::Ok(Option::Some(val)) => val
        Result::Ok(Option::None) => 0
        Result::Err(_) => -1
    }
}

// Test 17: Multiple unknowns in tuple
fn test_tuple_unknowns() -> i32 {
    // Both Option types need inference
    let pair = (Option::None, Option::None)
    
    match pair {
        (Option::Some(a), Option::Some(b)) => a + b
        (Option::Some(a), Option::None) => a
        (Option::None, Option::Some(b)) => b
        (Option::None, Option::None) => 0
    }
}