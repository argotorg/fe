use ingot::evm
use ingot::context::CalldataReader
use ingot::traits::Max
use ingot::buf::{MemoryBuffer, MemoryBufferReader, MemoryBufferWriter}

pub trait AbiDecode {
    fn decode(mut reader: CalldataReader) -> Self;
}

pub trait AbiEncode {
    fn encode(self, mut writer: MemoryBufferWriter);
}


// unsigned integers

impl AbiDecode for u256 {
    fn decode(mut reader: CalldataReader) -> Self {
        return reader.read_u256()
    }
}

impl AbiEncode for u256 {
    fn encode(self, mut writer: MemoryBufferWriter) {
        return writer.write(value: self)
    }
}

impl AbiDecode for u128 {
    fn decode(mut reader: CalldataReader) -> Self {
        let value: u256 = reader.read_u256()
        if value > u128::max() {
            revert
        } else {
            return u128(value)
        }
    }
}

impl AbiEncode for u128 {
    fn encode(self, mut writer: MemoryBufferWriter) {
        return writer.write(value: u256(self))
    }
}

impl AbiDecode for u64 {
    fn decode(mut reader: CalldataReader) -> Self {
        let value: u256 = reader.read_u256()
        if value > u64::max() {
            revert
        } else {
            return u64(value)
        }
    }
}

impl AbiEncode for u64 {
    fn encode(self, mut writer: MemoryBufferWriter) {
        return writer.write(value: u256(self))
    }
}

impl AbiDecode for u32 {
    fn decode(mut reader: CalldataReader) -> Self {
        let value: u256 = reader.read_u256()
        if value > u32::max() {
            revert
        } else {
            return u32(value)
        }
    }
}

impl AbiEncode for u32 {
    fn encode(self, mut writer: MemoryBufferWriter) {
        return writer.write(value: u256(self))
    }
}

impl AbiDecode for u16 {
    fn decode(mut reader: CalldataReader) -> Self {
        let value: u256 = reader.read_u256()
        if value > u16::max() {
            revert
        } else {
            return u16(value)
        }
    }
}

impl AbiEncode for u16 {
    fn encode(self, mut writer: MemoryBufferWriter) {
        return writer.write(value: u256(self))
    }
}

impl AbiDecode for u8 {
    fn decode(mut reader: CalldataReader) -> Self {
        let value: u256 = reader.read_u256()
        if value > u8::max() {
            revert
        } else {
            return u8(value)
        }
    }
}

impl AbiEncode for u8 {
    fn encode(self, mut writer: MemoryBufferWriter) {
        return writer.write(value: u256(self))
    }
}

// signed integers

// todo

// misc types

impl AbiDecode for bool {
    fn decode(mut reader: CalldataReader) -> Self {
        let value: u256 = reader.read_u256()

        if value == 0 {
            return false
        } else if value == 1 {
            return true 
        } else {
            revert
        }
    }
}

impl AbiEncode for bool {
    fn encode(self, mut writer: MemoryBufferWriter) {
        if self {
            writer.write(value: 1)
        } else {
            writer.write(value: 0)
        }
    }
}

impl AbiDecode for address {
    fn decode(mut reader: CalldataReader) -> Self {
        let value: u256 = reader.read_u256()

        if value > 2 ^ 160 {
           revert 
        } else {
            return address(value)
        }
    }
}

impl AbiEncode for address {
    fn encode(self, mut writer: MemoryBufferWriter) {
        writer.write(value: u256(self))
    }
}

// // generic impl of array encoding
// impl AbiEncode for Array<T, N>
//     where 
//         T: AbiEncode
// {
//     fn encode(self, mut writer: MemoryBufferWriter) {
//         let i: usize = 0  

//         while i < N {
//             self[i].encode(buf)
//             i += 1
//         }
//     }
// }

// // generic impl of array decoding
// impl AbiDecode for Array<T, N>
//     where 
//         T: AbiDecode
// {
//     fn decode(mut reader: CalldataReader) -> Self {
//         let decoded_array: Self
//         let i: usize = 0  

//         while i < N {
//             decoded_array[i] = T::decode(buf)
//             i += 1
//         }

//         return decoded_array
//     }
// }

// // tuple encode derivation 
// impl AbiEncode for (T1, T2, ...)
//     where 
//         T1: AbiEncode
//         T2: AbiEncode
//         ...
// {
//     fn encode(self, mut writer: MemoryBufferWriter) {
//         self.item0.encode(writer)
//         self.item1.encode(writer)
//         ...
//     }
// }

// // tuple decode derivation
// impl AbiDecode for (T1, T2, ...)
//     where 
//        T1: AbiDecode 
//        T1: AbiDecode 
//        ...
// {
//     fn decode(mut reader: CalldataReader) -> Self {
//         return (
//             u256::decode(reader), 
//             u256::decode(reader)
//             ...
//         )
//     }
// }