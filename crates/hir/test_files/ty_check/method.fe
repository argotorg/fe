mod evm {
    extern {
        pub fn abort() -> !
    }
}

pub fn todo() -> ! {
    evm::abort()
}

pub enum Option<T> {
    None,
    Some(T)
}

impl<T> Option<T> {
    pub fn and<U>(self: own Self, rhs: own Option<U>) -> Option<U> {
        match self {
            Self::Some(t) => rhs
            Self::None => Option::None
        }
    }

    pub fn get_or_insert(mut self: own Self, inner: own T) -> T {
        match self {
            Self::Some(t) => t
            Self::None => {
                self = Self::Some(inner)
                inner
            }
        }
    }
}

impl Option {
    pub fn unwrap<T>(self: own Self<T>) -> T {
        match self {
            Self::None => evm::abort()
            Self::Some(t) => t
        }
    }
}

fn get_t<T>() -> T {
    todo()
}

fn foo() -> Option<bool> {
    let mut x: Option<i32> = Option::Some(1)
    let y: Option<i32> = Option::Some(2)
    let func_obj = get_t
    y.get_or_insert(inner: func_obj())

    x.and(rhs: Option::Some(false))
}
