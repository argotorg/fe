---
source: crates/hir/tests/ty_check.rs
assertion_line: 40
expression: res
input_file: test_files/ty_check/ops.fe
---
note: 
   ┌─ ops.fe:9:24
   │  
 9 │       fn not(self) -> Ok {
   │ ╭────────────────────────^
10 │ │         match self {
11 │ │             Ok::No => Ok::Yes
12 │ │             Ok::Yes => Ok::No
13 │ │         }
14 │ │     }
   │ ╰─────^ Ok

note: 
   ┌─ ops.fe:10:9
   │  
10 │ ╭         match self {
11 │ │             Ok::No => Ok::Yes
12 │ │             Ok::Yes => Ok::No
13 │ │         }
   │ ╰─────────^ Ok

note: 
   ┌─ ops.fe:10:15
   │
10 │         match self {
   │               ^^^^ Ok

note: 
   ┌─ ops.fe:11:13
   │
11 │             Ok::No => Ok::Yes
   │             ^^^^^^ Ok

note: 
   ┌─ ops.fe:11:23
   │
11 │             Ok::No => Ok::Yes
   │                       ^^^^^^^ Ok

note: 
   ┌─ ops.fe:12:13
   │
12 │             Ok::Yes => Ok::No
   │             ^^^^^^^ Ok

note: 
   ┌─ ops.fe:12:24
   │
12 │             Ok::Yes => Ok::No
   │                        ^^^^^^ Ok

note: 
   ┌─ ops.fe:17:23
   │  
17 │   fn flip(ok: Ok) -> Ok {
   │ ╭───────────────────────^
18 │ │     !ok
19 │ │ }
   │ ╰─^ Ok

note: 
   ┌─ ops.fe:18:5
   │
18 │     !ok
   │     ^^^ Ok

note: 
   ┌─ ops.fe:18:6
   │
18 │     !ok
   │      ^^ Ok

note: 
   ┌─ ops.fe:22:38
   │  
22 │       fn eq(self, _ other: Ok) -> bool {
   │ ╭──────────────────────────────────────^
23 │ │         match (self, other) {
24 │ │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
25 │ │             _ => false
26 │ │          }
27 │ │     }
   │ ╰─────^ bool

note: 
   ┌─ ops.fe:23:9
   │  
23 │ ╭         match (self, other) {
24 │ │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
25 │ │             _ => false
26 │ │          }
   │ ╰──────────^ bool

note: 
   ┌─ ops.fe:23:15
   │
23 │         match (self, other) {
   │               ^^^^^^^^^^^^^ (Ok, Ok)

note: 
   ┌─ ops.fe:23:16
   │
23 │         match (self, other) {
   │                ^^^^ Ok

note: 
   ┌─ ops.fe:23:22
   │
23 │         match (self, other) {
   │                      ^^^^^ Ok

note: 
   ┌─ ops.fe:24:13
   │
24 │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
   │             ^^^^^^^^^^^^^^^^^^ (Ok, Ok)

note: 
   ┌─ ops.fe:24:13
   │
24 │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (Ok, Ok)

note: 
   ┌─ ops.fe:24:14
   │
24 │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
   │              ^^^^^^^ Ok

note: 
   ┌─ ops.fe:24:23
   │
24 │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
   │                       ^^^^^^^ Ok

note: 
   ┌─ ops.fe:24:34
   │
24 │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
   │                                  ^^^^^^^^^^^^^^^^ (Ok, Ok)

note: 
   ┌─ ops.fe:24:35
   │
24 │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
   │                                   ^^^^^^ Ok

note: 
   ┌─ ops.fe:24:43
   │
24 │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
   │                                           ^^^^^^ Ok

note: 
   ┌─ ops.fe:24:54
   │
24 │             (Ok::Yes, Ok::Yes) | (Ok::No, Ok::No) => true
   │                                                      ^^^^ bool

note: 
   ┌─ ops.fe:25:13
   │
25 │             _ => false
   │             ^ (Ok, Ok)

note: 
   ┌─ ops.fe:25:18
   │
25 │             _ => false
   │                  ^^^^^ bool

note: 
   ┌─ ops.fe:28:38
   │  
28 │       fn ne(self, _ other: Ok) -> bool {
   │ ╭──────────────────────────────────────^
29 │ │         !self.eq(other)
30 │ │     }
   │ ╰─────^ bool

note: 
   ┌─ ops.fe:29:9
   │
29 │         !self.eq(other)
   │         ^^^^^^^^^^^^^^^ bool

note: 
   ┌─ ops.fe:29:10
   │
29 │         !self.eq(other)
   │          ^^^^ Ok

note: 
   ┌─ ops.fe:29:10
   │
29 │         !self.eq(other)
   │          ^^^^^^^^^^^^^^ bool

note: 
   ┌─ ops.fe:29:18
   │
29 │         !self.eq(other)
   │                  ^^^^^ Ok

note: 
   ┌─ ops.fe:34:44
   │  
34 │       fn add_assign(self, _ other: Ok) -> Ok {
   │ ╭────────────────────────────────────────────^
35 │ │         if other == Ok::Yes {
36 │ │             Ok::Yes
37 │ │         } else {
38 │ │             self
39 │ │         }
40 │ │     }
   │ ╰─────^ Ok

note: 
   ┌─ ops.fe:35:9
   │  
35 │ ╭         if other == Ok::Yes {
36 │ │             Ok::Yes
37 │ │         } else {
38 │ │             self
39 │ │         }
   │ ╰─────────^ Ok

note: 
   ┌─ ops.fe:35:12
   │
35 │         if other == Ok::Yes {
   │            ^^^^^ Ok

note: 
   ┌─ ops.fe:35:12
   │
35 │         if other == Ok::Yes {
   │            ^^^^^^^^^^^^^^^^ bool

note: 
   ┌─ ops.fe:35:21
   │
35 │         if other == Ok::Yes {
   │                     ^^^^^^^ Ok

note: 
   ┌─ ops.fe:35:29
   │  
35 │           if other == Ok::Yes {
   │ ╭─────────────────────────────^
36 │ │             Ok::Yes
37 │ │         } else {
   │ ╰─────────^ Ok

note: 
   ┌─ ops.fe:36:13
   │
36 │             Ok::Yes
   │             ^^^^^^^ Ok

note: 
   ┌─ ops.fe:37:16
   │  
37 │           } else {
   │ ╭────────────────^
38 │ │             self
39 │ │         }
   │ ╰─────────^ Ok

note: 
   ┌─ ops.fe:38:13
   │
38 │             self
   │             ^^^^ Ok

note: 
   ┌─ ops.fe:49:39
   │  
49 │       fn add(self, _ p: Point) -> Point {
   │ ╭───────────────────────────────────────^
50 │ │         Point {
51 │ │             x: self.x + p.x,
52 │ │             y: self.y + p.y,
53 │ │         }
54 │ │     }
   │ ╰─────^ Point

note: 
   ┌─ ops.fe:50:9
   │  
50 │ ╭         Point {
51 │ │             x: self.x + p.x,
52 │ │             y: self.y + p.y,
53 │ │         }
   │ ╰─────────^ Point

note: 
   ┌─ ops.fe:51:16
   │
51 │             x: self.x + p.x,
   │                ^^^^ Point

note: 
   ┌─ ops.fe:51:16
   │
51 │             x: self.x + p.x,
   │                ^^^^^^ i32

note: 
   ┌─ ops.fe:51:16
   │
51 │             x: self.x + p.x,
   │                ^^^^^^^^^^^^ i32

note: 
   ┌─ ops.fe:51:25
   │
51 │             x: self.x + p.x,
   │                         ^ Point

note: 
   ┌─ ops.fe:51:25
   │
51 │             x: self.x + p.x,
   │                         ^^^ i32

note: 
   ┌─ ops.fe:52:16
   │
52 │             y: self.y + p.y,
   │                ^^^^ Point

note: 
   ┌─ ops.fe:52:16
   │
52 │             y: self.y + p.y,
   │                ^^^^^^ i32

note: 
   ┌─ ops.fe:52:16
   │
52 │             y: self.y + p.y,
   │                ^^^^^^^^^^^^ i32

note: 
   ┌─ ops.fe:52:25
   │
52 │             y: self.y + p.y,
   │                         ^ Point

note: 
   ┌─ ops.fe:52:25
   │
52 │             y: self.y + p.y,
   │                         ^^^ i32

note: 
   ┌─ ops.fe:58:37
   │  
58 │       fn add(self, _ n: i32) -> Point {
   │ ╭─────────────────────────────────────^
59 │ │         Point {
60 │ │             x: self.x + n,
61 │ │             y: self.y + n,
62 │ │         }
63 │ │     }
   │ ╰─────^ Point

note: 
   ┌─ ops.fe:59:9
   │  
59 │ ╭         Point {
60 │ │             x: self.x + n,
61 │ │             y: self.y + n,
62 │ │         }
   │ ╰─────────^ Point

note: 
   ┌─ ops.fe:60:16
   │
60 │             x: self.x + n,
   │                ^^^^ Point

note: 
   ┌─ ops.fe:60:16
   │
60 │             x: self.x + n,
   │                ^^^^^^ i32

note: 
   ┌─ ops.fe:60:16
   │
60 │             x: self.x + n,
   │                ^^^^^^^^^^ i32

note: 
   ┌─ ops.fe:60:25
   │
60 │             x: self.x + n,
   │                         ^ i32

note: 
   ┌─ ops.fe:61:16
   │
61 │             y: self.y + n,
   │                ^^^^ Point

note: 
   ┌─ ops.fe:61:16
   │
61 │             y: self.y + n,
   │                ^^^^^^ i32

note: 
   ┌─ ops.fe:61:16
   │
61 │             y: self.y + n,
   │                ^^^^^^^^^^ i32

note: 
   ┌─ ops.fe:61:25
   │
61 │             y: self.y + n,
   │                         ^ i32

note: 
   ┌─ ops.fe:68:47
   │  
68 │       fn index(self, _ i: usize) -> Option<i32> {
   │ ╭───────────────────────────────────────────────^
69 │ │         match i {
70 │ │             0 => Some(self.x)
71 │ │             1 => Some(self.y)
72 │ │             _ => None
73 │ │         }
74 │ │     }
   │ ╰─────^ Option<i32>

note: 
   ┌─ ops.fe:69:9
   │  
69 │ ╭         match i {
70 │ │             0 => Some(self.x)
71 │ │             1 => Some(self.y)
72 │ │             _ => None
73 │ │         }
   │ ╰─────────^ Option<i32>

note: 
   ┌─ ops.fe:69:15
   │
69 │         match i {
   │               ^ usize

note: 
   ┌─ ops.fe:70:13
   │
70 │             0 => Some(self.x)
   │             ^ usize

note: 
   ┌─ ops.fe:70:18
   │
70 │             0 => Some(self.x)
   │                  ^^^^ fn Some<i32>

note: 
   ┌─ ops.fe:70:18
   │
70 │             0 => Some(self.x)
   │                  ^^^^^^^^^^^^ Option<i32>

note: 
   ┌─ ops.fe:70:23
   │
70 │             0 => Some(self.x)
   │                       ^^^^ Point

note: 
   ┌─ ops.fe:70:23
   │
70 │             0 => Some(self.x)
   │                       ^^^^^^ i32

note: 
   ┌─ ops.fe:71:13
   │
71 │             1 => Some(self.y)
   │             ^ usize

note: 
   ┌─ ops.fe:71:18
   │
71 │             1 => Some(self.y)
   │                  ^^^^ fn Some<i32>

note: 
   ┌─ ops.fe:71:18
   │
71 │             1 => Some(self.y)
   │                  ^^^^^^^^^^^^ Option<i32>

note: 
   ┌─ ops.fe:71:23
   │
71 │             1 => Some(self.y)
   │                       ^^^^ Point

note: 
   ┌─ ops.fe:71:23
   │
71 │             1 => Some(self.y)
   │                       ^^^^^^ i32

note: 
   ┌─ ops.fe:72:13
   │
72 │             _ => None
   │             ^ usize

note: 
   ┌─ ops.fe:72:18
   │
72 │             _ => None
   │                  ^^^^ Option<i32>

note: 
   ┌─ ops.fe:77:26
   │  
77 │   fn f(a: Point, b: Point) {
   │ ╭──────────────────────────^
78 │ │     let c = a + b
79 │ │     let c2 = Add::add(a, b)
80 │ │     // let c3 = Add::add(a, 100) TODO: fix `type annotation is needed`
81 │ │     let d = c + as_i32(100)
82 │ │     let x = d[0]
83 │ │ }
   │ ╰─^ ()

note: 
   ┌─ ops.fe:78:9
   │
78 │     let c = a + b
   │         ^ Point

note: 
   ┌─ ops.fe:78:13
   │
78 │     let c = a + b
   │             ^ Point

note: 
   ┌─ ops.fe:78:13
   │
78 │     let c = a + b
   │             ^^^^^ Point

note: 
   ┌─ ops.fe:78:17
   │
78 │     let c = a + b
   │                 ^ Point

note: 
   ┌─ ops.fe:79:9
   │
79 │     let c2 = Add::add(a, b)
   │         ^^ Point

note: 
   ┌─ ops.fe:79:14
   │
79 │     let c2 = Add::add(a, b)
   │              ^^^^^^^^ fn add<Point, Point>

note: 
   ┌─ ops.fe:79:14
   │
79 │     let c2 = Add::add(a, b)
   │              ^^^^^^^^^^^^^^ Point

note: 
   ┌─ ops.fe:79:23
   │
79 │     let c2 = Add::add(a, b)
   │                       ^ Point

note: 
   ┌─ ops.fe:79:26
   │
79 │     let c2 = Add::add(a, b)
   │                          ^ Point

note: 
   ┌─ ops.fe:81:9
   │
81 │     let d = c + as_i32(100)
   │         ^ Point

note: 
   ┌─ ops.fe:81:13
   │
81 │     let d = c + as_i32(100)
   │             ^ Point

note: 
   ┌─ ops.fe:81:13
   │
81 │     let d = c + as_i32(100)
   │             ^^^^^^^^^^^^^^^ Point

note: 
   ┌─ ops.fe:81:17
   │
81 │     let d = c + as_i32(100)
   │                 ^^^^^^ fn as_i32

note: 
   ┌─ ops.fe:81:17
   │
81 │     let d = c + as_i32(100)
   │                 ^^^^^^^^^^^ i32

note: 
   ┌─ ops.fe:81:24
   │
81 │     let d = c + as_i32(100)
   │                        ^^^ i32

note: 
   ┌─ ops.fe:82:9
   │
82 │     let x = d[0]
   │         ^ Option<i32>

note: 
   ┌─ ops.fe:82:13
   │
82 │     let x = d[0]
   │             ^ Point

note: 
   ┌─ ops.fe:82:13
   │
82 │     let x = d[0]
   │             ^^^^ Option<i32>

note: 
   ┌─ ops.fe:82:15
   │
82 │     let x = d[0]
   │               ^ usize

note: 
   ┌─ ops.fe:85:28
   │
85 │ fn as_i32(_ x: i32) -> i32 { x }
   │                            ^^^^^ i32

note: 
   ┌─ ops.fe:85:30
   │
85 │ fn as_i32(_ x: i32) -> i32 { x }
   │                              ^ i32
