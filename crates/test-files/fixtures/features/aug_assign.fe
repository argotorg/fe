contract Foo {
    my_num: u256

    pub fn add(mut a: u256, b: u256) -> u256 {
        a += b
        return a
    }

    pub fn sub(mut a: u256, b: u256) -> u256 {
        a -= b
        return a
    }

    pub fn mul(mut a: u256, b: u256) -> u256 {
        a *= b
        return a
    }

    pub fn div(mut a: u256, b: u256) -> u256 {
        a /= b
        return a
    }

    pub fn mod(mut a: u256, b: u256) -> u256 {
        a %= b
        return a
    }

    pub fn pow(mut a: u256, b: u256) -> u256 {
        a **= b
        return a
    }

    pub fn lshift(mut a: u8, b: u8) -> u8 {
        a <<= b
        return a
    }

    pub fn rshift(mut a: u8, b: u8) -> u8 {
        a >>= b
        return a
    }

    pub fn bit_or(mut a: u8, b: u8) -> u8 {
        a |= b
        return a
    }

    pub fn bit_xor(mut a: u8, b: u8) -> u8 {
        a ^= b
        return a
    }

    pub fn bit_and(mut a: u8, b: u8) -> u8 {
        a &= b
        return a
    }

    pub fn add_from_sto(mut self, a: u256, b: u256) -> u256 {
        self.my_num = a
        self.my_num += b
        return self.my_num
    }

    pub fn add_from_mem(a: u256, b: u256) -> u256 {
        let mut my_array: Array<u256, 10> = [0; 10]
        my_array[7] = a
        my_array[7] += b
        return my_array[7]
    }
}
