use core::intrinsic

struct Agg {
    a: u8,
    b: u8,
}

const fn make_agg() -> Agg {
    Agg { a: 3, b: 2 }
}

const fn agg_len() -> usize {
    let agg = make_agg()
    agg.a as usize
}

const fn add(a: usize, b: usize) -> usize {
    a + b
}

const fn pick(flag: bool) -> usize {
    if flag {
        1
    } else {
        2
    }
}

const fn bytes_tail() -> usize {
    let xs: [u16; 2] = [258, 772]
    let bytes: [u8; 4] = intrinsic::__as_bytes(xs)
    bytes[3] as usize
}

enum AddrSpace {
    Mem,
    Stor,
    Tran,
}

const fn stor_code() -> usize {
    let bytes: [u8; 32] = intrinsic::__as_bytes(AddrSpace::Stor)
    (bytes[0] as usize) * 2 + (bytes[31] as usize)
}

type Arr = [u8; add(pick(true), pick(false))]
type ArrBytes = [u8; bytes_tail()]
type StorCode = [u8; stor_code()]
type AggArr = [u8; agg_len()]

fn takes_arr(_x: Arr) {}
fn takes_bytes(_x: ArrBytes) {}
fn takes_stor(_x: StorCode) {}
fn takes_agg(_x: AggArr) {}

fn ok(a: Arr, b: ArrBytes, c: StorCode, d: AggArr) {
    takes_arr(a)
    takes_bytes(b)
    takes_stor(c)
    takes_agg(d)
}
