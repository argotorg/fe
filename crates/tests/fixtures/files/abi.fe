// error: cannot glob import from ingot
// use std::{abi::Abi, evm}
use std::abi::{AbiDecode, AbiEncode}
use std::context::{Context, CalldataReader}
use std::buf::{
    MemoryBuffer, 
    MemoryBufferWriter, 
    MemoryBufferReader,
    RawCallBuffer
}
use std::evm
use std::traits::Max

contract AbiDecodeU256 {
    pub unsafe fn __call__(ctx: Context) {
        let mut reader: CalldataReader = ctx.calldata_reader()
        let value: u256 = u256::decode(reader)

        let mut buf: MemoryBuffer = MemoryBuffer::new(len: 32)
        let mut writer: MemoryBufferWriter = buf.writer()
        writer.write(value)

        evm::return_mem(buf)
    }
}

contract AbiDecodeU128 {
    pub unsafe fn __call__(ctx: Context) {
        let mut reader: CalldataReader = ctx.calldata_reader()
        let value: u128 = u128::decode(reader)

        let mut buf: MemoryBuffer = MemoryBuffer::new(len: 32)
        let mut writer: MemoryBufferWriter = buf.writer()
        writer.write(value)

        evm::return_mem(buf)
    }
}

// #test
// unsafe fn u256_decode() {
//     let mut buf: MemoryBuffer = MemoryBuffer::new(len: 64)

//     let mut writer: MemoryBufferWriter = buf.writer()
//     writer.write(value: 26)
//     writer.write(value: 42)

//     let mut reader: MemoryBufferReader = buf.reader()
//     assert u256::decode(reader) == 26
//     assert u256::decode(reader) == 42 
// }

#test
fn u256_encode() {
    let mut buf: MemoryBuffer = MemoryBuffer::new(len: 64)

    let mut writer: MemoryBufferWriter = buf.writer()
    26.encode(writer)
    42.encode(writer) 

    let mut reader: MemoryBufferReader = buf.reader()
    assert reader.read_u256() == 26
    assert reader.read_u256() == 42
}

#test
fn u256_decode(mut ctx: Context) {
    let decoder: address = address(AbiDecodeU256.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: 42)

    ctx.raw_call(addr: decoder, value: 0, buf)

    let mut reader: MemoryBufferReader = buf.reader()
    assert reader.read_u256() == 42
}

#test
fn u128_decode_invalid(mut ctx: Context) {
    let decoder: address = address(AbiDecodeU128.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: u256::max())

    assert not ctx.raw_call(addr: decoder, value: 0, buf)
}


// type MyArray = Array<u256, 2>
// type MyTuple = (u256, u256) 

// #test
// unsafe fn array_decode() {
//     evm::mstore(offset: HASH_SCRATCH_SPACE_START, value: 26)
//     evm::mstore(offset: HASH_SCRATCH_SPACE_START + 32, value: 42)

//     let mut buf: MemoryBuffer = MemoryBuffer::new(
//         start: HASH_SCRATCH_SPACE_START, 
//         end: HASH_SCRATCH_SPACE_START + HASH_SCRATCH_SPACE_SIZE
//     )

//     // parser panics
//     // let my_array:  = Array<u256, 2>::decode(buf)
//     let my_array: MyArray = MyArray::decode(buf)
//     assert my_array[0] == 26
//     assert my_array[1] == 42 
// }

// #test
// unsafe fn tuple_decode() {
//     evm::mstore(offset: HASH_SCRATCH_SPACE_START, value: 26)
//     evm::mstore(offset: HASH_SCRATCH_SPACE_START + 32, value: 42)

//     let mut buf: MemoryBuffer = MemoryBuffer::new(
//         start: HASH_SCRATCH_SPACE_START, 
//         end: HASH_SCRATCH_SPACE_START + HASH_SCRATCH_SPACE_SIZE
//     )

//     // parser panics
//     // let my_tuple: (u256, u256) = (u256, u256)::decode(buf)
//     let my_tuple: MyTuple = MyTuple::decode(buf)
//     assert my_tuple.item0 == 26
//     assert my_tuple.item1 == 42
// }
