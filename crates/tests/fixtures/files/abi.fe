use std::abi::{AbiDecode, AbiEncode}
use std::context::{Context, CalldataReader}
use std::buf::{
    MemoryBuffer, 
    MemoryBufferWriter, 
    MemoryBufferReader,
    RawCallBuffer
}
use std::evm
use std::traits::Max

contract AbiDecodeU256 {
    pub unsafe fn __call__(ctx: Context) {
        let mut reader: CalldataReader = ctx.calldata_reader()
        let value: u256 = u256::decode(reader)

        let mut buf: MemoryBuffer = MemoryBuffer::new(len: 32)
        let mut writer: MemoryBufferWriter = buf.writer()
        value.encode(writer) 

        evm::return_mem(buf)
    }
}

contract AbiDecodeU128 {
    pub unsafe fn __call__(ctx: Context) {
        let mut reader: CalldataReader = ctx.calldata_reader()
        let value: u128 = u128::decode(reader)

        let mut buf: MemoryBuffer = MemoryBuffer::new(len: 32)
        let mut writer: MemoryBufferWriter = buf.writer()
        value.encode(writer) 

        evm::return_mem(buf)
    }
}

contract AbiDecodeAddress {
    pub unsafe fn __call__(ctx: Context) {
        let mut reader: CalldataReader = ctx.calldata_reader()
        let value: address = address::decode(reader)

        let mut buf: MemoryBuffer = MemoryBuffer::new(len: 32)
        let mut writer: MemoryBufferWriter = buf.writer()
        value.encode(writer) 

        evm::return_mem(buf)
    }
}

contract AbiDecodeBool {
    pub unsafe fn __call__(ctx: Context) {
        let mut reader: CalldataReader = ctx.calldata_reader()
        let value: bool = bool::decode(reader)

        let mut buf: MemoryBuffer = MemoryBuffer::new(len: 32)
        let mut writer: MemoryBufferWriter = buf.writer()
        value.encode(writer) 

        evm::return_mem(buf)
    }
}

#test
fn u256_abi(mut ctx: Context) {
    let decoder: address = address(AbiDecodeU256.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: 42)

    ctx.raw_call(addr: decoder, value: 0, buf)

    let mut reader: MemoryBufferReader = buf.reader()
    assert reader.read_u256() == 42
}

#test
fn u128_abi(mut ctx: Context) {
    let decoder: address = address(AbiDecodeU128.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: 42)

    assert ctx.raw_call(addr: decoder, value: 0, buf)

    let mut reader: MemoryBufferReader = buf.reader()
    assert reader.read_u256() == 42
}

#test
fn u128_abi_invalid(mut ctx: Context) {
    let decoder: address = address(AbiDecodeU128.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: u256(u128::max()) + 1)

    assert not ctx.raw_call(addr: decoder, value: 0, buf)
}

#test
fn address_abi(mut ctx: Context) {
    let decoder: address = address(AbiDecodeAddress.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: 42)

    assert ctx.raw_call(addr: decoder, value: 0, buf)

    let mut reader: MemoryBufferReader = buf.reader()
    assert reader.read_u256() == 42
}

#test
fn address_abi_invalid(mut ctx: Context) {
    let decoder: address = address(AbiDecodeAddress.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: u256::max())

    assert not ctx.raw_call(addr: decoder, value: 0, buf)
}

#test
fn bool_abi(mut ctx: Context) {
    let decoder: address = address(AbiDecodeBool.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: 1)

    assert ctx.raw_call(addr: decoder, value: 0, buf)

    let mut reader: MemoryBufferReader = buf.reader()
    assert reader.read_u256() == 1 
}

#test
fn bool_abi_invalid(mut ctx: Context) {
    let decoder: address = address(AbiDecodeBool.create(ctx, 0))
    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )

    let mut writer: MemoryBufferWriter = buf.writer()
    writer.write(value: 3)

    assert not ctx.raw_call(addr: decoder, value: 0, buf)
}

// type MyArray = Array<u256, 2>
// type MyTuple = (u256, u256) 

// #test
// unsafe fn array_decode() {
//     evm::mstore(offset: HASH_SCRATCH_SPACE_START, value: 26)
//     evm::mstore(offset: HASH_SCRATCH_SPACE_START + 32, value: 42)

//     let mut buf: MemoryBuffer = MemoryBuffer::new(
//         start: HASH_SCRATCH_SPACE_START, 
//         end: HASH_SCRATCH_SPACE_START + HASH_SCRATCH_SPACE_SIZE
//     )

//     // parser panics
//     // let my_array:  = Array<u256, 2>::decode(buf)
//     let my_array: MyArray = MyArray::decode(buf)
//     assert my_array[0] == 26
//     assert my_array[1] == 42 
// }

// #test
// unsafe fn tuple_decode() {
//     evm::mstore(offset: HASH_SCRATCH_SPACE_START, value: 26)
//     evm::mstore(offset: HASH_SCRATCH_SPACE_START + 32, value: 42)

//     let mut buf: MemoryBuffer = MemoryBuffer::new(
//         start: HASH_SCRATCH_SPACE_START, 
//         end: HASH_SCRATCH_SPACE_START + HASH_SCRATCH_SPACE_SIZE
//     )

//     // parser panics
//     // let my_tuple: (u256, u256) = (u256, u256)::decode(buf)
//     let my_tuple: MyTuple = MyTuple::decode(buf)
//     assert my_tuple.item0 == 26
//     assert my_tuple.item1 == 42
// }
