/// Ownership pattern with access-controlled functions.
/// Inspired by OpenZeppelin's Ownable contract.
///
/// Tests: ctx.caller() in init, address-based authorization, cross-contract
/// calls via proxy, ownership transfer.

use std::evm::{Address, Evm, Call, Ctx}
use std::evm::effects::assert

msg OwnableMsg {
    #[selector = 0x01]
    TransferOwnership { new_owner_inner: u256 },
    #[selector = 0x02]
    ProtectedIncrement -> u256,
    #[selector = 0x03]
    GetCount -> u256,
    #[selector = 0x04]
    GetOwner -> u256,
}

struct OwnableStore {
    owner_inner: u256,
    count: u256,
}

pub contract Ownable uses (ctx: Ctx) {
    mut store: OwnableStore

    init() uses (mut store, ctx) {
        store.owner_inner = ctx.caller().inner
        store.count = 0
    }

    recv OwnableMsg {
        TransferOwnership { new_owner_inner } uses (mut store, ctx) {
            if ctx.caller().inner == store.owner_inner {
                store.owner_inner = new_owner_inner
            }
        }

        ProtectedIncrement -> u256 uses (mut store, ctx) {
            if ctx.caller().inner != store.owner_inner {
                return 0
            }
            store.count += 1
            store.count
        }

        GetCount -> u256 uses (store) {
            store.count
        }

        GetOwner -> u256 uses (store) {
            store.owner_inner
        }
    }
}

/// Helper: calls Ownable methods from a different address.
msg ProxyMsg {
    #[selector = 0x10]
    TryIncrement { target: Address } -> u256,
}

pub contract NonOwnerCaller uses (call: mut Call) {
    recv ProxyMsg {
        TryIncrement { target } -> u256 uses (mut call) {
            call.call(
                addr: target,
                gas: 100000,
                value: 0,
                message: OwnableMsg::ProtectedIncrement {},
            )
        }
    }
}

#[test]
fn test_ownable() uses (evm: mut Evm) {
    // Deploy â€” test runner becomes owner via ctx.caller() in init
    let ownable = evm.create2<Ownable>(value: 0, args: (), salt: 0)
    assert(ownable.inner != 0)

    // Owner can increment
    let res: u256 = evm.call(addr: ownable, gas: 100000, value: 0, message: OwnableMsg::ProtectedIncrement {})
    assert(res == 1)
    let res: u256 = evm.call(addr: ownable, gas: 100000, value: 0, message: OwnableMsg::ProtectedIncrement {})
    assert(res == 2)

    // Deploy a proxy (different address)
    let proxy = evm.create2<NonOwnerCaller>(value: 0, args: (), salt: 1)
    assert(proxy.inner != 0)

    // Non-owner rejected (returns 0)
    let res: u256 = evm.call(addr: proxy, gas: 200000, value: 0, message: ProxyMsg::TryIncrement { target: ownable })
    assert(res == 0)

    // Count unchanged
    let count: u256 = evm.call(addr: ownable, gas: 100000, value: 0, message: OwnableMsg::GetCount {})
    assert(count == 2)

    // Transfer ownership to proxy
    evm.call(addr: ownable, gas: 100000, value: 0, message: OwnableMsg::TransferOwnership { new_owner_inner: proxy.inner })

    // Test runner no longer owner
    let res: u256 = evm.call(addr: ownable, gas: 100000, value: 0, message: OwnableMsg::ProtectedIncrement {})
    assert(res == 0)

    // Proxy is new owner
    let res: u256 = evm.call(addr: proxy, gas: 200000, value: 0, message: ProxyMsg::TryIncrement { target: ownable })
    assert(res == 3)
}
