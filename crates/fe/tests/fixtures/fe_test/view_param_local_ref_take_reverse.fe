use std::evm::effects::assert
use ingot::seq::Seq

struct Reverse<I, T: Seq<I>> {
    base: ref T,
}

struct Take<I, T: Seq<I>> {
    n: usize,
    base: ref T,
}

fn reverse<I, T: Seq<I>>(seq: ref T) -> Reverse<I, T> {
    Reverse { base: seq }
}

fn take<I, T: Seq<I>>(n: usize, seq: ref T) -> Take<I, T> {
    Take { n, base: seq }
}

impl<I, T: Seq<I>> Seq<I> for Reverse<I, T> {
    fn len(self) -> usize {
        self.base.len()
    }

    fn get(self, i: usize) -> I {
        let n = self.base.len()
        self.base.get(n - 1 - i)
    }
}

impl<I, T: Seq<I>> Seq<I> for Take<I, T> {
    fn len(self) -> usize {
        let total = self.base.len()
        if self.n < total {
            self.n
        } else {
            total
        }
    }

    fn get(self, i: usize) -> I {
        self.base.get(i)
    }
}

fn sum_last4(arr: [u256; 8]) -> u256 {
    let total = 0
    for x in take(4, reverse(arr)) {
        total += x
    }
    total
}

#[test]
fn test_view_param_local_ref_take_reverse() {
    let arr: [u256; 8] = [1, 2, 3, 4, 5, 6, 7, 8]
    assert(sum_last4(arr) == 26)
}
