use std::evm::effects::assert

struct Reverse<I, T: core::Seq<I> + core::Copy> {
    base: ref T,
}

struct Take<I, T: core::Seq<I> + core::Copy> {
    n: usize,
    base: ref T,
}

impl<I, T: core::Seq<I> + core::Copy> core::Copy for Reverse<I, T> {}
impl<I, T: core::Seq<I> + core::Copy> core::Copy for Take<I, T> {}

fn reverse<I, T: core::Seq<I> + core::Copy>(seq: ref T) -> Reverse<I, T> {
    Reverse { base: seq }
}

fn take<I, T: core::Seq<I> + core::Copy>(n: usize, seq: ref T) -> Take<I, T> {
    Take { n, base: seq }
}

fn reverse_u256<T: core::Seq<u256> + core::Copy>(seq: ref T) -> Reverse<u256, T> {
    reverse(seq)
}

fn take_u256<T: core::Seq<u256> + core::Copy>(n: usize, seq: ref T) -> Take<u256, T> {
    take(n, seq)
}

impl<I, T: core::Seq<I> + core::Copy> core::Seq<I> for Reverse<I, T> {
    fn len(self) -> usize {
        let base: T = self.base
        base.len()
    }

    fn get(self, i: usize) -> I {
        let base: T = self.base
        let n = base.len()
        base.get(n - 1 - i)
    }
}

impl<I, T: core::Seq<I> + core::Copy> core::Seq<I> for Take<I, T> {
    fn len(self) -> usize {
        let base: T = self.base
        let total = base.len()
        if self.n < total {
            self.n
        } else {
            total
        }
    }

    fn get(self, i: usize) -> I {
        let base: T = self.base
        base.get(i)
    }
}

fn sum_last4(arr: [u256; 8]) -> u256 {
    let mut total = 0
    let rev = reverse_u256(ref arr)
    let tail = take_u256(4, ref rev)
    for x in tail {
        total += x
    }
    total
}

fn sum_first4(arr: [u256; 8]) -> u256 {
    let mut total = 0
    let head = take_u256(4, ref arr)
    for x in head {
        total += x
    }
    total
}

#[test]
fn test_view_param_local_ref_take_reverse() {
    let arr: [u256; 8] = [1, 2, 3, 4, 5, 6, 7, 8]
    assert(sum_last4(arr) == 26)
    assert(sum_first4(arr) == 10)
}
