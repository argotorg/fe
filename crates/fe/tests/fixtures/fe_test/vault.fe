/// Proportional share vault (ERC-4626 inspired).
/// Deposit assets to receive shares; withdraw shares to receive assets.
/// Per-user share tracking via StorageMap<Address, u256>.
///
/// Tests: if-expressions, proportional math, per-user StorageMap with Address
/// keys, ctx.caller() identity, multi-user via proxy contract.

use std::evm::{Address, Evm, Call, Ctx, StorageMap}
use std::evm::effects::assert

msg VaultMsg {
    #[selector = 0x01]
    Deposit { amount: u256 } -> u256,
    #[selector = 0x02]
    Withdraw { shares: u256 } -> u256,
    #[selector = 0x03]
    AddYield { amount: u256 },
    #[selector = 0x04]
    GetTotalAssets -> u256,
    #[selector = 0x05]
    GetTotalShares -> u256,
    #[selector = 0x06]
    GetMyShares -> u256,
}

struct VaultStore {
    total_assets: u256,
    total_shares: u256,
    user_shares: StorageMap<Address, u256, 0>,
}

pub contract Vault uses (ctx: Ctx) {
    mut store: VaultStore

    init() uses (mut store) {
        store.total_assets = 0
        store.total_shares = 0
    }

    recv VaultMsg {
        Deposit { amount } -> u256 uses (mut store, ctx) {
            if amount == 0 {
                return 0
            }
            let shares = if store.total_shares == 0 {
                amount
            } else {
                amount * store.total_shares / store.total_assets
            }
            store.total_assets += amount
            store.total_shares += shares
            let caller = ctx.caller()
            let current = store.user_shares.get(key: caller)
            store.user_shares.set(key: caller, value: current + shares)
            shares
        }

        Withdraw { shares } -> u256 uses (mut store, ctx) {
            if shares == 0 {
                return 0
            }
            if store.total_shares == 0 {
                return 0
            }
            let caller = ctx.caller()
            let user_bal = store.user_shares.get(key: caller)
            if shares > user_bal {
                return 0
            }
            let assets = shares * store.total_assets / store.total_shares
            store.total_shares -= shares
            store.total_assets -= assets
            store.user_shares.set(key: caller, value: user_bal - shares)
            assets
        }

        AddYield { amount } uses (mut store) {
            store.total_assets += amount
        }

        GetTotalAssets -> u256 uses (store) { store.total_assets }
        GetTotalShares -> u256 uses (store) { store.total_shares }

        GetMyShares -> u256 uses (store, ctx) {
            store.user_shares.get(key: ctx.caller())
        }
    }
}

/// Proxy to simulate a second user depositing/withdrawing.
msg VaultProxyMsg {
    #[selector = 0x10]
    ProxyDeposit { vault: Address, amount: u256 } -> u256,
    #[selector = 0x11]
    ProxyWithdraw { vault: Address, shares: u256 } -> u256,
    #[selector = 0x12]
    ProxyGetMyShares { vault: Address } -> u256,
}

pub contract VaultUser uses (mut call: Call) {
    recv VaultProxyMsg {
        ProxyDeposit { vault, amount } -> u256 uses (mut call) {
            call.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::Deposit { amount })
        }
        ProxyWithdraw { vault, shares } -> u256 uses (mut call) {
            call.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::Withdraw { shares })
        }
        ProxyGetMyShares { vault } -> u256 uses (mut call) {
            call.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::GetMyShares {})
        }
    }
}

#[test]
fn test_vault_multiuser() uses (mut evm: Evm) {
    let vault = evm.create2<Vault>(value: 0, args: (), salt: 0)
    assert(vault.inner != 0)

    let user2 = evm.create2<VaultUser>(value: 0, args: (), salt: 1)
    assert(user2.inner != 0)

    // User 1 (test runner) deposits 1000 -> 1000 shares (1:1 initial)
    let shares: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::Deposit { amount: 1000 })
    assert(shares == 1000)

    // User 2 deposits 1000 -> 1000 shares (same ratio)
    let shares: u256 = evm.call(addr: user2, gas: 200000, value: 0, message: VaultProxyMsg::ProxyDeposit { vault, amount: 1000 })
    assert(shares == 1000)

    // Total: 2000 assets, 2000 shares
    let ta: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::GetTotalAssets {})
    assert(ta == 2000)
    let ts: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::GetTotalShares {})
    assert(ts == 2000)

    // Yield accrues: +1000 assets
    evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::AddYield { amount: 1000 })
    // Total: 3000 assets, 2000 shares (1.5x price)

    // User 1 withdraws 500 shares -> 500 * 3000 / 2000 = 750 assets
    let assets: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::Withdraw { shares: 500 })
    assert(assets == 750)

    // User 1 has 500 shares left
    let my_shares: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::GetMyShares {})
    assert(my_shares == 500)

    // User 2 still has 1000 shares
    let u2_shares: u256 = evm.call(addr: user2, gas: 200000, value: 0, message: VaultProxyMsg::ProxyGetMyShares { vault })
    assert(u2_shares == 1000)

    // Total: 2250 assets, 1500 shares
    let ta: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::GetTotalAssets {})
    assert(ta == 2250)

    // User 2 can't withdraw more than they have
    let assets: u256 = evm.call(addr: user2, gas: 200000, value: 0, message: VaultProxyMsg::ProxyWithdraw { vault, shares: 9999 })
    assert(assets == 0)

    // User 2 withdraws all 1000 shares -> 1000 * 2250 / 1500 = 1500
    let assets: u256 = evm.call(addr: user2, gas: 200000, value: 0, message: VaultProxyMsg::ProxyWithdraw { vault, shares: 1000 })
    assert(assets == 1500)

    // User 1 withdraws remaining 500 -> 500 * 750 / 500 = 750
    let assets: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::Withdraw { shares: 500 })
    assert(assets == 750)

    // Vault empty
    let ta: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::GetTotalAssets {})
    assert(ta == 0)
    let ts: u256 = evm.call(addr: vault, gas: 100000, value: 0, message: VaultMsg::GetTotalShares {})
    assert(ts == 0)
}
