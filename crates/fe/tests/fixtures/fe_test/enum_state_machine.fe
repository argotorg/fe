/// Enum-based state machine stored in contract storage.
///
/// BUG (both backends): Reading a mutated enum variant from storage reverts.
/// The initial variant (discriminant 0) reads correctly, but after writing
/// a different variant and re-reading in a subsequent call, the match reverts.
/// This may be related to how enum discriminants are encoded in storage words.
///
/// The contract and commented-out tests below document the intended pattern.
/// Once the enum storage roundtrip bug is fixed, uncomment the lifecycle tests.

use std::evm::Evm
use std::evm::effects::assert

enum OrderStatus {
    Created,
    Confirmed,
    Shipped,
    Delivered,
    Cancelled,
}

msg OrderMsg {
    #[selector = 0x01]
    Confirm -> u256,
    #[selector = 0x02]
    Ship -> u256,
    #[selector = 0x03]
    Deliver -> u256,
    #[selector = 0x04]
    Cancel -> u256,
    #[selector = 0x05]
    Which -> u256,
}

struct OrderStore {
    status: OrderStatus,
}

pub contract Order {
    mut store: OrderStore

    init() uses (mut store) {
        store.status = OrderStatus::Created
    }

    recv OrderMsg {
        Confirm -> u256 uses (mut store) {
            match store.status {
                OrderStatus::Created => {
                    store.status = OrderStatus::Confirmed
                    return 0
                }
                _ => {
                    return 1
                }
            }
        }

        Ship -> u256 uses (mut store) {
            match store.status {
                OrderStatus::Confirmed => {
                    store.status = OrderStatus::Shipped
                    return 0
                }
                _ => {
                    return 1
                }
            }
        }

        Deliver -> u256 uses (mut store) {
            match store.status {
                OrderStatus::Shipped => {
                    store.status = OrderStatus::Delivered
                    return 0
                }
                _ => {
                    return 1
                }
            }
        }

        Cancel -> u256 uses (mut store) {
            match store.status {
                OrderStatus::Created => {
                    store.status = OrderStatus::Cancelled
                    return 0
                }
                OrderStatus::Confirmed => {
                    store.status = OrderStatus::Cancelled
                    return 0
                }
                _ => {
                    return 1
                }
            }
        }

        Which -> u256 uses (store) {
            match store.status {
                OrderStatus::Created => 0,
                OrderStatus::Confirmed => 1,
                OrderStatus::Shipped => 2,
                OrderStatus::Delivered => 3,
                OrderStatus::Cancelled => 4,
            }
        }
    }
}

// This test only exercises the initial state (variant 0), which works.
#[test]
fn test_order_initial_state() uses (mut evm: Evm) {
    let order = evm.create2<Order>(value: 0, args: (), salt: 0)
    assert(order.inner != 0)

    let s: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Which {})
    assert(s == 0)

    // The Confirm call itself succeeds (writes to storage),
    // but reading the mutated enum back in a subsequent call would revert.
    let r: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Confirm {})
    assert(r == 0)
}

// TODO: Uncomment once enum storage roundtrip bug is fixed.
//
// #[test]
// fn test_order_lifecycle() uses (mut evm: Evm) {
//     let order = evm.create2<Order>(value: 0, args: (), salt: 0)
//     assert(order.inner != 0)
//
//     let s: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Which {})
//     assert(s == 0)
//
//     // Created -> Confirmed
//     let r: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Confirm {})
//     assert(r == 0)
//     let s: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Which {})
//     assert(s == 1)
//
//     // Confirmed -> Shipped
//     let r: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Ship {})
//     assert(r == 0)
//     let s: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Which {})
//     assert(s == 2)
//
//     // Shipped -> Delivered
//     let r: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Deliver {})
//     assert(r == 0)
//     let s: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Which {})
//     assert(s == 3)
//
//     // Can't go backwards
//     let r: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Confirm {})
//     assert(r == 1)
// }
//
// #[test]
// fn test_order_cancellation() uses (mut evm: Evm) {
//     let order = evm.create2<Order>(value: 0, args: (), salt: 1)
//     assert(order.inner != 0)
//
//     let r: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Cancel {})
//     assert(r == 0)
//     let s: u256 = evm.call(addr: order, gas: 100000, value: 0, message: OrderMsg::Which {})
//     assert(s == 4)
// }
