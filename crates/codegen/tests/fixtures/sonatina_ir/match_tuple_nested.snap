---
source: crates/codegen/tests/sonatina_ir.rs
expression: output
input_file: crates/codegen/tests/fixtures/match_tuple_nested.fe
---
target = "evm-ethereum-osaka"

type @__fe_tuple_0 = {i256, i256};
type @__fe_tuple_1 = {@__fe_tuple_0, i256};
type @__fe_tuple_2 = {@__fe_tuple_1, i256};

func public %match_nested_tuple(v0.i256) -> i256 {
    block0:
        jump block7;

    block1:
        jump block2;

    block2:
        v3.i256 = phi (7.i256 block1) (6.i256 block3) (5.i256 block4) (2.i256 block5) (1.i256 block6);
        return v3;

    block3:
        jump block2;

    block4:
        jump block2;

    block5:
        jump block2;

    block6:
        jump block2;

    block7:
        v9.*@__fe_tuple_1 = int_to_ptr v0 *@__fe_tuple_1;
        v10.*i256 = gep v9 0.i256 0.i256 0.i256;
        v11.i256 = mload v10 i256;
        v12.i1 = ne v11 0.i256;
        v13.i256 = zext v12 i256;
        v14.i1 = eq v13 1.i256;
        br v14 block8 block15;

    block8:
        v17.*@__fe_tuple_1 = int_to_ptr v0 *@__fe_tuple_1;
        v18.*i256 = gep v17 0.i256 0.i256 1.i256;
        v19.i256 = mload v18 i256;
        v20.i1 = ne v19 0.i256;
        v21.i256 = zext v20 i256;
        v22.i1 = eq v21 1.i256;
        br v22 block9 block16;

    block9:
        v25.*@__fe_tuple_1 = int_to_ptr v0 *@__fe_tuple_1;
        v26.*i256 = gep v25 0.i256 1.i256;
        v27.i256 = mload v26 i256;
        v28.i1 = ne v27 0.i256;
        v29.i256 = zext v28 i256;
        v30.i1 = eq v29 1.i256;
        br v30 block1 block17;

    block10:
        evm_invalid;

    block11:
        evm_invalid;

    block12:
        v33.*@__fe_tuple_1 = int_to_ptr v0 *@__fe_tuple_1;
        v34.*i256 = gep v33 0.i256 1.i256;
        v35.i256 = mload v34 i256;
        v36.i1 = ne v35 0.i256;
        v37.i256 = zext v36 i256;
        v38.i1 = eq v37 1.i256;
        br v38 block5 block18;

    block13:
        evm_invalid;

    block14:
        evm_invalid;

    block15:
        v15.i1 = eq v13 0.i256;
        br v15 block12 block14;

    block16:
        v23.i1 = eq v21 0.i256;
        br v23 block4 block11;

    block17:
        v31.i1 = eq v29 0.i256;
        br v31 block3 block10;

    block18:
        v39.i1 = eq v37 0.i256;
        br v39 block6 block13;
}

func public %match_deeply_nested(v0.i256) -> i256 {
    block0:
        jump block5;

    block1:
        jump block2;

    block2:
        v3.i256 = phi (15.i256 block1) (8.i256 block3) (0.i256 block4);
        return v3;

    block3:
        jump block2;

    block4:
        jump block2;

    block5:
        v6.*@__fe_tuple_2 = int_to_ptr v0 *@__fe_tuple_2;
        v7.*i256 = gep v6 0.i256 0.i256 0.i256 0.i256;
        v8.i256 = mload v7 i256;
        v9.i1 = ne v8 0.i256;
        v10.i256 = zext v9 i256;
        v12.i1 = eq v10 1.i256;
        br v12 block6 block10;

    block6:
        v15.*@__fe_tuple_2 = int_to_ptr v0 *@__fe_tuple_2;
        v16.*i256 = gep v15 0.i256 1.i256;
        v17.i256 = mload v16 i256;
        v18.i1 = ne v17 0.i256;
        v19.i256 = zext v18 i256;
        v20.i1 = eq v19 1.i256;
        br v20 block7 block3;

    block7:
        v22.*@__fe_tuple_2 = int_to_ptr v0 *@__fe_tuple_2;
        v23.*i256 = gep v22 0.i256 0.i256 1.i256;
        v24.i256 = mload v23 i256;
        v25.i1 = ne v24 0.i256;
        v26.i256 = zext v25 i256;
        v27.i1 = eq v26 1.i256;
        br v27 block8 block3;

    block8:
        v29.*@__fe_tuple_2 = int_to_ptr v0 *@__fe_tuple_2;
        v30.*i256 = gep v29 0.i256 0.i256 0.i256 1.i256;
        v31.i256 = mload v30 i256;
        v32.i1 = ne v31 0.i256;
        v33.i256 = zext v32 i256;
        v34.i1 = eq v33 1.i256;
        br v34 block1 block3;

    block9:
        evm_invalid;

    block10:
        v13.i1 = eq v10 0.i256;
        br v13 block4 block9;
}

func public %__fe_sonatina_entry() {
    block0:
        v1.i256 = call %match_nested_tuple 0.i256;
        evm_stop;
}


object @Contract {
    section runtime {
        entry %__fe_sonatina_entry;
    }
}
